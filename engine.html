$def with (name)

<html>
  <head>
    <script src="./static/jawsjs/jaws.js"></script>
    <script src="./static/jawsjs/audio.js"></script>
    <script src="./static/json/json.js"></script>
    <script src="./static/howler/howler.js"></script>
    <script src="./static/sjcl/sjcl.js"></script>
    <script type="text/javascript" src="./static/jquery/jquery-1.10.2.min.js"></script>
    <link type="text/css" rel="stylesheet" href="./static/style.css" />
    <title>Super Wizard Potion</title>
  </head>
<body>

  <a id="muteButton" href="#" onClick="toggleMute()" style="visibility:hidden;float:right">Sound: On</a>  
  <canvas id="gameScreen" width=600 height=500 style="position:fixed; top:10px; margin-top:10px"></canvas>
  <br>
  <div id="progressButtons" margin="100">
    <div id="saveData" hidden="true">Data to save comes from here.</div>
    <div id="openData" hidden="true">Data to save comes from here.</div>
  </div>
  <div id="live_info"></div>
  <div hidden="true">
    <canvas id="puzzleScreen" width=240 height=400></canvas>
  </div>

  <script>

    // CONSTANTS
    var SLOW = 10
    var FAST = 60
    var BOARD_WIDTH = 6
    var BOARD_HEIGHT = 10
    var ITEM_WIDTH = 40
    var PURPLE_HEX = '#350028'//'#700054'
    var MAX_RAISE_LEVEL_TIME = 20
    var MIN_RAISE_LEVEL_TIME = 6
    var FREQ_RAISE_LEVEL_TIME = 20  // decrease raise_level_time every 20 seconds
    var MARATHON_STAR_LOCK = 100
    var ZERO_STAR_LOCK = 0
    var MENU_FONT = "bold 12pt Menu Text"


    var COLORS = new Array("RED","GREEN","PURPLE","BLUE","YELLOW","ORANGE","EMPTY","WHITE","UNSTABLE")
    var TYPES = new Array("BLOCK","POTION","ROBOT")
    var RED = 0
    var GREEN = 1
    var PURPLE = 2
    var BLUE = 3
    var UNSTABLE = COLORS.length - 1
    var WHITE = COLORS.length - 2
    var EMPTY = COLORS.length - 3

    var COLOR = {
      RED : 0,
      GREEN : 1,
      PURPLE : 2,
      BLUE : 3,
      YELLOW : 4,
      ORANGE : 5,
      EMPTY : 6,
      WHITE : 7
    }

    // PROBABILITIES FOR
    // GENERATING RANDOM ITEMS IN MARATHON
    var ITEM_PROBS = {

    // BLOCKS
      "0|0" : 8 , // RED
      "0|1" : 8 , // GREEN
      "0|2" : 8 , // PURPLE
      "0|4" : 6 , // YELLOW
      "0|7" : 16 , // WHITE

    // POTIONS
      "1|0" : 1 , // RED
      "1|1" : 1 , // GREEN
      "1|2" : 1 , // PURPLE
      "1|4" : 1 , // YELLOW
      "1|6" : 3 , // EMPTY
      "1|7" : 4 , // WHITE

    // ROBOTS
      "2|0" : 6 , // RED
      "2|1" : 6 , // GREEN
      "2|2" : 6 , // PURPLE
      "2|3" : 1 , // RED ARMOR
      "2|4" : 1 , // GREEN ARMOR
      "2|5" : 1 , // PURPLE ARMOR
    }

    // GLOBALS
    var X_SPEED = SLOW
    var Y_SPEED = FAST
    var name_entered = false
    var player_name = ""
    var level_data
    var player_level = 1
    var player_stage = 1
    var player_progress = [[0,{}],[0,{}],[0,{}],[0,{}],[0,{}],[0,{}],[0,{}]]
    var star_progress = [{},{},{},{},{},{},{}]
    var marathon_progress = ["00:00",0]
    var control_scheme = 1
    var game_mode = 1
    var game_record = ""
    var level_edit = false
    var marathon = false
    var latest_edit
    var pause = false
    var main_menu_auto = undefined
    var mute = true
    var sound_effects = new Array()
    var paused_sound_effects = new Array()
    var playing_sound_effects = new Array()
    // player sound effects
    var grab_sound
    var drop_sound
    var break_audio
    var brew_audio
    var splash_audio
    var melt_audio
    var white_audio
    // setupSounds()

    // load cookies if possible
    var cookie_save = getCookie("player_save")
    if (cookie_save != null && cookie_save != "") {
      console.log("cookie loaded")
      console.log(cookie_save.toString())
      var open_data = cookie_save.split("|")
      if (open_data[0] == "SuperWizardPotionSave") {

        console.log("open_data = ")
        console.dir(open_data)
        // window.alert("OPEN DATA")

        player_name = open_data[1]
        player_progress = JSON.parse(open_data[2])
        star_progress = JSON.parse(open_data[3])
        marathon_progress = JSON.parse(open_data[4])

        name_entered = true
      }
    } else {
      console.log("failed to load cookie data")
    }

    function Game() {
      var player
      var star_sprites = new Array()
      var viewport
      var need_to_restart = false
      var game_end = ""
      var game_start = false
      var level_editor
      var pause_menu
      var winlose_data
      var winlose_menu
      var continue_lock_box
      var level_record
      var level_edit_menu
      var level_select_menu
      var level_select_ok
      var winlose = false
      var raise_level_time = MAX_RAISE_LEVEL_TIME
      var continue_menu_item
      var undo_menu_item
      var back_menu_item
      var restart_menu_item = new MenuItem(pause_menu,"Restart",function() {
        // update marathon progress
        if (marathon) {
          if (player.timer.clock_text > marathon_progress[0])
            marathon_progress[0] = player.timer.clock_text
          if (player.score > marathon_progress[1])
            marathon_progress[1] = player.score
          // update player_save data
          var player_save = $("saveData")
          player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
          // update cookie save
          setCookie("player_save",player_save.innerHTML,360000)
        }
        var record = buildRecordString(player.board,"R")
        saveRecord(record)
        game_end = "R"
        jaws.start(Game)
      })

      var save_menu_item = new MenuItem(pause_menu,"Save Level",function() {
        saveLevel(player_level,player_stage,player.board,function() {
          loadLevels(function(data) {
            level_data = JSON.parse(data)
            latest_edit = level_data.levels[0].length + 1
            player_progress[0][0] = latest_edit - 2
          })
        })
      })

      var randomization_array = new Array()

      var player_data
      var screen_data
      var puzzle_data
      var marathon_data
      var star_time
      var star_score
      var beat_marathon_time = false
      var beat_marathon_score = false
      var drew_puzzle_screen = false

      // undo states
      var player_undid = false
      var undo_hand = new Array()
      var undo_board = new Array()

      // hide progress buttons
      var progress_buttons = $("progressButtons")
      progress_buttons.hidden = true

      /* Called once when a game state is activated. Use it for one-time setup code. */
      this.setup = function() {
        // live_info = document.getElementById("live_info")
        live_info = $("live_info")

        viewport = new jaws.Viewport({max_x: 600, max_y: 500})

        console.dir("jaws.context = " + jaws.context.strokeRect)

        // initialize player
        player = new Player(3,0)


        // setup player data in a menu box
        player_data = new MenuBox(
          player_name,
          screen_data,
          player.board.board.x + player.board.board.width + ITEM_WIDTH,
          player.board.board.y,
          160,
          [new MenuItem(screen_data,"  x " + player.stars,function(){return})]
        )
        player_data.index = -1
        var player_stars_sprite = new jaws.Sprite({x:player_data.x+20,y:player_data.y+36,image:"./static/images/STAR.gif",anchor:"left"})   
        player_stars_sprite.width = 15
        player_stars_sprite.height = 15
        star_sprites.push(player_stars_sprite) 
        console.log("starsprite")
        console.dir(player_stars_sprite)       

        // setup screen data in a menu box
        var screen_data_items = new Array()
        screen_data_items.push(new MenuItem(screen_data,(marathon)?("Marathon"):(player_level + "-" + player_stage),function(){return}))
        if (!level_edit) {
          screen_data_items.push(new MenuItem(screen_data,player.timer.clock_text,function(){return}))
          screen_data_items.push(new MenuItem(screen_data,'\u03BB'+player.score,function(){return}))
        }
        screen_data = new MenuBox(
          "Level",
          screen_data,
          player.board.board.x + player.board.board.width + ITEM_WIDTH,
          player_data.y + player_data.height + 1,
          125,
          screen_data_items
        )
        screen_data.index = -1

        console.log("creating box for screen data")

        // Player Controls
        player.controls()

        // fill up the level with items
        // and setup screen data for marathon
        if (marathon) {
          console.log("MARATHON")
          raise_level_time = 24
          player.board.marathonLevel(5)

          var marathon_data_items = new Array()
          marathon_data_items.push(new MenuItem(marathon_data,"Best Time:  " + marathon_progress[0],function(){return}))
          marathon_data_items.push(new MenuItem(marathon_data,"High Score: \u03BB" + marathon_progress[1],function(){return}))

          marathon_data = new MenuBox("",marathon_data,screen_data.x,screen_data.y + screen_data.height + 1,150 + ITEM_WIDTH*2,marathon_data_items)
          marathon_data.index = -1

          // start timer immediately
          game_start = true

          // marathon_star_lock_menu.menu_box.setup(main_menu.x + main_menu.width/2 + ITEM_WIDTH*2, main_menu.y + 20,level_select_ok.menu_box.width)

        } else {
          console.dir(level_data)
          if (level_data.levels[player_level][player_stage-1] != undefined) {
            console.log("filling level " + player_level + "-" + player_stage)
            player.board.fillLevel(player_level,player_stage)
            addStateForUndo(player.hand,player.board)

            console.log("player_progress")
            console.dir(player_progress)

            if (player_progress[player_level][1][player_stage.toString()] != undefined) {
              var best_time = player_progress[player_level][1][player_stage.toString()][0]
              var best_score = player_progress[player_level][1][player_stage.toString()][1]

              var puzzle_data_items = new Array()
              puzzle_data_items.push(new MenuItem(puzzle_data,"Best Time:  " + best_time,function(){return}))
              puzzle_data_items.push(new MenuItem(puzzle_data,"High Score: \u03BB" + best_score,function(){return}))

              puzzle_data = new MenuBox("",puzzle_data,screen_data.x,screen_data.y + screen_data.height + 1,150 + ITEM_WIDTH*2,puzzle_data_items)
              puzzle_data.index = -1
            }

          }
        }

        // pause menu
        pause = false

        var menu_x = player.board.board.x + player.board.board.width/2 - (4*ITEM_WIDTH+15)/2
        var menu_y = player.board.board.y + player.board.board.height/2 - 3*ITEM_WIDTH

        var pause_menu_items = new Array()
        pause_menu_items.push(new MenuItem(pause_menu,"Resume",function() {
          pause = false
          // playPausedSounds()
          player.controls()
        }))
        pause_menu_items.push(((level_edit) ? save_menu_item : restart_menu_item))
        pause_menu_items.push(new MenuItem(pause_menu,"Back to Menu",function() {
          if (!marathon)
            main_menu_auto = [(level_edit) ? 3 : 0,player_level,player_stage]
          else
            main_menu_auto = [1,0,0]
          jaws.start(MainMenu)
        }))

        pause_menu = new MenuBox("Pause!",pause_menu,menu_x, menu_y,4*ITEM_WIDTH+15,pause_menu_items)

        // winlose data
        var winlose_data_items = new Array()
        winlose_data_items.push(new MenuItem(winlose_data_items,"YOU WIN!",function() {return}))
        winlose_data_items.push(new MenuItem(winlose_data_items,"Time:",function() {return}))
        winlose_data_items.push(new MenuItem(winlose_data_items,"Score:",function() {return}))
        winlose_data_items.push(new MenuItem(winlose_data_items,"",function() {return}))

        winlose_data = new MenuBox("",winlose_data,menu_x, menu_y, 4*ITEM_WIDTH+15, winlose_data_items)

        // add star sprites for winlose data
        for (var s=0; s < winlose_data_items.length; s++) {
          var this_sprite = new jaws.Sprite({x:winlose_data.x,y:winlose_data.y+36 + 20*(s-1),anchor:"left"})
          this_sprite.width = 15
          this_sprite.height = 15
          winlose_data_items[s].sprites.push(this_sprite)

          console.log("winlose sprite, s = " + s)
          console.dir(winlose_data_items[s].sprites[0])
        }

        // winlose menu
        continue_menu_item = new MenuItem(winlose_menu,"Continue",function() {

          // advance the player to the next level
          console.log("player_stage = " + player_stage)
          console.dir(level_data)
          if (player_stage < level_data["levels"][player_level].length) {
            player_stage++
          } else {
            player_level++
            player_stage = 1
          }
          console.log("player_stage = " + player_stage)

          // reset board
          jaws.start(Game)
        })
        continue_menu_item.active = false
        undo_menu_item = new MenuItem(winlose_menu,"Undo",function() {
          winlose = false
          winlose_menu.active = false

          winlose_menu.y = winlose_data.y + winlose_data.height
          winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

          // color timer to be red to indicate game end
          screen_data.index = -1
          game_end = ""
          player.controls()
          undoLastMove(true)
        })
        back_menu_item = new MenuItem(winlose_menu,"Back to Menu",function() {
          if (!marathon)
            main_menu_auto = [(level_edit) ? 3 : 0,player_level,player_stage]
          else
            main_menu_auto = [1,0,0]
          jaws.start(MainMenu)
        })
        winlose_menu = new MenuBox(" ",winlose_menu,menu_x, winlose_data.y + winlose_data.height,4*ITEM_WIDTH+15,[])

        // to display star lock to continue to next world
        continue_lock_box = new OkSubMenu("",winlose_menu,function() { return })
        continue_lock_box.menu_box.setup(winlose_menu.x + winlose_menu.width - 50, winlose_menu.y+40,continue_lock_box.menu_box.width)
        continue_lock_box.menu_box.index = -1

        // lock sprite
        var lock_sprite = new jaws.Sprite({x:continue_lock_box.menu_box.x+21,y:continue_lock_box.menu_box.y,image:"./static/images/LOCK.gif",anchor:"left"})        
        continue_lock_box.menu_box.sprites.push(lock_sprite)
        lock_sprite.active = true

        // star lock sprite
        var star_lock_sprite = new jaws.Sprite({x:continue_lock_box.menu_box.x+64,y:continue_lock_box.menu_box.y+17,image:"./static/images/STAR.gif",anchor:"left"})        
        star_lock_sprite.width = 15
        star_lock_sprite.height = 15
        continue_lock_box.menu_box.sprites.push(star_lock_sprite)
        star_lock_sprite.active = true        

        // level record data
        var level_record_items = new Array()
        level_record_items.push(new MenuItem(level_record,"Completed!",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Time:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Score:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"",function() {return}))

        level_record = new MenuBox("",level_record,winlose_menu.x + winlose_menu.width - 50, winlose_menu.y+40, 230, level_record_items)
        level_record.index = -1
        level_record.active = false

        // add star sprites for level record data
        for (var s=0; s < level_record_items.length; s++) {
          var this_sprite = new jaws.Sprite({x:level_record.x,y:level_record.y+36 + 20*(s-1),anchor:"left",image:"./static/images/STAR.gif"})
          this_sprite.width = 15
          this_sprite.height = 15
          this_sprite.active = false
          level_record.sprites.push(this_sprite)

        }


        // level editor
        if (level_edit) {
          level_editor = new LevelEditor(player.board)

          // level edit menu
          var level_edit_menu_items = new Array()
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"New",function() {
            console.log("New")
            player_stage = latest_edit
            console.log("editing level 0-" + player_stage)
            jaws.start(Game)
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Load",function() {
            console.log("Load")
            level_select_menu.active = true
            level_select_menu.controls(level_select_menu,level_select_ok)
            level_select_ok.menu_box.active = true
            level_select_string = player_level + "-" + player_stage
            level_select_menu.items[0].text = level_select_string
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Save",function() {
            console.log("Save")
            saveLevel(player_level,player_stage,player.board,function() {
              loadLevels(function(data) {
                level_data = JSON.parse(data)
                latest_edit = level_data.levels[0].length + 1
                player_progress[0][0] = latest_edit - 2
              })
            })
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Copy",function() {
            console.log("Copy")
            player_level = 0
            player_stage = latest_edit
            console.log(player_stage)
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Delete",function() {
            console.log("Delete")
            if (player_stage == latest_edit) {
              jaws.start(Game)
            } else {
              deleteLevel (player_level,player_stage,function(latest){
                console.log("latest = " + latest)
                latest_edit = latest - 1
                player_progress[0][0] = latest_edit
                player_stage = latest_edit
                jaws.start(Game)
              })
            }
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Clear",function() {
            console.log("Clear")
            player.board.clearBoard()
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Quit",function() {
            console.log("Quit")
            jaws.start(MainMenu)
          }))

          level_edit_menu = new MenuBox("",level_edit_menu,level_editor.board.x + level_editor.board.width + 10, level_editor.board.y,3*ITEM_WIDTH,level_edit_menu_items)

          level_edit_menu.active = true

          var level_select_string = player_level + "-" + player_stage

          // level select menu
          level_select_menu = new MenuBox("Level",level_edit_menu,level_edit_menu.x, level_edit_menu.y + level_edit_menu.height + 1, level_edit_menu.width, [new MenuItem(level_select_menu,level_select_string,function() {
            if (player_stage == latest_edit) {
              level_select_menu.active = false
              level_select_ok.menu_box.active = false
              player.controls()
            }
            else
              jaws.start(Game)
          })])

          level_select_menu.level = player_level
          level_select_menu.stage = player_stage

          // level select arrows
          level_select_menu.arrow_sprites = new jaws.SpriteSheet({
            image: "./static/images/ARROWS.gif", frame_size: [20,10]})

          level_select_menu.up_arrow = new jaws.Sprite({x:level_select_menu.x + 85, y:level_select_menu.y + 20, image: level_select_menu.arrow_sprites.frames[0]})
          level_select_menu.down_arrow = new jaws.Sprite({x:level_select_menu.x + 85, y:level_select_menu.y + 38, image: level_select_menu.arrow_sprites.frames[1]})

          level_select_menu.up_arrow.height = 15
          level_select_menu.down_arrow.height = 15

          level_select_menu.up_arrow.mouse_over = false
          level_select_menu.down_arrow.mouse_over  = false

          level_select_menu.up_arrow.active = true
          level_select_menu.down_arrow.active = true

          level_select_menu.sprites.push(level_select_menu.up_arrow)
          level_select_menu.sprites.push(level_select_menu.down_arrow)

          level_select_menu.update = function() {

            // update arrow sprites
            for (var s=0; s < level_select_menu.sprites.length; s++) {
              var this_sprite = level_select_menu.sprites[s]
              if (this_sprite.mouse_over && this_sprite.image == level_select_menu.arrow_sprites.frames[s])
                this_sprite.image = level_select_menu.arrow_sprites.frames[s+2]
              else if (!this_sprite.mouse_over && this_sprite.image == level_select_menu.arrow_sprites.frames[s+2])
                this_sprite.image = level_select_menu.arrow_sprites.frames[s]
            }

            if (level_edit) {
              if (level_select_menu.stage == latest_edit)
                this.sprites[0].active = false
              else
                this.sprites[0].active = true
              if (level_select_menu.stage == 1)
                this.sprites[1].active = false
              else
                this.sprites[1].active = true
            } else {
              if (level_select_menu.level == player_progress.length-1 && level_select_menu.stage == player_progress[player_progress.length-1][0])
                this.sprites[0].active = false
              else
                this.sprites[0].active = true
              if (player_progress[0][0] > 0) {
                if (level_select_menu.level == 0 && level_select_menu.stage == 1)
                  this.sprites[1].active = false
                else
                  this.sprites[1].active = true
              } else {
                if (level_select_menu.level == 1 && level_select_menu.stage == 1)
                  this.sprites[1].active = false
                else
                  this.sprites[1].active = true

              }

            }

          }

          level_select_menu.controls = function(menu,ok_submenu) {

            menu.up_action = function() {

              console.log("down_action")

              if (level_edit) {

                if (level_select_menu.stage < latest_edit)
                  level_select_menu.stage++

              } else {

                if (level_select_menu.stage < player_progress[level_select_menu.level][0]) {
                  level_select_menu.stage++
                } else {
                  if (level_select_menu.level < player_progress.length - 1) {
                    level_select_menu.level++
                    level_select_menu.stage = 1
                  }
                }

              }

              level_select_string = level_select_menu.level + "-" + level_select_menu.stage
              menu.items[0].text = level_select_string

            }

            menu.down_action = function() {

              console.log("down_action")

              if (level_select_menu.stage > 1)
                level_select_menu.stage--
              else if (level_select_menu.level > 0 && player_progress[level_select_menu.level-1][0] > 0){
                if(level_edit) return
                level_select_menu.level--
                level_select_menu.stage = player_progress[level_select_menu.level][0]
              }

              level_select_string = level_select_menu.level + "-" + level_select_menu.stage
              menu.items[0].text = level_select_string

            }

            jaws.on_keydown(["up","w"], function() {

              menu.up_action()

            })

            jaws.on_keydown(["down","s"], function() {

              menu.down_action()

            })

            jaws.on_keydown(["enter","space"], function() {
              console.log("performing action")
              menu.items[menu.index].action(jaws)
            })

            jaws.on_keydown(["esc","a","left"], function() {
              menu.back()
            })

            jaws.on_keydown(["left_mouse_button"], function() {
              console.log("click button")
              if (menu.sprites[0].mouse_over) {
                menu.up_action()
                console.log("up button")
              }
              else if (menu.sprites[1].mouse_over) {
                console.log("click on down arrow")
                menu.down_action()
              }
              else if (ok_submenu.menu_box.mouse_inside) {
                console.log("ok!")
                player_level = menu.level
                player_stage = menu.stage
                menu.items[menu.index].action()
              }
              else if (menu.mouse_inside)
                return
              else {
                console.log("elsing")
                menu.active = false
                ok_submenu.menu_box.active = false
                player.controls()
              }
            })

          }

          level_select_ok = new OkSubMenu("",level_select_menu,function() {
            level_select_menu.items[menu.index].action(jaws)
          })

        }

        console.log("setup game")
        console.log("player_name = " + player_name)
        console.log("live_info = " + live_info)

        jaws.context.mozImageSmoothingEnabled = false;  // non-blurry, blocky retro scaling
        jaws.preventDefaultKeys(["w", "s", "a", "d", "k"])

      }

      /* update() will get called each game tick with your specified FPS. Put game logic here. */
      this.update = function() {

        if (need_to_restart)
          jaws.start(Game)

        if ((game_end == "W" || game_end == "L") && !winlose) {
          player.board.winLose()
        }

        if (pause) {
          // console.log(pause_menu)
          pause_menu.controls(pause_menu)
        }

        player.update()

        if (marathon) {
          if (!beat_marathon_time) {
            if (player.timer.clock_text > marathon_progress[0]) {
              beat_marathon_time = true
              marathon_data.items[0].color = "Grey"
            }
          }
          // check if player beat marathon high score
          if (!beat_marathon_score) {
            if (player.score > marathon_progress[1]) {
              beat_marathon_score = true
              marathon_data.items[1].color = "Grey"
            }
          }
        }

        if(level_edit) {
          level_editor.update()
          if(!level_edit_menu.mouse_inside)
            level_edit_menu.index = -1
          if(level_select_menu.active)
            level_select_menu.update()
          if(level_select_ok.menu_box.active)
            level_select_ok.update()
        }

        if (winlose_menu.active && game_end == "W") {
          if (player_progress[player_level][0] >= level_data.levels[player_level].length){
            if (winlose_menu.index > 0 && winlose_menu.index <= level_data.levels[player_level].length) {
              level_record.active = true
              continue_lock_box.active = false
              var level_item = winlose_menu.items[winlose_menu.index]
              var level_name = level_item.text.split("-")
              var level = parseInt(level_name[0])
              var stage = level_name[1]
              if (player_progress[level] != undefined && player_progress[level][1][stage] != undefined) {
                level_record.items[1].text = "Best Time:  " + player_progress[level][1][stage][0]
                level_record.items[2].text = "High Score: \u03BB" + player_progress[level][1][stage][1]
                
                // show appropriate stars
                level_record.sprites[0].active = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? true : false
                level_record.sprites[1].active = (star_progress[level][stage] != undefined && star_progress[level][stage][1] > 0) ? true : false
                level_record.sprites[2].active = (star_progress[level][stage] != undefined && star_progress[level][stage][2] > 0) ? true : false
                level_record.sprites[3].active = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? true : false
                level_record.items[0].text = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? "Completed!" : "Completed (undo)"
                level_record.items[3].text = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? "Perfect" : ""
              }
            } else if (winlose_menu.index == 0) {
              level_record.active = false
              if (winlose_menu.items[0].active && winlose_menu.items[0].locked) {
                continue_lock_box.active = true
                var next_level = (level_data.levels[parseInt(player_level) + 1] != undefined) ? level_data.levels[parseInt(player_level) + 1][0] : undefined
                var next_star_lock = (next_level != undefined) ? next_level.split('\n')[8] : undefined   
                continue_lock_box.menu_box.items[0].text = "      x " + ((next_star_lock == undefined) ? "?" : next_star_lock)

              }
            } else {
              level_record.active = false
              continue_lock_box.active = false
            }
          }
        }


        live_info.innerHTML = jaws.game_loop.fps + " fps. Player: " + parseInt(player.x) + "/" + parseInt(player.y) + ". "
        live_info.innerHTML += "Viewport: " + parseInt(viewport.x) + "/" + parseInt(viewport.y) + "."

      }

      /* Directly after each update draw() will be called. Put all your on-screen operations here. */
      this.draw = function() {
        jaws.clear()

        // background
        jaws.context.fillStyle = 'Black' //PURPLE_HEX
        jaws.context.fillRect(0,0,600,500)

        // the viewport magic. wrap all draw()-calls inside viewport.apply and it will draw those relative to the viewport.
        viewport.apply( function() {
          player.draw()
          player_data.draw()
          screen_data.draw()
          if (marathon)
            marathon_data.draw()
          else (!level_edit)
            if (puzzle_data != undefined) puzzle_data.draw()
          for (var s=0; s < star_sprites.length; s++) {
            star_sprites[s].draw()
          }
          if(level_edit) {
            level_editor.draw()
            level_edit_menu.draw()
            if (level_select_menu.active)
              level_select_menu.draw()
            if (level_select_ok.menu_box.active)
              level_select_ok.draw()
          }
        });

        // display board on puzzleScreen
        if (!drew_puzzle_screen && level_edit) {
          var gamescreen_canvas = $("gameScreen")
          var puzzleScreen_canvas = $("puzzleScreen")
          puzzleScreen.getContext("2d").drawImage(gamescreen_canvas,40,40,240,400,0,0,240,400)

          // save as jpg
          var data_url = puzzleScreen_canvas.toDataURL( "image/png" , 1 )

          // window.prompt("encoded data",data_url.substring(data_url.indexOf(",")+1,data_url.length))

          saveImage(player_level,player_stage,data_url.substring(data_url.indexOf(",")+1,data_url.length))

          // window.open(data_url, '_blank')

          drew_puzzle_screen = true          
        }

        if (continue_lock_box.active)
          continue_lock_box.draw()

        if (level_record.active)
          level_record.draw()

      }

      /* Constructor for Player */
      function Player(x,y) {

        // player consists of a board and hand
        // board consists of six stacks, hand is a stack
        // stack consists of items
        // an item has type and color

        this.x = x
        this.y = y
        this.board = new Board(this)
        this.hand = new Stack(this.board, -1) // passing in Player board
        this.cursor_speed = X_SPEED
        this.score = 0
        this.control_scheme = 0
        this.keyboard_actions = 0
        this.mouse_actions = 0
        this.stars = starTotal()
        this.new_stars = 0 // new stars player acquired for this

        this.sprite_sheet = new jaws.SpriteSheet({
          image: "./static/images/CURSOR.gif", frame_size: [40,20]})

        this.cursor_top = new jaws.Sprite({x:this.board.posx(x), y:this.board.posy(y), image: this.sprite_sheet.frames[0]})
        this.cursor_bottom = new jaws.Sprite({x:this.board.posx(x), y:(this.board.posy(y)+20), image: this.sprite_sheet.frames[1]})

        // player timer
        this.timer = new Timer(this)

        // count player actions
        this.moves = 0

        // record player actions
        this.replay_data = {}

        this.addScore = function(points) {
          if (level_edit)
            return
          this.score += points
          screen_data.items[2].text = '\u03BB' + this.score
        }

        // player controls
        this.controls = function() {

          jaws.on_keydown(["enter","esc","p"], function() {

            if (game_end == "")
              pauseGame(pause_menu,player,restart_menu_item,save_menu_item)

          })

          jaws.on_keydown(["l"], function() {
            if (marathon && !player.board.stacksBreaking() && !player.board.stacksFull()) {
              player.board.raiseStacks()
              player.addScore(1)
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"raise",0]
            }
          })

          jaws.on_keydown(["left","a"], function() {
            if (pause || game_end != "") return
            X_SPEED = SLOW
            player.control_scheme = 0
            if(player.x > 0) {
              if (player.canMoveX(-1)) player.moveX(-1)
              else {
                // drop minimum amount of items on hand so hand can move left
                var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x - 1].items.length)
                if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x - 1].items.length > 0) {
                  player.drop(player.board.stacks[player.x],drop_amount)
                  player.moveX(-1)
                }
              }
            }
            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["right","d"], function() {
            if (pause || game_end != "") return
            X_SPEED = SLOW
            player.control_scheme = 0
            if(player.x < BOARD_WIDTH - 1) {
              if (player.canMoveX(1)) player.moveX(1)
              else {
                // drop minimum amount of items on hand so hand can move right
                var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x + 1].items.length)
                if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x + 1].items.length > 0) {
                  player.drop(player.board.stacks[player.x],drop_amount)
                  player.moveX(1)
                }

              }
            }
            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["up","w"], function() {
            if (pause || game_end != "") return
            player.control_scheme = 0
            if(player.y < BOARD_HEIGHT-1)player.y += 1
            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["down","s"], function() {

            if (pause || game_end != "") return
            player.control_scheme = 0
            if(player.hand.items.length>0) {
              player.drop(player.board.stacks[player.x],player.hand.items.length)
            } else if(player.y > 0) player.y -= 1


            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["k","c"], function() {
            if (pause || game_end != "") return
            if(player.hand.items.length == 0) {
              player.grab(player.board.stacks[player.x],player.board.stacks[player.x].items.length)
            } else {
              player.drop(player.board.stacks[player.x],player.hand.items.length)
            }
            player.control_scheme = 0
            player.keyboard_actions++
          })
          jaws.on_keydown(["x","j","space"], function() {
            if (pause || game_end != "") return
            if(player.hand.items.length == 0) {
              //grab depth determined by cursor y-position
              var depth = player.board.stacks[player.x].items.length - player.y
              player.grab(player.board.stacks[player.x],depth)
            } else {
              //drop
              player.drop(player.board.stacks[player.x],1)
            }
            player.control_scheme = 0
            player.keyboard_actions++
          })


          var ctrl = false

          jaws.on_keydown(["ctrl"], function () {
            ctrl = true
          })

          jaws.on_keyup(["ctrl"], function () {
            ctrl = false
          })

          jaws.on_keydown(["z"], function() {
            if (ctrl)
              undoLastMove()
          })

          jaws.on_keydown(["r"], function() {

            if (!ctrl)
              return

            // stop all sounds currently playing
            for (var i=0; i<player.board.sounds.length;i++) {
              var this_sound = player.board.sounds[i]
              this_sound.stop()
              removeFromPlayingSounds(this_sound)
            }
            // update marathon progress
            if (marathon) {
              if (player.timer.clock_text > marathon_progress[0])
                marathon_progress[0] = player.timer.clock_text
              if (player.score > marathon_progress[1])
                marathon_progress[1] = player.score
              // update player_save data
              var player_save = $("saveData")
              player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
              // update cookie save
              setCookie("player_save",player_save.innerHTML,360000)
            }
            var record = buildRecordString(player.board,"R")
            saveRecord(record)
            game_end = "R"
            jaws.start(Game)
          })

          jaws.on_keydown(["left_mouse_button"], function() {
            if (pause || game_end != "") return
            var click_coordinates = new Array()
            click_coordinates = player.board.boardCoordinates(jaws.mouse_x,jaws.mouse_y)
            console.log("click coordinates on board: (" + click_coordinates[0] + "," + click_coordinates[1] + ")")
            player.clickAction(click_coordinates)
          })

          jaws.on_keydown(["right_mouse_button"], function() {
            if (pause || game_end != "") return
            var click_coordinates = new Array()
            click_coordinates = player.board.boardCoordinates(jaws.mouse_x,jaws.mouse_y)
            console.log("right click coordinates on board: (" + click_coordinates[0] + "," + click_coordinates[1] + ")")
            player.clickAction(click_coordinates,true)
          })

        }

        // check if player hand can move in x direction
        this.canMoveX = function(x) {

          // check if stacks overlap
          if (this.board.stacks[this.x + x].items.length + this.hand.items.length > BOARD_HEIGHT)
            return false

          return true
        }

        // move the player hand in x direction
        this.moveX = function(x) {

          this.x += x

          //update each item in hand
          for (var i=0; i<this.hand.items.length; i++) {
            var item = this.hand.items[i]
            item.x = this.x
            item.sprite.dx = this.board.posx(this.x)
          }

          console.log("player x = " + this.x)
        }

        this.moveX_click = function(x) {

          var sign = x?x<0?-1:1:0
          var hit_wall = false

          for (var i=0; i < Math.abs(x); i++) {
            if (this.canMoveX(sign)) player.moveX(sign)
            else {
              // drop minimum amount of items on hand so hand can move left
              var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x + sign].items.length)
              hit_wall = true
              if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x + sign].items.length > 0) {
                player.drop(player.board.stacks[player.x],drop_amount)
                player.moveX(sign)
              }
            }
          }

          return hit_wall

        }

        // grab depth amount of items from stack
        this.grab = function(stack,depth) {

          // record this action
          this.replay_data[this.timer.frame_ticker.toString()]
            = [this.x,this.y,"grab",depth]

          // start the timer
          if (!game_start)
            game_start = true

          // count player moves
          this.moves++

          // move the cursor quickly to the top of the screen
          Y_SPEED = FAST
          this.cursor_speed = Y_SPEED

          // loop through the items of the stack according to depth passed in
          // pop items and push to the player hand, one by one
          for(var i=0; i<depth; i++) {

            // push top of stack to hand
            var item = stack.items.pop()
            if (item.breaking) {
              stack.items.push(item)
              break
            }
            this.hand.items.push(item)

            // update hand position
            item.x = this.x
            item.y = BOARD_HEIGHT - 1 - i
            item.stack = this.hand

            // update sprite destination
            item.sprite.dx = this.board.posx(item.x)
            item.sprite.dy = this.board.posy(item.y)

            // reset chain
            item.chain = 0

          }

          // add current state of board and hand to undo arrays
          addStateForUndo(this.hand,this.board)

          // play sound effect
          // if (depth > 0) {
          //   grab_sound.stop()
          //   removeFromPlayingSounds(grab_sound)
          //   if (!mute)
          //     drop_sound.play()
          // }
        }

        // drop depth amount of items onto stack
        this.drop = function(stack,depth) {

          // record this action
          this.replay_data[this.timer.frame_ticker.toString()]
            = [this.x,this.y,"drop",depth]          

          this.moves++
          console.log("player moves = " + this.moves)

          Y_SPEED = FAST

          var hand_items = this.hand.items
          var stack_items = stack.items

          for(var i=0; i<depth; i++) {
            stack.items.push(hand_items.pop())

            // update stack items
            var item = stack_items.pop()
            item.x = this.x
            item.y = stack_items.length
            item.stack = stack

            // update sprite destination
            item.sprite.dx = this.board.posx(item.x)
            item.sprite.dy = this.board.posy(item.y)

            stack_items.push(item)

          }

          // reset chain for all items on stack if none are breaking
          if (!stack.itemsBreaking())
            stack.setChain(stack.items,0)

          // check for matches
          stack.checkForMatches()

          // reposition player's y position if hand is now empty
          if (hand_items.length == 0)
            this.y = stack_items.length - depth // at item at bottom of hand stack

          // add current state of board and hand to undo arrays
          addStateForUndo(this.hand,this.board)

          // play sound effects
          // drop_sound.stop()
          // removeFromPlayingSounds(drop_sound)
          // grab_sound.stop()
          // removeFromPlayingSounds(grab_sound)
          // if (!mute)
          //   grab_sound.play()

        }

        this.clickAction = function(click_coordinates,right_click) {

          var click_x = click_coordinates[0]
          var click_y = click_coordinates[1]
          right_click = typeof right_click !== 'undefined' ? right_click : false;

          var click_outside_board = false

          // normal gameplay
          if (!level_edit) {
            this.mouse_actions++
            this.control_scheme = 1

            if (click_x < 0 || click_y < 0)
              click_outside_board = true

            if (click_outside_board && marathon) {
              if (marathon && !player.board.stacksBreaking() && !player.board.stacksFull()) {
                player.board.raiseStacks()
                player.addScore(1)
                // record this action
                player.replay_data[player.timer.frame_ticker.toString()]
                  = [player.x,player.y,"raise",0]
              }
              return
            }

            // move player cursor to clicked x coordinate
            if (Math.abs(click_x - this.x) > 1) X_SPEED = FAST
            else X_SPEED = SLOW

            var this_stack = this.board.stacks[click_x]
            var depth = 0
            var old_x = this.x

            // move the hand and catch if it hit a wall
            var hit_wall = this.moveX_click(click_x - this.x)
            this_stack = this.board.stacks[this.x] // update this_stack

            // grab if hand is empty
            if (this.hand.items.length == 0) {

              // grab if item on stack is clicked
              if (right_click)
                depth = this_stack.items.length
              else if (this_stack.items.length >= click_y) {
                depth = this_stack.items.length - click_y // how many items to grab
              }

              this.grab(this_stack,depth)

            // drop if hand is holding items
            } else {

              // determine y coordinate of bottom of hand stack
              var cutoff = BOARD_HEIGHT - this.hand.items.length
              console.log("click_y = " + click_y)
              console.log("cutoff = " + cutoff)
              if (right_click)
                depth = this.hand.items.length
              else if (click_y < cutoff) {
                depth = 1
              } else if (old_x == click_x) {
                depth = click_y - cutoff + 1
              } else if (old_x != click_x) {
                if (click_y == this_stack.items.length)
                  depth = 1
              }

              // drop remaining items on hand
              console.log("depth = " + depth)
              this.drop(this_stack,depth)

            }

          // controls for level editor
          } else if (level_edit) {

            level_editor.controls(click_x, click_y, right_click)
            if (level_edit_menu.mouse_inside) {
              level_edit_menu.items[level_edit_menu.index].action()
            }

          }
        }



        // update player sprites positions
        this.updatePlayerSprites = function(dx,dy) {

          var cursor_top = this.cursor_top
          var cursor_bottom = this.cursor_bottom

          cursor_top.dx = cursor_bottom.dx = this.board.posx(this.x)

          if (this.hand.items.length == 0) {
            cursor_top.dy = this.board.posy(this.y)
            cursor_bottom.dy = this.board.posy(this.y) + cursor_bottom.height
          } else {
            cursor_top.dy = this.board.posy(BOARD_HEIGHT-1)
            cursor_bottom.dy = this.board.posy(BOARD_HEIGHT - this.hand.items.length) + cursor_bottom.height
          }

          spriteMove(cursor_top,X_SPEED,this.cursor_speed)
          spriteMove(cursor_bottom,X_SPEED,this.cursor_speed)

          // reset cursor speed when it reaches dy
          if (this.hand.items.length == 0 && cursor_top.dy == cursor_top.y) this.cursor_speed = X_SPEED


        }

        // update player sprites, board sprites, etc.
        this.update = function() {

          if (pause)
            return

          // update timer
          this.timer.update()

          // update cursor position
          var cursor = this.cursor

          // cursor.dx = this.board.posx(this.x)
          // cursor.dy = this.board.posy(this.y)
          // spriteMove(cursor,X_SPEED,X_SPEED)

          this.updatePlayerSprites(this.board.posx(this.x),this.board.posy(this.y))

          this.board.update() // updates sprites for each stack
          this.hand.update()  // updates sprites for items in hand

        }

        // draw everything that was just updated
        this.draw = function() {

          this.board.draw()

          if (pause || game_end != "")
            return

          if (marathon) {
            // draw hand, flash if stack is full
            var this_stack = this.board.stacks[this.x]
            var this_stack_full = (this_stack.items.length + this.hand.items.length == BOARD_HEIGHT)
            // var danger_time = (player_timer.raise_level_timer < raise_level_time/4) ? ((player_timer.ticker%8==0) ? true : false) : false
            var danger_time = (this.timer.ticker%8==0) ? true : false
            if (!this_stack_full || !danger_time || this_stack.itemsBreaking()) {
              this.hand.draw()
            }
          } else
            this.hand.draw()
          // jaws.context.drawImage(jaws.assets.get("images/CURSOR.gif"), this.cursor.x, this.cursor.y)

          if (control_scheme == 2 && this.hand.items.length == 0)
            return

          if (this.control_scheme == 0 || this.hand.items.length > 0) {
            this.cursor_top.draw()
            this.cursor_bottom.draw()
          }
        }

      }

      function LevelEditor(board) {

        this.x = board.board.x + ITEM_WIDTH * (BOARD_WIDTH + 1)
        this.y = board.board.y + ITEM_WIDTH * 2
        this.board = new jaws.Sprite({x:this.x,y:this.y,image:"./static/images/BOARD.gif",anchor:"left"})
        this.board.width = ITEM_WIDTH * 3
        this.board.height = ITEM_WIDTH * 8

        this.flasks = new Array()
        this.blocks = new Array()
        this.robots = new Array()

        // provide position with respect to this Board
        this.posx = function(x) { return this.x + x * ITEM_WIDTH }
        this.posy = function(y) { return this.y + (8 - 1 - y)*ITEM_WIDTH }

        // flasks
        for (var f = 0; f < 8; f++) {
          this.flasks.push(new jaws.Sprite({x:this.posx(0),y:this.posy(f),image:"./static/images/POTION_" + COLORS[(f==6) ? 7 : ((f==7) ? 6 : f)] + ".gif",anchor:"left"}))
        }

        // blocks
        for (var b = 0; b < 7; b++) {
          this.blocks.push(new jaws.Sprite({x:this.posx(1),y:this.posy(b),image:"./static/images/" + COLORS[(b==6) ? 7: b] + ".gif",anchor:"left"}))
          console.log("creating block_sprite = " + this.blocks[b])
        }

        for (var r = 0; r < 6; r++) {
          // create sprite for this robot
          this.robots.push(new jaws.Sprite({x:this.posx(2),y:this.posy(r), anchor: "left"}))
          var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + COLORS[r] + ".gif", frame_size: [40,40], frame_duration: 100})
          this.robots[r].anim_default = anim.slice(0,5)
          this.robots[r].setImage(this.robots[r].anim_default.next())
          console.log("creating robot_sprite = " + this.robots[r])
        }

        this.hand = new jaws.Sprite(this.flasks[this.flasks.length-1])
        this.hand.type = 1
        this.hand.color = EMPTY

        this.controls = function(click_x, click_y, right_click) {
          var color

          // catch clicks made in toolbox
          if (click_x >= 7 && click_x <= 9) {

            if (click_y >= 0 && click_y <= 5) {
              color = click_y
            } else if (click_y == 6) {
              if (click_x <= 8)
                color = WHITE
            } else if (click_y == 7) {
              if (click_x == 7)
                color = EMPTY
            }

            if (click_x == 7) {
              level_editor.hand = new jaws.Sprite(level_editor.flasks[click_y])
              level_editor.hand.type = 1
            }
            else if (click_x == 8) {
              if (click_y > 6)
                return
              level_editor.hand = new jaws.Sprite(level_editor.blocks[click_y])
              level_editor.hand.type = 0
            }
            else if (click_x == 9) {
              if (click_y > 5)
                return
              level_editor.hand = new jaws.Sprite(level_editor.robots[click_y])
              level_editor.hand.type = 2
            }
            level_editor.hand.color = color

            console.log("click with type = " + level_editor.hand.type + " and color = " + level_editor.hand.color)

          // catch clicks made on board
          } else if (click_x >=0 && click_x <= 5) {

            var this_stack = player.board.stacks[click_x]
            console.log("player = " + player)
            console.log("player.board = " + player.board)
            console.log("player.board.stacks = " + player.board.stacks)
            var cutoff = this_stack.items.length

            // add item if above stack
            if (click_y >= cutoff) {

              if (right_click) {

                while (this_stack.items.length < BOARD_HEIGHT) {
                  this_stack.items.push(new Item(this_stack,level_editor.hand.type,level_editor.hand.color,click_x,this_stack.items.length))

                  // items fall after spawn
                  var this_item = this_stack.items[this_stack.items.length-1]
                  console.log("this_item = " + this_item)
                  this_item.sprite.x = player.board.posx(click_x)
                  this_item.sprite.y = player.board.posy(click_y)

                }

              // remove item clicked
              } else {

                if (this_stack.items.length < BOARD_HEIGHT) {
                  this_stack.items.push(new Item(this_stack,level_editor.hand.type,level_editor.hand.color,click_x,this_stack.items.length))

                  // items fall after spawn
                  var this_item = this_stack.items[this_stack.items.length-1]
                  console.log("this_item = " + this_item)
                  this_item.sprite.x = player.board.posx(click_x)
                  this_item.sprite.y = player.board.posy(click_y)

                }

              }

            // remove item clicked on stack
            } else {

              var this_item = this_stack.items[click_y]

              if (right_click) {

                var matches = new Array()
                var last_match = this_stack.items[0]
                var this_match
                var touched_this_item = false

                matches.push(last_match)
                console.log("pushing onto matches: (" + last_match.type + "," + last_match.color + ")")

                // THIS WAS DONE WITH TRIAL AND ERROR. TODO: COMMENTS
                for (var i=1; i < this_stack.items.length; i++) {

                  console.log("i = " + i)

                  this_match = this_stack.items[i]

                  if (this_match.type==last_match.type && this_match.color==last_match.color) {
                    matches.push(this_match)
                    console.log("pushing onto matches: (" + this_match.type + "," + this_match.color + ")")
                    last_match = this_match
                  } else {

                    if (i > click_y)
                      touched_this_item = true

                    if (!touched_this_item) {
                      matches = new Array()
                      matches.push(this_match)
                      console.log("pushing onto matches: (" + this_match.type + "," + this_match.color + ")")
                      last_match = this_match
                    } else {
                      break
                    }

                  }

                }

                console.log("matches = " + matches)
                this_stack.removeItems(matches)

              } else {

                // remove clicked item
                this_stack.removeItem(this_item)

              }

              var sprite_stack = (this_item.type == 0) ? this.blocks : (
                (this_item.type == 1) ? this.flasks : this.robots
                )

              if(this_item.color == WHITE)
                color = 6
              else if (this_item.color == EMPTY)
                color = 7
              else
                color = this_item.color

              this.hand = new jaws.Sprite(sprite_stack[color])
              this.hand.type = this_item.type
              this.hand.color = this_item.color

            }
          }
        }

        this.update = function() {
          this.hand.x = jaws.mouse_x - ITEM_WIDTH/2
          this.hand.y = jaws.mouse_y - ITEM_WIDTH/2
        }

        this.draw = function() {

          this.hand.draw()
          this.board.draw()

          for (var f = 0; f < this.flasks.length; f++) {
            this.flasks[f].draw()
          }
          for (var b = 0; b < this.blocks.length; b++) {
            this.blocks[b].draw()
          }
          for (var r = 0; r < this.robots.length; r++) {
            this.robots[r].draw()
          }

        }

      }

      /* Constructor for board */
      function Board(player) {
        this.player = player
        this.stacks = new Array()
        this.board = new jaws.Sprite({x:ITEM_WIDTH,y:ITEM_WIDTH,image:"./static/images/BOARD.gif",anchor:"left"})

        this.block_count = [0,0,0,0,0,0,0,0]
        this.flask_count = [0,0,0,0,0,0,0,0,0]
        this.robot_count = [0,0,0,0,0,0]

        this.effects = new Array()
        this.sounds = new Array()

        this.undo_alpha = 0

        // provide position with respect to this Board
        this.posx = function(x) { return this.board.x + x * ITEM_WIDTH }
        this.posy = function(y) { return this.board.y + (BOARD_HEIGHT - 1 - y)*ITEM_WIDTH }

        this.clearBoard = function() {

         for (var s = 0; s < this.stacks.length; s++) {
          var this_stack = this.stacks[s]
          this_stack.items = new Array()
         }

        }

        // generate random item
        this.randomItem = function(stack,x,y) {

          var type_color_string = randomization_array.pop()
          randomization_array.push(type_color_string)
          fisherYates(randomization_array)
          var type_color = type_color_string.split("|")
          var type = type_color[0]
          var color = type_color[1]

          return new Item(stack,type,color,x,y)

        }

        // checks if a stack contains breaking items
        this.stacksBreaking = function() {
          var this_stack
          for (var s=0; s < this.stacks.length; s++) {
            this_stack = this.stacks[s]
            if (this_stack.itemsBreaking())
              return true
          }
          return false
        }

        // checks if any stack is full
        this.stacksFull = function() {

          var this_stack
          for (var s=0; s < this.stacks.length; s++) {
            this_stack = this.stacks[s]
            if (this_stack.items.length + ((this_stack.x == player.x)?(player.hand.items.length):0) >= BOARD_HEIGHT)
              return true
          }

          return false

        }

        // raise level using random items in each stack's queue
        this.raiseStacks = function() {


          // reset board y position
          this.board.y = ITEM_WIDTH

          var this_stack
          for (var s = 0; s < BOARD_WIDTH; s++) {
            this_stack = this.stacks[s]
            console.log("raising this stack using random item:")
            console.dir(this_stack.next_random_item)

            // pop each item of this stack onto a temporary array
            var temp_stack = new Array()
            while (this_stack.items.length > 0) {
              temp_stack.push(this_stack.items.pop())
            }

            // push next random item onto this stack and update it's location and sprite
            this_stack.items.push(this_stack.next_random_item)
            this_stack.next_random_item.y = 0
            this_stack.next_random_item.sprite.dy = this.posy(0)
            this_stack.next_random_item.active = true

            // push temporary stack onto this stack
            while (temp_stack.length > 0) {
              var this_item = temp_stack.pop()
              this_stack.items.push(this_item)
              this_item.y = this_stack.items.length-1
              this_item.chain = 0
              this_item.sprite.dy = this.posy(this_stack.items.length-1)
            }

            // check for matches
            this_stack.checkForMatches()

            // randomize next random item
            this_stack.next_random_item = this.randomItem(this_stack,s,-1)

          }

          // move player cursor up
          player.y++

          // reset timer
          player.timer.raise_level_timer = raise_level_time

          Y_SPEED = SLOW

        }

        // generate marathon board
        this.marathonLevel = function(level) {

          var value

          // fill up the randomization array
          for (var key in ITEM_PROBS) {
            if (ITEM_PROBS.hasOwnProperty(key)) {
              value = ITEM_PROBS[key]

              for (var i = 0; i < value; i++) {
                randomization_array.push(key)
              }

            }
          }

          // shuffle the randomization array
          fisherYates(randomization_array)
          for (var i = 0; i < randomization_array.length; i++) {
            console.log("randomization_array " + i + " = " + randomization_array[i])
          }

          // create stacks for the board
          var random_item
          for (var s = 0; s < BOARD_WIDTH; s++) {
            this.stacks.push(new Stack(this,level,s))
            var this_stack = this.stacks[s]
            // add level amount of random items to this stack
            for (var l = 0; l < level; l++) {

              random_item = this.randomItem(this_stack,s,l)
              this_stack.items.push(random_item)

            }

            this_stack.next_random_item = this.randomItem(this_stack,s,-1)
            console.log("this stack's next random item:")
            console.dir(this_stack.next_random_item)

            // check for matches
            this_stack.checkForMatches()

          }


        }

        this.fillLevel = function(level,stage,undo) {

          var undo_state = undo || undefined

          var data = (undo_state != undefined) ? undo_state : level_data.levels[level][stage-1]

          console.log("level_data")
          console.dir(level_data)

          // SANITY CHECK
          if (data == "" || data == "\n\n\n\n\n\n" || data == undefined) {
            if (level_edit) {
              for (var s=0; s < BOARD_WIDTH; s++)
                this.stacks.push(new Stack(this,level,s))
              return
            } else {
              player_level = 1
              player_stage = 1
              jaws.start(MainMenu)
            }
          }

          // array of stacks in string form
          var stacks_string = data.split('\n')
          var items
          star_time = stacks_string[6]
          star_score = stacks_string[7]

          // go through each stack
          for (var s=0; s < BOARD_WIDTH; s++) {

            this.stacks.push(new Stack(this,level,s))

            var this_stack = this.stacks[s]

            // array of items in string form
            items = stacks_string[s].split(',')

            // skip empty stacks
            if (items == "")
              continue

            // go through each item in this stack
            for (var i=0; i < items.length; i++) {

              var item = items[i]
              var item_string = item.split('|')

              var type = item_string[0]
              var color = item_string[1]

              console.log("stack(" + s + ") looking though item of type = " + type + ", color = " + color)

              this_stack.items.push(new Item(this_stack,type,color,s,i))

            }

          }

          console.log("block_count = " + this.block_count)
          console.log("flask_count = " + this.flask_count)
          console.log("robot_count = " + this.robot_count)



        }

        // fill up the board with items depending on level-stage
        this.fill = function(level,stage) {

          console.log("Setting up level " + level + "-" + stage + ".")

          // determine what needs to be placed on the board for this level-stage
          var total_flasks = level + 1 // except for 1-1, 1-2
          if (level == 1 && (stage == 1 || stage == 2))
            total_flasks = 1
          console.log("total_flasks = " + total_flasks)

          var total_robots = level + stage // except for level 1
          if (level == 1) {
            total_robots = stage
          }
          console.log("total_robots = " + total_robots)

          var total_blocks = 6 * (level + 1) + stage // except for 1-1,1-2,1-3,1-4,1-5
          if (level == 1) {
            if (stage == 1) total_blocks = 5
            else if (stage == 2) total_blocks = 6
            else if (stage == 3) total_blocks = 10
            else if (stage == 4) total_blocks = 12
            else if (stage == 5) total_blocks = 14
          }
          console.log("total_blocks = " + total_blocks)

          var total_colors = level + 1 // except for 1-1,1-2
          if (level == 1) {
            if (stage <= 2) total_colors = 1
          } else if (level == 6) total_colors = 6
          console.log("total_colors = " + total_colors)

          // put everything that's needed into an Array then randomize
          var items_array = new Array() // will contain tuple = [type,color]

          // put items in array for each color
          for (var c=0; c < total_colors; c++) {

            // put robots into array
            var robots_of_color = total_robots / total_colors
            for (var r=0; r < robots_of_color; r++) {
              items_array.push([2,c])
              if (items_array.length >= total_robots) break
            }

            // put at least one flask for each color, fill up flasks with white for mode: 1
            //items_array.push([1, (game_mode == 1) ? WHITE : EMPTY])

            // put at least three blocks for each color
            items_array.push([0,c])
            items_array.push([0,c])
            items_array.push([0,c])

          }

          // put in flasks
          var num_empty_flasks = Math.floor(total_colors / 2)

          // exceptions
          // 1-3
          if (player_level == 1) {
            if (player_stage == 3)
              num_empty_flasks = 0
            else if (player_stage == 6) {
              num_empty_flasks = 1
            }
          } else if (player_level == 6) {
            if (player_stage == 1)
              num_empty_flasks = 2
            else if (player_stage == 6)
              num_empty_flasks = 1
          }

          console.log("num_empty_flasks = " + num_empty_flasks)

          var num_white_flasks = total_colors - num_empty_flasks

          for (var e=0; e < num_empty_flasks; e++) {
            items_array.push([1, EMPTY])
            // put at least three white blocks for each empty flask
            items_array.push([0,WHITE])
            items_array.push([0,WHITE])
            items_array.push([0,WHITE])
          }
          for (var w=0; w < num_white_flasks; w++)
            items_array.push([1, WHITE])

          console.log("item_count = " + items_array.length)

          // fill up with random blocks and flasks until total_blocks reached
          while (items_array.length < total_blocks) {

            var rand_color = Math.floor(Math.random()*7)

            if (rand_color > total_colors - 1) {
              items_array.push(
                [2,Math.floor(Math.random()*total_colors)]
              )
            } else if (rand_color < 6) {

              var rand_int = Math.floor(Math.random()*2)
              if (rand_int == 0) items_array.push([0,rand_color])
              else items_array.push([2,rand_color])

            }
            else {
              items_array.push([1,WHITE])
              console.log("color(" + WHITE + ")")
            }



            console.log(items_array[items_array.length - 1])

          }

          console.log("done filling up items_array")
          console.log("item_count = " + items_array.length)

          // shuffle the item_array
          fisherYates(items_array)
          for(var i=0; i < items_array.length; i++) {
            console.log("[" + items_array[i][0] + "," + items_array[i][1] + "]")
          }

          // push BOARD_WIDTH amount of stacks
          for (var i=0; i < BOARD_WIDTH; i++) {
            this.stacks.push(new Stack(this,level,i))
          }

          console.log("items_array = " + items_array)

          // randomly decide which stack to place items in
          while (items_array.length > 0) {

            var rand_stack = Math.floor(Math.random()*6)
            var this_stack = this.stacks[rand_stack]
            if (this_stack.items.length >= level + 3) {
              console.log(items_array.length)
              console.log("top of stack reached")
              continue
            }
            var item_top = items_array.pop()

            console.log("color(" + item_top[1] + ")")
            this_stack.items.push(
              new Item(this_stack,item_top[0],item_top[1],rand_stack,this_stack.items.length)
            )

          }

          // make sure that stacks don't contain matches
          for(var s=0; s < player.board.stacks.length; s++) {
            var this_stack = player.board.stacks[s]
            if (this_stack.checkForMatches()) {
              // will restart at the beginning of this.update()
              need_to_restart = true
            }
          }

          // check if there are 5 blocks of some color
          for(var c=0; c < COLORS.length; c++) {
            if(this.block_count[c] == 5) {
              console.log("5 blocks of color(" + COLORS[c] + ") found. Resetting board.")
              need_to_restart = true
            }
          }

          // make sure that robot don't shed to add up to more than 9
          for(var i=0; i < 3; i++) {
            if(this.robot_count[i] + this.robot_count[i+3] > 9) {
              need_to_restart = true
              break
            }
          }

          console.log("block_count = " + this.block_count)
          console.log("flask_count = " + this.flask_count)
          console.log("robot_count = " + this.robot_count)

        }

        // provide coordinates of clicks with respect to (stack, depth)
        this.boardCoordinates = function(x,y) {
          console.log("converting click coordinates to board coordinates")

          // find click coordinates with respect to board's top-left position in canvas
          var board_x = x - this.board.x
          var board_y = y - this.board.y

          if (marathon) {
            if (board_x < 0 || board_x > this.board.width || board_y < 0 || board_y > this.board.height) {
              return [-1,-1]
            }
          }

          // figure out which stack player clicked above or on
          // bitwise OR operator to truncate float point figures
          board_x = (board_x / ITEM_WIDTH) | 0

          // figure out depth the player clicked into the stack
          board_y = BOARD_HEIGHT + (BOARD_HEIGHT - board_y) / ITEM_WIDTH | 0

          console.log([board_x, board_y])

          return [board_x, board_y]



        }

        // check if the player has reached a win/lose condition and act accordingly
        this.checkWinLose = function() {

          if (marathon)
            return

          console.log("CHECKING")

          // win condition: robots cleared
          console.log("checking win condition")
          if (!(this.robot_count<[0,0,0,0,0,0] || [0,0,0,0,0,0]<this.robot_count)) { // array equality
            game_end = "W"
            return
          }

          // lose condition: no more blocks/flasks to clear robots
          console.log("checking lose conditions")
          var remaining_robot_colors = 0
          var remaining_armor_robots = 0
          for (var c=0; c < 6; c++) {

            // catch all armored robots
            if (c > 2 && this.robot_count[c] > 0) {
              remaining_armor_robots++
              continue
            }

            if (this.robot_count[c] > 0)
              remaining_robot_colors++
            if (this.flask_count[c] > 0)
              remaining_robot_colors --
          }

          if (remaining_armor_robots > 0)
            remaining_robot_colors++
          if (this.flask_count[4] > 0)
            remaining_robot_colors--

          var potential_white_potions = this.block_count[WHITE] / 3 + this.flask_count[WHITE]

          console.log("potential_white_potions = " + potential_white_potions)
          console.log("remaining_robot_colors = " + remaining_robot_colors)

          for (var c=0; c < 6; c++) {

            if (c == 3 || c > 5)
              continue

            if (this.robot_count[c] > 0) {
              console.log("robots of color " + COLORS[c] + " still exist!")
              console.log("block count = " + this.block_count[c])
              console.log("flask_count = " + this.flask_count[c])
              if (this.flask_count[c] <= 0) {
                if (this.block_count[c] < 3) {
                  console.log("lose! here for color = " + c)
                  game_end = "L"
                  return
                } else if (potential_white_potions < remaining_robot_colors){
                  console.log("lose! not enough white blocks, checking color = " + COLORS[c])
                  game_end = "L"
                  return
                }
              }

            }
          }

        }

        this.winLose = function() {

          winlose = true
          winlose_menu.active = true
          winlose_menu.controls(winlose_menu)   
          var winlose_menu_items = new Array()       

          if (game_end == "W") {

            winlose_data.items[1].text += "  " + player.timer.clock_text
            winlose_data.items[2].text += " \u03BB" + player.score

            // update star progress
            if (!player_undid)
              player.new_stars = updateStarProgress(player,player_level,player_stage,star_time,star_score,winlose_data)

            player.stars = starTotal()
            player_data.items[0].text = "  x " + player.stars

            winlose_menu.title = ""

            // allow player to advance to next level if they have enough stars     
            console.log("level_data")
            console.dir(level_data)
            var level_check
            var stage_check
            if (player_stage < level_data["levels"][player_level].length) {
              level_check = player_level
              stage_check = player_stage
            } else {
              level_check = parseInt(player_level) + 1
              stage_check = 0
            }
            console.log("level_check = " + level_check)
            console.log("stage_check = " + stage_check)
            var next_level = (level_data.levels[level_check] != undefined) ? level_data.levels[level_check][stage_check] : undefined
            var next_star_lock = (next_level != undefined) ? next_level.split('\n')[8] : undefined

            // stage menu if beat last stage (already)
            if (player_stage == level_data.levels[player_level].length ||
                player_progress[player_level][0] >= level_data.levels[player_level].length) {

              winlose_menu_items.push(continue_menu_item)              

              // add MenuItem for each stage of this level
              for (var s = 0; s < level_data.levels[player_level].length; s++) {
                var stage_menu_item = new MenuItem(winlose_menu,player_level.toString() + "-" + (s+1).toString(), function() {
                  player_stage = parseInt(this.text[2])
                  console.dir(this)
                  jaws.start(Game)
                })
                winlose_menu_items.push(stage_menu_item)
              }
              // add Back to Menu item
              winlose_menu_items.push(back_menu_item)
              winlose_menu.items = winlose_menu_items
              winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

              next_level = (level_data.levels[parseInt(player_level) + 1] != undefined) ? level_data.levels[parseInt(player_level) + 1][0] : undefined
              next_star_lock = (next_level != undefined) ? next_level.split('\n')[8] : undefined      

              console.log("continue! ??" + next_level)
              console.dir(level_data)        

              // continue
              if (next_level != undefined) {
                winlose_menu.items[0].active = true
                if (next_star_lock == undefined || starTotal() >= next_star_lock)
                  winlose_menu.items[0].locked = false
                else
                  winlose_menu.items[0].locked = true
                winlose_menu.items[0].text = "Cont. to " + (parseInt(player_level) + 1) + "-1"
                winlose_menu.items[0].action = function() {
                  player_level++
                  player_stage = 1
                  jaws.start(Game)
                }
              } 

              // default index
              if (player_progress[player_level][0] >= player_stage)
                winlose_menu.index = player_stage                         

            // beating puzzles for the first time
            } else {

              winlose_menu_items.push(continue_menu_item)
              winlose_menu_items.push(restart_menu_item)
              restart_menu_item.action = function () {
                jaws.start(Game) // no need to save record here
              }
              winlose_menu_items.push(back_menu_item)
              winlose_menu.items = winlose_menu_items
              winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

              // continue
              if (next_level != undefined) {
                winlose_menu.items[0].active = true
              }

              // default index
              // restart if beat this level already
              if (player_progress[player_level][0] >= player_stage)
                winlose_menu.index = 1
            }

            // update player progress
            if (player_progress[player_level][0] < player_stage)
              player_progress[player_level][0] = parseInt(player_stage)

            // update best time and score for this level-stage
            var this_level_progress = player_progress[player_level][1]
            var this_stage_progress = this_level_progress[player_stage.toString()]
            if (this_stage_progress == undefined) // create new array if stage newly beaten
              this_stage_progress = this_level_progress[player_stage.toString()] = ["99:99",0]
            if (player.timer.clock_text < this_stage_progress[0]) {
              this_stage_progress[0] = player.timer.clock_text
              if (puzzle_data != undefined)
                puzzle_data.items[0].color = "Grey"
            }
            if (player.score > this_stage_progress[1]) {
              this_stage_progress[1] = player.score
              if (puzzle_data != undefined)
                puzzle_data.items[1].color = "Grey"
            }

            console.log("player_progress = ")
            console.dir(player_progress)

            // update player_save data
            var player_save = $("saveData")
            player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)    
            // update cookie save
            setCookie("player_save",player_save.innerHTML,360000)

            // update level data if player beat star_score
            // if (star_score == undefined || player.score > star_score) {
            //   updateLevel(player_level,player_stage,player.score,function() {
            //     console.log("updated level with new star score")
            //     loadLevels(function(data) {

            //       level_data = JSON.parse(data)
            //       console.log("level_data = ")
            //       console.dir(level_data)
            //       latest_edit = level_data.levels[0].length + 1
            //       player_progress[0][0] = latest_edit - 2
                  
            //     })
            //   })
            // }

          } else if (game_end == "L") {

            // drop player hand
            player.drop(player.board.stacks[player.x],player.hand.items.length)

            // but don't add this action to the undo_state
            undo_hand.pop()
            undo_board.pop()


            winlose_menu.y = winlose_data.y
            winlose_menu_items.push(undo_menu_item)
            winlose_menu_items.push(restart_menu_item)
            restart_menu_item.action = function () {
              jaws.start(Game) // no need to save record here
            }
            winlose_menu_items.push(back_menu_item)
            winlose_menu.items = winlose_menu_items
            winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

            // change menu item text
            if (marathon) {
              undo_menu_item.active = false
              restart_menu_item.text = "Play again"
            }


            winlose_menu.title = (marathon) ? "GAME OVER!" : "YOU LOSE!"

            winlose_menu.index = 1
          }

          if (marathon) {

            // update marathon progress
            if (player.timer.clock_text > marathon_progress[0])
              marathon_progress[0] = player.timer.clock_text
            if (player.score > marathon_progress[1])
              marathon_progress[1] = player.score

            // update player_save data
            var player_save = $("saveData")
            player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
            // update cookie save
            setCookie("player_save",player_save.innerHTML,360000)
          }

          var record = buildRecordString(this,game_end)
          saveRecord(record)

          // color timer to be red to indicate game end
          screen_data.index = 1
        }

        // check for items of specified type,color that are breaking
        this.checkForBreaking = function(type,color) {

          console.log("checking for breaking robot of color: " + color)

          for (var i=0; i < this.stacks.length; i++) {

            var this_stack = this.stacks[i]

            // check each item of the stack
            for (var j=0; j < this_stack.items; j++) {
              var this_item = this_stack.items[j]
              if (this_item.type == type && this_item.color == color) {
                console.log("breaking robot of color (" + color + ") found!")
                return true
              }
            }

          }

          return false

        }

        // update all stacks and effects in this board
        this.update = function() {

          // update stacks
          for (var s=0; s<this.stacks.length; s++) {
            this.stacks[s].update()
          }

          // update effects
          for (var e=0; e<this.effects.length; e++) {
            this.effects[e].update()
          }
        }

        // draw all stacks and effects on this board
        this.draw = function() {

          // draw pause menu
          if (pause) {
            jaws.context.fillStyle = PURPLE_HEX //"Black"
            jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)
            jaws.context.fillStyle = "rgba(10,0,10," + this.undo_alpha + ")"
            jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)
            pause_menu.draw()
            return
          }

          // draw background
          jaws.context.fillStyle = PURPLE_HEX //"Black"
          jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)

          // draw undo background
          if (player_undid) {
            if (this.undo_alpha < 1)
              this.undo_alpha += .05
            jaws.context.fillStyle = "rgba(10,0,10," + this.undo_alpha + ")"
            jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)            
          }

          // draw all stacks in this board and containing items
          for (var i=0; i < this.stacks.length; i++) {
            this.stacks[i].draw()
          }

          // hide next random items
          var alpha = player.timer.raise_level_timer/raise_level_time/2 + .5
          jaws.context.fillStyle =  "rgba(0,0,0," + alpha + ")"//"rgba(112,0,84," + alpha + ")"
          jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH+this.board.height,this.board.width,ITEM_WIDTH)

          // draw all effects on this board
          for (var e=0; e < this.effects.length; e++) {
            this.effects[e].draw()
          }

          // draw winlose menu
          if (game_end != "" && game_end != "R") {
            winlose_data.draw()
            winlose_menu.draw()
          }

        }

      }

      /* Constructor for stack */
      function Stack(board,level,x) {

        this.board = board
        this.items = new Array()
        this.level = level
        this.x = x
        this.next_random_item  // string of form "type|color" for use in marathon

        // check if the stack contains matches (3 or more consecutive blocks of same color)
        // return true if matches are found
        this.checkForMatches = function() {

          var match_found = false
          var matches = new Array()
          var items = this.items
          var match
          var item

          console.log("checking for matches")

          // loop through each item on the stack, adding them to matches[] array
          for (var i = 0; i < items.length; i++) {

            item = items[i]

            matches.push(item)
            match = matches[0]

            if (!match.matchBlocks(item)) {
              matches.pop()
              if (matches.length >= 3) {
                console.log("matches found!!! " + matches.length + " of color (" + matches[0].color + ")")
                this.matchesFound(matches)
                match_found = true
                // melt_audio.stop()
                // removeFromPlayingSounds(melt_audio)
                // if (!mute)
                //   melt_audio.play()
              }

              matches = new Array()
              matches.push(item)
            }

            if (i == items.length - 1) {
              if (matches.length >= 3) {
                console.log("matches found!!! " + matches.length + " of color (" + matches[0].color + ")")
                this.matchesFound(matches)
                match_found = true
                // melt_audio.stop()
                // removeFromPlayingSounds(melt_audio)
                // if (!mute)
                //   melt_audio.play()
              }
            }
          }

          return match_found

        }

        // break matches and update their chains
        this.matchesFound = function(matches) { // matches, an array of blocks

          // keep track of block with largest chain
          var chain = 0

          // break matches
          for (var i=0; i<matches.length; i++) {

            var match = matches[i]
            match.breaking = true
            match.chain += 1

            // update chain
            if (match.chain > chain) chain = match.chain
            match.chain = chain

            if (i==0)
              match.last_in_chain = true

          }

          // ensure that all matches have same chain
          this.setChain(matches,chain)

          console.log("breaking with chain = " + chain)

          console.log("matches:")
          for(var i=0; i<matches.length; i++) {
            console.log(matches[i].breaking)
          }

          return chain

        }

        // sets chain for all items passed in
        this.setChain = function(items,chain) {

          // go through each item and set its chain
          for (var i=0; i<items.length; i++) {
            var item = items[i]
            item.chain = chain
          }

        }

        this.removeItem = function(old_item) {

          console.log("removing (" + old_item.type + ") of color (" + old_item.color + ")" + " with chain = " + old_item.chain + ", y = " + old_item.y)

          // remove old item from items array
          this.items.splice(old_item.y,1)

          // update sprite destination for each item above old_item
          Y_SPEED = FAST
          for (var i=0; i<this.items.length; i++) {
            var item = this.items[i]
            if (item.y > old_item.y) item.y -= 1
              item.sprite.dy = this.board.posy(item.y)
          }

          // update board count
          if (old_item.type == 0) {
            this.board.block_count[old_item.color]--
          } else if (old_item.type == 1) {
            this.board.flask_count[old_item.color]--
          } else if (old_item.type == 2) {
            if (old_item.color > 2) {
              this.board.robot_count[4]--  // all armored robots count as yellowß
              console.log("decrement yellow robot count")
            }
            else
              this.board.robot_count[old_item.color]--
          }

          if (level_edit)
            return

          // check for win/lose only when blocks and robots are broken since flasks break first
          // but only check when items aren't breaking
          if (!this.board.stacksBreaking()) {
            if (old_item.type == 0 || old_item.type == 1) {
              // if (old_item.color != WHITE)
                this.board.checkWinLose() // check for win/lose conditions
            } else if (old_item.type == 2) {
              // make sure that there are no other robots in the process of being removed
              var below = this.items[old_item.y - 1]
              if(below == undefined) {
                this.board.checkWinLose()
              } else {
                // if there is an item below, check if it is a robot of the same color
                if (!(below.type == 2 && below.color == old_item.color && below.breaking)) {
                  this.board.checkWinLose()
                }
              }

            }
          }

          console.log("block_count = " + this.board.block_count)
          console.log("flask_count = " + this.board.flask_count)
          console.log("robot_count = " + this.board.robot_count)

          this.checkForMatches()

          // add to player score depending on type of this item
          if (old_item.type==0) {
            player.addScore(100*old_item.chain)
          } else if (old_item.type==2) {
            player.addScore(500*old_item.chain)
          }

          // show chain effects if last in chain
          if (old_item.last_in_chain && old_item.chain > 1) {
            console.log("last in chain = " + old_item.chain)
            this.board.effects.push(new ChainEffect(this,old_item))
          }

          // stop sound effects
          if (old_item.type == 1) {
            console.log("stop sound effect")
            // console.dir(old_item.break_audio)
            // break_audio.stop()
            // removeFromPlayingSounds(break_audio)
            if (old_item.chain > 1)
              this.board.effects.push(new ChainEffect(this,old_item))
          }

        }

        // only used by level editor
        this.removeItems = function(old_items) {

          for (var i=0; i<old_items.length; i++) {

            this.removeItem(old_items[i])

          }
        }

        this.shedRobot = function(old_item) {

          // sanity check!!!!!!!
          if (old_item.type != 2)
            return

          console.log("shedding (" + old_item.type + ") of color (" + old_item.color + ")")

          // remove old item from items array
          // replace robot with color of (old_item.color - 3)
          var new_item = new Item(this,2,old_item.color-3,old_item.x,old_item.y)
          new_item.active = true
          new_item.chain = old_item.chain
          this.items.splice(old_item.y,1,new_item)

          // update yellow robot count
          this.board.robot_count[4]--

          // check for win/lose only when blocks and robots are broken since flasks break first
          // but only check when items aren't breaking
          if (!this.board.stacksBreaking()) {
            if (old_item.type == 0 || old_item.type == 1) {
              // if (old_item.color != WHITE)
                this.board.checkWinLose() // check for win/lose conditions
            } else if (old_item.type == 2) {
              // make sure that there are no other robots in the process of being removed
              var below = this.items[old_item.y - 1]
              if(below == undefined) {
                this.board.checkWinLose()
              } else {
                // if there is an item below, check if it is a robot of the same color
                if (!(below.type == 2 && below.color == old_item.color && below.breaking)) {
                  this.board.checkWinLose()
                }
              }

            }
          }

          console.log("block_count = " + this.board.block_count)
          console.log("flask_count = " + this.board.flask_count)
          console.log("robot_count = " + this.board.robot_count)

          this.checkForMatches()

          player.addScore(500*new_item.chain)

        }

        // check if there are items breaking on this stack
        this.itemsBreaking = function() {

          var breaking = false
          var item

          for (var i=0; i<this.items.length; i++) {
            item = this.items[i]
            if (item.breaking) {
              breaking = true
              break
            }
          }

          return breaking

        }

        // clear array of robots followed by array of flasks
        this.clearRobotsFlasks = function(robots_to_clear,flasks_to_clear) {

          for (var r = 0; r < robots_to_clear.length; r++) {

            var this_robot = robots_to_clear[r]

            this_robot.breaking = true

            // put splashes here
            var robot_delay = this_robot.deathcounter + this_robot.splash_order
            this.board.effects.push(new Splash(this,this_robot.type,this_robot.color,this_robot.x,this_robot.y,this.board.effects.length,robot_delay))

            // determine which sprites to use
            var death_color = "RED"
            if (this_robot.color == 1 || this_robot.color == 4)
              death_color = "YELLOW"
            else if (this_robot.color == 2 || this_robot.color == 5)
              death_color = "PURPLE"

            // update sprite data
            this_robot.sprite = new jaws.Sprite({x:this_robot.stack.board.posx(this_robot.x), y:this_robot.stack.board.posy(this_robot.y), anchor: "left"})
            var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + death_color + "_DEATH.gif", frame_size: [40,40], frame_duration: 20})
            this_robot.sprite.anim_default = anim.slice(0,6)

            var rand_color = Math.floor(Math.random()*WHITE)
            for (var c=0; c < rand_color; c++)
              this_robot.sprite.setImage(this_robot.sprite.anim_default.next())

            this_robot.sprite.dx = this_robot.stack.board.posx(this_robot.x)
            this_robot.sprite.dy = this_robot.stack.board.posy(this_robot.y)

          }

          for (var f = 0; f < flasks_to_clear.length; f++) {

            var this_flask = flasks_to_clear[f]

            this_flask.breaking = true

            // put splashes here
            this.board.effects.push(new Splash(this,this_flask.type,this_flask.color,this_flask.x,this_flask.y,this.board.effects.length,this_flask.deathcounter))

            // update sprite data
            this_flask.sprite = new jaws.Sprite({x:this_flask.stack.board.posx(this_flask.x),y:this_flask.stack.board.posy(this_flask.y), anchor: "left"})
            var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_SPRITES.gif", frame_size: [40,40], frame_duration: 20 + Math.floor(Math.random()*((60-20) + 1))})
            this_flask.sprite.anim_default = anim.slice(0,6)

            this_flask.sprite.dx = this_flask.stack.board.posx(this_flask.x)
            this_flask.sprite.dy = this_flask.stack.board.posy(this_flask.y)

            // stop flask's sound effects
            // break_audio.stop()
            // removeFromPlayingSounds(break_audio)

            // // play robot breaking sound effects
            // if (!mute)
            //   break_audio.play()



          }

        }

        // Stack .update() updates each item in the stack
        // update animations, counters, and chains
        // remove items if their death counters set off
        this.update = function() {

          // make sure to break flask last or the game will think lose condition is met
          // put flasks and robots to break into respective arrays
          var flasks_to_clear = new Array()
          var robots_to_clear = new Array()

          // copy stack items into new array so we can loop through all items
          // even if items are removed
          var stack_items = this.items.slice()

          // update each item
          for(var i=0; i<stack_items.length; i++) {
            var item = stack_items[i]
            var above = stack_items[i + 1]

            // for all items breaking (except UNSTABLE flasks)
            // NOTE: eventually will make updateX for X for any type of item
            // animation updates will happen there
            if (item.breaking) {

              // breaking animation
              if (item.type == 0) {
                if (item.sprite.width > 1) {
                  item.sprite.scaleWidth(.5)
                  item.sprite.dx += item.sprite.width / 2
                } else {
                  item.sprite.dx -= item.sprite.width / 2
                  item.sprite.scaleWidth(2)
                }

              // animate breaking flasks and robots
              } else {
                item.sprite.setImage(item.sprite.anim_default.next())
              }

              // update deathcounter
              item.deathcounter -= 1

              // add chain to items above
              if (above != undefined && !above.breaking) {
                above.chain = item.chain
                console.log("item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] passing chain (" + item.chain + ") to item [" + TYPES[above.type] + "|" + COLORS[above.color] + "] above")
              }

            }

            // update items in transitory animation
            if (item.sleepcounter > 0) {
              item.sleepcounter -= 1
            }

            // remove item if death counter has expired
            if (item.deathcounter <= 0) {

              // do not destroy blue, yellow, orange robots
              if(item.type == 2 && (item.color == 3 || item.color == 4 || item.color == 5)) {
                this.shedRobot(item)
                console.log("shedRobot")
              }
              else
                this.removeItem(item)
            }

            // animate robots
            if (item.type == 2) {
              item.sprite.setImage(item.sprite.anim_default.next())
            }

            // update item sprite positions
            spriteMove(item.sprite,X_SPEED,Y_SPEED)


            // check for breaking conditions
            // skip items on player hand
            if (item.stack != player.hand && !item.breaking) {

              // update flasks
              if (item.type == 1) {

                item.updateFlask(above)

              }

              // update robots
              // check for yellow robots
              else if (item.type == 2) {

                // clear robots

                var above = stack_items[i + 1]
                var below = stack_items[i - 1]
                if (above != undefined) {

                  // break robot and same-colored flask above
                  if (above.sleepcounter == 0 && above.color == ((item.color > 2) ? 4 : item.color) && above.type == 1) {

                    // item.breaking = true
                    // above.breaking = true

                    robots_to_clear.push(item)
                    flasks_to_clear.push(above)

                    above.chain += 1
                    item.chain = above.chain
                    item.splash_order = above.splash_order + 1

                    console.log("(" + above.color + ") flask breaking robot of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  // break if robot above is breaking
                  } else if (above.type == 2 && ((item.color > 2) ? (above.color > 2):(above.color == item.color)) && above.breaking) {

                    // item.breaking = true

                    robots_to_clear.push(item)

                    item.chain = above.chain
                    console.log("item [" + TYPES[above.type] + "|" + COLORS[above.color] + "] passing chain (" + above.chain + ") to item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] below")
                    item.splash_order = above.splash_order + 1

                    console.log("robot combo of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  }
                }

                if (below != undefined) {

                  // break robot and same-colored flask below
                  if (below.sleepcounter == 0 && below.color == ((item.color > 2) ? 4 : item.color) && below.type == 1) {

                    // item.breaking = true
                    // below.breaking = true

                    robots_to_clear.push(item)
                    flasks_to_clear.push(below)

                    item.chain += 1
                    below.chain = item.chain

                    item.splash_order = below.splash_order + 1

                    below.chain = item.chain
                    console.log("item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] passing chain (" + item.chain + ") to item [" + TYPES[below.type] + "|" + COLORS[below.color] + "] below")

                    console.log("(" + below.color + ") flask breaking robot of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  // break if robot below is breaking
                  } else if (below.type == 2 && ((item.color > 2) ? (below.color > 2):(below.color == item.color)) && below.breaking) {

                    // item.breaking = true

                    robots_to_clear.push(item)

                    item.chain = below.chain
                    console.log("item [" + TYPES[below.type] + "|" + COLORS[below.color] + "] passing chain (" + below.chain + ") to item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] above")
                    item.splash_order = below.splash_order + 1

                    console.log("robot combo of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  }
                }
              }
            }
          }

          this.clearRobotsFlasks(robots_to_clear,flasks_to_clear)

        }

        this.draw = function() {

          // // draw all items on stack and next random item
          // for (var i=0; i<this.items.length;i++) {
          //   this.items[i].draw()
          // }
          if (!marathon) {
            for (var i=0; i<this.items.length;i++) {
              this.items[i].draw()
            }
          } else {
            // TODO: flash stack when full and player in danger
            var this_stack_full = (this.items.length + ((this.board.player.x != this.x) ? 0 : this.board.player.hand.items.length) == BOARD_HEIGHT)
            var player_timer = this.board.player.timer
            // var danger_time = (player_timer.raise_level_timer < raise_level_time/4) ? ((player_timer.ticker%8==0) ? true : false) : false
            var danger_time = (player_timer.ticker%8==0) ? true : false
            if (!this_stack_full || !danger_time || this.itemsBreaking() || game_end != "") {
              for (var i=0; i<this.items.length;i++) {
                this.items[i].draw()
              }
            }
          }
          if (this.level >= 0 && marathon) {
            this.next_random_item.draw()
          }
        }

      }

      /* Constructor for item */
      function Item(stack,type,color,x,y) {

        console.log("making new item of type(" + type + "), color(" + COLORS[color] + ")")

        // an item has type and color
        this.stack = stack
        this.type = type
        this.color = color
        this.x = x             // x position on the board
        this.y = y             // y position on the board
        this.active = false
        this.breaking = false
        this.deathcounter = 40
        this.sleepcounter = 0  // used for transitory animations
                               // (eg: potion filling up, items exploding, etc.)
        this.chain = 0
        this.last_in_chain = false
        this.splash_order = 0

        var board = stack.board

        // set appropriate sprite for this item
        if (this.type == 0) {
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y),image:"./static/images/" + COLORS[color] + ".gif",anchor:"left"})
          board.block_count[color] += 1
        } else if (this.type == 1) {
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), image:"./static/images/POTION_" + COLORS[color] + ".gif",anchor:"left"})
          board.flask_count[color] += 1
        } else if (this.type == 2) {
          // create sprite for this robot
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), anchor: "left"})
          var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + COLORS[this.color] + ".gif", frame_size: [40,40], frame_duration: 100})
          this.sprite.anim_default = anim.slice(0,5)
          this.sprite.setImage(this.sprite.anim_default.next())

          // determine which sprites to use
          var death_color = "RED"
          if (this.color == 1 || this.color == 4)
            death_color = "YELLOW"
          else if (this.color == 2 || this.color == 5)
            death_color = "PURPLE"
          var dead_sprites = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + death_color + "_DEATH.gif", frame_size: [40,40], frame_duration: 20})
          this.sprite.setImage(dead_sprites.slice(
            (death_color=="RED"||this.color==1)?this.color:((this.color==2)?4:3),
            6).next())

          if (this.color > 2)
            board.robot_count[4] += 1
          else
            board.robot_count[this.color] += 1
        }
        this.sprite.dx = this.stack.board.posx(x)
        this.sprite.dy = this.stack.board.posy(y)

        this.matchBlocks = function(item) { // item to check if this matches with

          if (!this.breaking && this.type == 0 && item.type == this.type && item.color == this.color)
            return true

          return false

        }

        // update all flask items, called by Stack's .update()
        // above: the item above this flask, if any
        this.updateFlask = function(above) {

          // sanity check
          if (this.type != 1) return

          // check if blocks are breaking above
          // fill flask with potion of that color
          if (above != undefined) {
            if (above.breaking && above.type == 0) {

              // fill up the flask with potion of breaking color
              // only if the flask is not empty
              if (this.color == WHITE && above.color != WHITE) {
                this.color = above.color
                this.chain = above.chain
                this.sleepcounter = 40
                player.addScore(100)
                console.log("sleepcounter = " + this.sleepcounter)

                // update sprite data
                this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), image:"./static/images/POTION_" + COLORS[above.color] + ".gif",anchor:"left"})
                this.sprite.dx = this.stack.board.posx(above.x)
                this.sprite.dy = this.stack.board.posy(above.y - 1)

                // update board count
                this.stack.board.flask_count[WHITE]--
                this.stack.board.flask_count[above.color]++

                // play sound effect for brewing
                // brew_audio.stop()
                // removeFromPlayingSounds(brew_audio)
                // melt_audio.stop()
                // removeFromPlayingSounds(melt_audio)
                // white_audio.stop()
                // removeFromPlayingSounds(white_audio)
                // console.log("brewing color potion")
                // if (!mute) {
                //   brew_audio.play()
                //   white_audio.play()
                // }

              // only accept white blocks above if empty
              // break if other colors brewed
              } else if (this.color == EMPTY) {

                if (above.color == WHITE) {

                  this.color = above.color
                  this.sleepcounter = 40
                  player.addScore(100)
                  console.log("sleepcounter = " + this.sleepcounter)

                  // update sprite data
                  this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), image:"./static/images/POTION_" + COLORS[above.color] + ".gif",anchor:"left"})
                  this.sprite.dx = this.stack.board.posx(above.x)
                  this.sprite.dy = this.stack.board.posy(above.y - 1)

                  // update board count
                  this.stack.board.flask_count[EMPTY]--
                  this.stack.board.flask_count[above.color]++

                  // play sound effect for brewing
                  // white_audio.stop()
                  // removeFromPlayingSounds(white_audio)
                  // melt_audio.stop()
                  // removeFromPlayingSounds(melt_audio)
                  // console.log("brewing white potion")
                  // if (!mute)
                  //   white_audio.play()

                // melting colored blocks over empty flask creates an unstable reaction
                } else {

                  var this_stack = this.stack.items

                  console.log("this_stack:")
                  for (var i=this_stack.length-1; i > 0; i--) {
                    console.log (this_stack[i])
                  }

                  this.color = UNSTABLE
                  this.breaking = true

                  // put splashes here
                  this.stack.board.effects.push(new Splash(this.stack,this.type,this.color,this.x,this.y,this.stack.board.effects.length,this.deathcounter))

                  // update sprite data
                  this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), anchor: "left"})
                  var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_SPRITES.gif", frame_size: [40,40], frame_duration: 20})
                  this.sprite.anim_default = anim.slice(0,6)

                  this.sprite.dx = this.stack.board.posx(above.x)
                  this.sprite.dy = this.stack.board.posy(above.y - 1)

                  // update board count
                  this.stack.board.flask_count[EMPTY]--
                  this.stack.board.flask_count[this.color]++

                  // play sound effect for unstable reaction
                  // break_audio.stop()
                  // removeFromPlayingSounds(break_audio)
                  // console.log("brewing unstable potion")
                  // if (!mute)
                  //   break_audio.play()
                }

              }

            }
          }

        }

        // player name and timer
        this.draw = function() {

          if (this.y < 0)
            this.sprite.y = this.stack.board.posy(this.y)
          else
            this.sprite.dy = this.stack.board.posy(this.y)

          this.sprite.draw()
        }
      }

      function ChainEffect(stack,item) {

        this.stack = stack
        this.chain = item.chain
        this.item = item
        this.speed = 1
        this.deathcounter = 60

        this.index = stack.board.effects.length

        this.sprite = new jaws.Sprite({
          x: item.sprite.x,
          y: item.sprite.y,
          image: "./static/images/CHAIN.gif",
          anchor: "left"
        })

        this.removeChainEffect = function() {
          this.stack.board.effects.splice(this.index,1)

          // reset indices
          for (var i = this.index; i < this.stack.board.effects.length; i++) {
            var this_effect = this.stack.board.effects[i]
            this_effect.index = i
          }

          console.log("effects array:")
          console.dir(this.stack.board.effects)
        }

        this.update = function() {
          this.sprite.y -= this.speed
          this.deathcounter -= 1
        }

        this.draw = function() {

          if (this.deathcounter < 0) {
            this.removeChainEffect()
            return
          }

          this.sprite.draw()

          jaws.context.font = MENU_FONT
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  "White"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText("x" + this.chain, this.sprite.x + 6, this.sprite.y + 15)
        }

      }

      /* Constructor for Splashes */
      function Splash(stack,type,color,x,y,index,delay) {

        // console.log("adding splash")

        this.stack = stack // the stack this splash comes from
        this.type = type   // type of the item destroyed
        this.color = color // color of the item destroyed
        this.x = x
        this.y = y
        this.index = index
        this.delay = delay // delay animation until counter goes to 0

        // set appropriate sprite for this Splash
        if (type == 1)
          this.sprite_sheet = new jaws.SpriteSheet({
            image: "./static/images/POTION_SPLASH.gif", frame_size: [20,20]})
        else if (type == 2)
          this.sprite_sheet = new jaws.SpriteSheet({
            image: "./static/images/ROBOT_" + COLORS[color] + "_SPLASH.gif", frame_size: [20,20]})

        this.sprite1 = new jaws.Sprite({x:this.stack.board.posx(x), y:this.stack.board.posy(y), image: this.sprite_sheet.frames[0]})
        this.sprite2 = new jaws.Sprite({x:this.stack.board.posx(x)+20, y:this.stack.board.posy(y), image: this.sprite_sheet.frames[1]})
        this.sprite3 = new jaws.Sprite({x:this.stack.board.posx(x), y:this.stack.board.posy(y)+20, image: this.sprite_sheet.frames[2]})
        this.sprite4 = new jaws.Sprite({x:this.stack.board.posx(x)+20, y:this.stack.board.posy(y)+20, image: this.sprite_sheet.frames[3]})

        this.initSprite = function(sprite, splash, x_offset, y_offset) {

          x_offset = typeof x_offset !== 'undefined' ? x_offset : 0;
          y_offset = typeof y_offset !== 'undefined' ? y_offset : 0;

          sprite.x0 = sprite.dx = this.stack.board.posx(splash.x) + x_offset
          sprite.y0 = sprite.dy = this.stack.board.posy(splash.y) + y_offset
          sprite.t = 0

        }

        this.initSprite(this.sprite1, this)
        this.initSprite(this.sprite2, this, 20)
        this.initSprite(this.sprite3, this, 0, 20)
        this.initSprite(this.sprite4, this, 20, 20)

        this.spriteExplode = function(sprite, splash, direction) {

          // console.log("spriteExplode")
          sprite.t += 3
          sprite.dy = sprite.y0 + .1 * sprite.t * sprite.t - 4 * sprite.t
          sprite.dx = sprite.x0 + (direction) * sprite.t

        }

        this.spritesOffscreen = function() {

          var sprites = new Array(this.sprite1, this.sprite2, this.sprite3, this.sprite4)
          var offscreen = new Array(false, false, false, false)

          for (var s = 0; s < sprites.length; s++) {

            var this_sprite = sprites[s]
            if (this_sprite.x < 0 || this_sprite.x > jaws.width || this_sprite.y > jaws.height)
              offscreen[s] = true

          }

          if (!([true,true,true,true]<offscreen || offscreen<[true,true,true,true]))
            return true

          return false

        }

        // remove old splash from board's effects array
        this.removeSplash = function(old_splash) {
          this.stack.board.effects.splice(old_splash.index,1)

          // reset indices
          for (var i = old_splash.index; i < this.stack.board.effects.length; i++) {
            var this_effect = this.stack.board.effects[i]
            this_effect.index = i
          }

          console.log("effects array:")
          console.dir(this.stack.board.effects)
        }

        this.update = function() {

          if (this.delay == 0) {
            console.log("playing break sfx")
            // splash_audio.stop()
            // removeFromPlayingSounds(splash_audio)
            // if (!mute)
            //   splash_audio.play()
          }

          if (this.spritesOffscreen())
            this.removeSplash(this)

          if (this.delay <= 0) {
            // console.log ("updating splash sprites")
            this.spriteExplode(this.sprite1, this, -1)
            this.spriteExplode(this.sprite2, this, 1)
            this.spriteExplode(this.sprite3, this, -.5)
            this.spriteExplode(this.sprite4, this, .5)

            // update splash sprite positions
            spriteMove(this.sprite1,X_SPEED,Y_SPEED)
            spriteMove(this.sprite2,X_SPEED,Y_SPEED)
            spriteMove(this.sprite3,X_SPEED,Y_SPEED)
            spriteMove(this.sprite4,X_SPEED,Y_SPEED)
          }

          this.delay--

        }

        this.draw = function() {

          if (this.delay > 0)
            return

          this.sprite1.draw()
          this.sprite2.draw()
          this.sprite3.draw()
          this.sprite4.draw()

        }

      }

      function Timer(player) {

        this.player = player
        this.minutes = 0
        this.seconds = 0
        this.ticker = 0
        this.frame_ticker = 0
        this.clock_text = "00:00"
        this.raise_level_timer = raise_level_time
        this.raise_level_frequency_timer = 0

        // increment the ticker and count the seconds and minutes
        this.update = function() {
          // start the timer
          if (game_start && game_end == "") {
            this.ticker++
            this.frame_ticker++
          }
          if (this.ticker >= 60) {
            this.ticker = 0
            this.seconds++
            this.raise_level_frequency_timer++

            if (this.raise_level_frequency_timer >= FREQ_RAISE_LEVEL_TIME) {
              if (raise_level_time > MIN_RAISE_LEVEL_TIME)
                raise_level_time--
              console.log("raise_level_time = " + raise_level_time)
              this.raise_level_frequency_timer = 0
            }

            if (marathon && MAX_RAISE_LEVEL_TIME > 0 && !this.player.board.stacksBreaking())
              this.raise_level_timer--

          }
          if (this.seconds >= 60) {
            this.seconds = 0
            this.minutes++
          }
          if (this.raise_level_timer==0) {

            if (!this.player.board.stacksFull()) {
              this.player.board.raiseStacks()
            } else {
              this.player.board.raiseStacks()
              var record = buildRecordString(this,"W")
              saveRecord(record)
              game_end = "L"
            }

            this.raise_level_timer = raise_level_time
            console.log("raise_level_time = " + raise_level_time)
          }

          var min_text = (this.minutes < 10) ? "0" + this.minutes : this.minutes
          var sec_text = (this.seconds < 10) ? "0" + this.seconds : this.seconds

          this.clock_text = min_text + ":" + sec_text
          if (!level_edit)
            screen_data.items[1].text = this.clock_text

        }

      }

      function spriteMove(sprite,x_speed,y_speed) {
        if (Math.abs(sprite.x - sprite.dx) < x_speed) sprite.x = sprite.dx
        else if (sprite.x < sprite.dx) sprite.x += x_speed
        else sprite.x -= x_speed

        if (Math.abs(sprite.y - sprite.dy) < y_speed) sprite.y = sprite.dy
        else if(sprite.y < sprite.dy) sprite.y += y_speed
        else sprite.y -= y_speed
      }

      // adds the current state of the player hand and board
      // to the undo state arrays
      function addStateForUndo (hand,board,undo) {

        var called_by_undo = undo || false

        // construct level string
        var level_string = ""
        // go through each stack
        for (var s = 0; s < board.stacks.length; s++) {
          // go through each item in the stack
          var this_stack = board.stacks[s]
          for (var i = 0; i < this_stack.items.length; i++) {
            // append this item string to level_string
            var this_item = this_stack.items[i]
            if (i>0) level_string = level_string + ","
            level_string = level_string + this_item.type + "|" + this_item.color
          }
          level_string = level_string + "\n"
        }

        // add level string to undo state array
        undo_board.push(level_string)

        // construct hand string
        var hand_string = ""        
        // go through each item in the stack
        for (var i = 0; i < hand.items.length; i++) {
          // append this item string to hand_string
          var this_item = hand.items[i]
          if (i>0) hand_string = hand_string + ","
          hand_string = hand_string + this_item.type + "|" + this_item.color
        }
        hand_string = hand_string + "\n"

        // update player.x of previous state
        if (undo_hand[undo_hand.length-1] != undefined && !called_by_undo) {
          undo_hand[undo_hand.length-1][0] = player.x
        }

        // add hand string to undo state array
        undo_hand.push([player.x,player.y,player.hand.level,hand_string,player.score])

        console.log("added hand and board states!")
        console.dir(undo_hand)
        console.dir(undo_board)

      }

      // takes back the players last action
      function undoLastMove (from_menu) {

        // SANITY CHECK!!!
        if (undo_hand.length <= 0 || undo_board.length <= 0 || !game_start || marathon)
          return

        var called_by_menu = from_menu || false

        console.log('UNDOING')

        // record this action for replays
        if (called_by_menu) {
          player.replay_data[player.timer.frame_ticker.toString()]
            = [player.x,player.y,"undo_menu",0]
        } else {
          player.replay_data[player.timer.frame_ticker.toString()]
            = [player.x,player.y,"undo",0]
        }

        console.log("replay_data")
        console.dir(player.replay_data)

        // disable player from earning stars and beating records
        player_undid = true
        screen_data.items[0].locked = true
        screen_data.items[1].locked = true
        screen_data.items[2].locked = true
        winlose_data.items[0].locked = true
        winlose_data.items[1].locked = true
        winlose_data.items[2].locked = true

        // reset item counts
        player.board.block_count = [0,0,0,0,0,0,0,0]
        player.board.flask_count = [0,0,0,0,0,0,0,0,0]
        player.board.robot_count = [0,0,0,0,0,0]

        // empty the players hand
        player.hand.items = new Array()
        Y_SPEED = FAST
        player.cursor_speed = Y_SPEED

        if (undo_hand.length > 1)
          undo_hand.pop()
        var player_state = undo_hand.pop()
        player.x = player_state[0]
        player.y = player_state[1]
        player.hand.level = player_state[2]
        var hand_state = player_state[3].split('\n')[0]
        player.score = player_state[4]
        screen_data.items[2].text = '\u03BB' + player.score

        // go through each item in this stack
        var items = (hand_state.length > 0) ? hand_state.split(',') : []
        for (var i=0; i < items.length; i++) {

          // construct new item from string data
          var item = items[i]
          var item_string = item.split('|')
          var type = item_string[0]
          var color = item_string[1]
          var this_item = new Item(player.hand,type,color,player.x,i)

          // push item to player hand
          player.hand.items.push(this_item)

          // update hand position
          this_item.x = player.x
          this_item.y = BOARD_HEIGHT - 1 - i
          this_item.stack = player.hand

          // update sprite destination
          this_item.sprite.dx = player.board.posx(this_item.x)
          this_item.sprite.dy = player.board.posy(this_item.y)

        }

        if (undo_board.length > 1)
          undo_board.pop()
        var board_state = undo_board.pop()

        player.board.clearBoard()
        player.board.fillLevel(player_level,player_stage,board_state)

        addStateForUndo(player.hand,player.board,true)

        console.log("popped the last hand and board states!")
        console.dir(undo_hand)
        console.dir(undo_board)
        console.dir(hand_state)
        console.dir(board_state)

        // finally, check for matches
        for(var s=0; s < player.board.stacks.length; s++) {
          var this_stack = player.board.stacks[s]
          this_stack.checkForMatches()
        }

      }

    }

    function pauseGame (pause_menu,player,restart_menu_item,save_menu_item) {

      if (pause) {
        return
      } else {
        pause = true
        pause_menu.active = true
        // pause all sounds currently playing
        // stopSounds()
      }


      // construct the pause menu
      pause_menu.items = new Array()
      pause_menu.items.push(new MenuItem(pause_menu,"Resume",function() {
        pause = false
        // playPausedSounds()
        player.controls()
      }))
      pause_menu.items.push(((level_edit) ? save_menu_item : restart_menu_item))
      pause_menu.items.push(new MenuItem(pause_menu,"Back to Menu",function() {
        if (!level_edit) {

          // update marathon progress
          if (marathon) {
            if (player.timer.clock_text > marathon_progress[0])
              marathon_progress[0] = player.timer.clock_text
            if (player.score > marathon_progress[1])
              marathon_progress[1] = player.score

            // update player_save data
            var player_save = $("saveData")
            player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
            // update cookie save
            setCookie("player_save",player_save.innerHTML,360000)
          }
          var record = buildRecordString(player.board,"Q")
          saveRecord(record)
          game_end = "Q"
        }
        if (!marathon)
          main_menu_auto = [(level_edit) ? 3 : 0,player_level,player_stage]
        else
          main_menu_auto = [1,0,0]
        jaws.start(MainMenu)
      }))

      console.log("constructed pause_menu = " + pause_menu.items.length)
    }

    function setupHowls () {
      // player sound effects
      grab_sound = new Howl({
        urls: ['./static/sfx/grab.mp3','./static/sfx/grab.ogg'],
        volume:.3
      })
      sound_effects.push(grab_sound)

      drop_sound = new Howl({
        urls: ['./static/sfx/drop.mp3','./static/sfx/drop.ogg'],
        volume:.3
      })
      sound_effects.push(drop_sound)
      // flask sound effects
      break_audio = new Howl({
        urls: ["./static/sfx/robot_death.mp3","./static/sfx/robot_death.ogg"],
        volume:.25
      })
      sound_effects.push(break_audio)
      brew_audio = new Howl({
        urls: ["./static/sfx/brew.mp3","./static/sfx/brew.ogg"],
        volume:.2
      })
      sound_effects.push(brew_audio)
      splash_audio = new Howl({
          urls: ["./static/sfx/break.mp3","./static/sfx/break.ogg"],
          volume:1
        })
      sound_effects.push(splash_audio)
      melt_audio = new Howl({
          urls: ["./static/sfx/melt1.mp3","./static/sfx/melt1.ogg"],
          volume:.1
      })
      sound_effects.push(melt_audio)
      white_audio = new Howl({
          urls: ["./static/sfx/white3.mp3","./static/sfx/white3.ogg"],
          volume:.5
      })
      sound_effects.push(white_audio)

      // // set onpause callback for each howl object
      // for (var i = 0; i < sound_effects.length; i++) {
      //   var this_sound = sound_effects[i]

      //   // push this sound onto the array of currently playing sounds
      //   this_sound.on('play', function() {
      //     playing_sound_effects.push(this)
      //   })

      //   // push this sound onto the array of currently paused sounds
      //   this_sound.on('pause', function() {
      //     paused_sound_effects.push(this)  
      //   })

      //   // remove this sound from array of currently playing sounds
      //   this_sound.on('end', function() {
      //     removeFromPlayingSounds(this)
      //   })


      // }
    }

    function setupSounds () {
      // player sound effects
      grab_sound = new jaws.Audio({
        volume:.3
      })
      grab_sound.setAudio("./static/sfx/grab.wav")
      sound_effects.push(grab_sound)

      drop_sound = new jaws.Audio({
        volume:.3
      })
      drop_sound.setAudio("./static/sfx/drop.wav")
      sound_effects.push(drop_sound)

      // flask sound effects
      break_audio = new jaws.Audio({
        volume:.25
      })
      break_audio.setAudio("./static/sfx/robot_death.wav")
      sound_effects.push(break_audio)

      brew_audio = new jaws.Audio({
        volume:.2
      })
      brew_audio.setAudio("./static/sfx/brew.wav")
      sound_effects.push(brew_audio)

      splash_audio = new jaws.Audio({
          volume:1
        })
      splash_audio.setAudio("./static/sfx/break.wav")
      sound_effects.push(splash_audio)

      melt_audio = new jaws.Audio({
          volume:.1
      })
      melt_audio.setAudio("./static/sfx/melt1.wav")
      sound_effects.push(melt_audio)

      white_audio = new jaws.Audio({
          volume:.5
      })
      white_audio.setAudio("./static/sfx/white3.wav")
      sound_effects.push(white_audio)

    }

    function stopSounds () {
      // stop all sounds
      for (var i=0; i<sound_effects.length;i++) {
        var this_sound = sound_effects[i]
        this_sound.stop()
      }
      playing_sound_effects = new Array()
    }

    function pauseSounds () {
      // pause all currently playing sounds
      for (var i=0; i<playing_sound_effects.length;i++) {
        var this_sound = playing_sound_effects[i]
        this_sound.pause()
      }
      playing_sound_effects = new Array()
    }

    function playPausedSounds() {

      if (mute)
        return

      // play all paused sounds
      for (var i=0; i<paused_sound_effects.length;i++) {
        var this_sound = paused_sound_effects[i]
        this_sound.play()
      }
      paused_sound_effects = new Array()
    }

    function removeFromPlayingSounds(this_sound) {
      var index = 0
      for (var j = 0; j < playing_sound_effects; j++) {
        if (this_sound == playing_sound_effects[j])
          break
        else
          index++
      }
      playing_sound_effects.splice(index,1);
    }

    function toggleMute() {
      if (mute) {
        $("muteButton").innerHTML = "Sound: On"
        mute = false
        stopSounds()
      } else {
        $("muteButton").innerHTML = "Sound: Off"
        mute = true
      }
    }

    function fisherYates ( myArray ) {
      var i = myArray.length, j, temp;
      if ( i === 0 ) return false;
      while ( --i ) {
         j = Math.floor( Math.random() * ( i + 1 ) );
         temp = myArray[i];
         myArray[i] = myArray[j];
         myArray[j] = temp;
       }
    }

    // construct record string
    function buildRecordString (board, winloss) {

      console.log("Buidling record string")

      var control_text = (board.player.keyboard_actions > board.player.mouse_actions) ? "KB" : (board.player.keyboard_actions == board.player.mouse_actions) ? "KM" : "MS"
      var record = "\n\n" + new Date((+new Date())) + "\n"

      if (marathon)
        record += player_name + " " + starTotal() + " " + control_text + " MRTHN-" + MAX_RAISE_LEVEL_TIME + " (" + board.player.score + ")/(" + board.player.timer.clock_text + ")/(" + board.player.moves + ") " + winloss
      else
        record += player_name + " " + starTotal() + " " + control_text + " " + player_level + "-" + player_stage + " (" + board.player.score + ")/(" + board.player.timer.clock_text + ")/(" + board.player.moves + ") " + winloss

      // append data for replays
      var player_moves = JSON.stringify(board.player.replay_data)
      record += "\n" + player_moves

      console.log("new_stars = " + board.player.new_stars)
      if (board.player.new_stars > 0) {
        record += "\n"
        for (var i = 0; i < star_progress.length; i++) {
          var level_progress = JSON.stringify(star_progress[i])
          record += "world " + i + " - " + level_progress + "\n"
        }
      }

      console.log(record)

      game_record = record

      console.log("game_record = " + game_record)

      return record

    }

    function starTotal() {

      var total = 0
      for (var i = 0; i < star_progress.length; i++) {
        for (var key in star_progress[i]) {
          for (var j = 0; j < star_progress[i][key].length; j++)
          total += star_progress[i][key][j]
        }
      }

      return total

    }

    function setCookie(c_name,value,exdays) {
      var exdate=new Date();
      exdate.setDate(exdate.getDate() + exdays);
      var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
      document.cookie=c_name + "=" + c_value;
    }

    function getCookie(c_name) {
      var c_value = document.cookie;
      var c_start = c_value.indexOf(" " + c_name + "=");
      if (c_start == -1)
        {
        c_start = c_value.indexOf(c_name + "=");
        }
      if (c_start == -1)
        {
        c_value = null;
        }
      else
        {
        c_start = c_value.indexOf("=", c_start) + 1;
        var c_end = c_value.indexOf(";", c_start);
        if (c_end == -1)
        {
      c_end = c_value.length;
      }
      c_value = unescape(c_value.substring(c_start,c_end));
      }
      return c_value;
    }

    // update star for a stage
    function updateStarProgress(player,player_level,player_stage,star_time,star_score,winlose_data) {

      var level_star_progress = star_progress[player_level]
      if (level_star_progress == undefined)
        star_progress.push({})
      var stage_star_progress = star_progress[player_level][player_stage.toString()]
      var new_stars = 0

      if (stage_star_progress == undefined) {
        star_progress[player_level][player_stage.toString()] = [1,0,0,0] // [complete,time,score,all]
        stage_star_progress = star_progress[player_level][player_stage.toString()]
        winlose_data.items[0].sprites[0].setImage("./static/images/STAR.gif")
        winlose_data.items[0].sprites[0].width = 15
        winlose_data.items[0].sprites[0].height = 15
        new_stars++
      } else {
        winlose_data.items[0].sprites[0].setImage("./static/images/STAR_BORDER.gif")
        winlose_data.items[0].sprites[0].width = 15
        winlose_data.items[0].sprites[0].height = 15
      }

      console.dir(winlose_data)

      var these_stars = 1

      // check if player got star time
      if (player.timer.clock_text <= star_time) {
        console.log("achieved star time = " + star_time)

        if (stage_star_progress[1] == 0) {
          winlose_data.items[1].sprites[0].setImage("./static/images/STAR.gif")
          winlose_data.items[1].sprites[0].width = 15
          winlose_data.items[1].sprites[0].height = 15
          new_stars++
        } else {
          winlose_data.items[1].sprites[0].setImage("./static/images/STAR_BORDER.gif")
          winlose_data.items[1].sprites[0].width = 15
          winlose_data.items[1].sprites[0].height = 15
        }

        stage_star_progress[1] = 1
        these_stars++
      }

      // check if player got star score
      if (player.score >= star_score) {
        console.log("achieved star score = " + star_score)

        if (stage_star_progress[2] == 0) {
          winlose_data.items[2].sprites[0].setImage("./static/images/STAR.gif")
          winlose_data.items[2].sprites[0].width = 15
          winlose_data.items[2].sprites[0].height = 15
          new_stars++
        } else {
          winlose_data.items[2].sprites[0].setImage("./static/images/STAR_BORDER.gif")
          winlose_data.items[2].sprites[0].width = 15
          winlose_data.items[2].sprites[0].height = 15
        }

        stage_star_progress[2] = 1
        these_stars++
      }

      // check if player got star time and star score
      if (these_stars >= 3) {
        console.log("achieved bonus star = " + star_score)

        if (stage_star_progress[3] == 0) {
          winlose_data.items[3].sprites[0].setImage("./static/images/STAR.gif")
          winlose_data.items[3].sprites[0].width = 15
          winlose_data.items[3].sprites[0].height = 15
          new_stars++
        } else {
          winlose_data.items[3].sprites[0].setImage("./static/images/STAR_BORDER.gif")
          winlose_data.items[3].sprites[0].width = 15
          winlose_data.items[3].sprites[0].height = 15
        }

        winlose_data.items[3].text = "Perfect"
        stage_star_progress[3] = 1
        these_stars++
      }

      console.log("stage_star_progress = ")
      console.dir(stage_star_progress)

      return new_stars

    }

    function saveImage (level,stage,encoded_data) {

      var json_data = JSON.stringify({'type': "saveImage", 'data': encoded_data, 'level': [level,stage]})

      console.log("saving image with json_data = " + json_data)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("level image saved to server: " + data)
          }
      });

    }

    function saveRecord (record) {

      var json_data = JSON.stringify({'type': "saveRecord", 'data': record})

      console.log("savingRecord() with json_data = " + json_data)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("record POSTed to server: " + data)
          }
      });

    }

    function saveLevel (level,stage,board,callback) {

      console.log("saving stage = " + level + "-" + stage)

      // construct level string
      var level_string = ""

      // go through each stack
      console.log("stacks = " + board.stacks)
      for (var s = 0; s < board.stacks.length; s++) {

        var this_stack = board.stacks[s]
        // go through each item in the stack
        console.log("this_stack.items = " + this_stack.items)
        for (var i = 0; i < this_stack.items.length; i++) {

          var this_item = this_stack.items[i]
          if (i>0) level_string = level_string + ","
          level_string = level_string + this_item.type + "|" + this_item.color

          console.log ("adding item, level_string = " + level_string)

        }

        level_string = level_string + "\n"

      }

      console.log("level_string = " + level_string)

      var json_data = JSON.stringify({'type': "saveLevel", 'data': level_string, 'level': [level,stage]})

      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          window.alert("level saved to server: " + data)
          callback()
        }
      })

    }

    function updateLevel (level,stage,score,callback) {

      console.log("updating stage = " + level + "-" + stage)

      var this_data = level_data.levels[player_level][player_stage-1]

      // array of stacks in string form
      var stacks_string = this_data.split('\n')
      var star_time = stacks_string[6]
      var star_score = score

      // construct level string
      var level_string = ""
      for (var s = 0; s < BOARD_WIDTH; s++) {
        level_string += stacks_string[s] + "\n"
      }
      level_string += star_time.toString() + "\n"
      level_string += score

      console.log("level_string = " + level_string)

      var json_data = JSON.stringify({'type': "saveLevel", 'data': level_string, 'level': [level,stage]})

      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          window.alert("level saved to server: " + data)
          callback()
        }
      })

    }

    function loadLevel (level,stage,board,callback) {

      var json_data = JSON.stringify({'type': "loadLevel", 'level': [level,stage]})

      console.log("loading stage = " + level)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("retrieved level data from server = " + data)
          callback(data,board)
        }
      })

    }

    function loadLevels (callback) {
      var json_data = JSON.stringify({'type': "loadLevels"})

      console.log("loading levels")
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("retrieved level data from server" + data)
          callback(data)
        }
      })
    }

    function deleteLevel (level,stage,callback) {

      var json_data = JSON.stringify({'type': "deleteLevel", 'level': [level,stage,latest_edit]})

      console.log("deleting stage = " + stage)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("deleted level data from server. last level found = 0-" + data)
          callback(data)
        }
      })

    }

    function findEditLevels (callback) {

      var json_data = JSON.stringify({'type': "findEditLevels"})

      console.log("finding last edited level")
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("last level found = 0-" + data)
          callback(data)
        }
      })

    }

    function MenuItem(menu,text,action) {

      this.menu = menu
      this.text = text
      this.action = action
      this.active = true

      this.locked = false
      this.star_lock = 100

      this.description = ""

      this.color

      this.sprites = new Array()

    }

    function MenuBox(title,parent,x,y,width,items,scrolling,right_for_ok) {

      console.log("constructing menubox with title = " + this.title + " at (" + x + "," + y + ")")


      var SPRITE_WIDTH = 10

      this.title = title
      this.parent = parent // parent menu
      this.submenus = new Array() // submenus (ok box, etc.)

      this.x = x
      this.y = y
      this.width = width
      this.items = items // menu items
      this.index = 0 // item currently chosen
      this.back
      this.active = false
      this.mouse_inside = false
      this.scrolling = scrolling || false
      this.right_for_ok = right_for_ok || false
      this.old_mouse_x = jaws.mouse_x
      this.old_mouse_y = jaws.mouse_y

      this.setup = function(x,y,width) {

        this.x = x
        this.y = y
        // calculate height
        if (this.scrolling)
          this.height = 70
        else
          this.height = 20 * (this.items.length + ((this.title == "") ? 0 : 1)) + 30

        this.sprites = new Array()

        console.log("earthbou")
        this.sprite_sheet = new jaws.SpriteSheet({
          image: "./static/images/MENUBOX_SPRITES.gif", frame_size: [SPRITE_WIDTH,SPRITE_WIDTH]})
        console.log("earthbou.zip")

        var edge_width  = width - SPRITE_WIDTH*2
        var edge_height = this.height - SPRITE_WIDTH*2

        this.sprite_nw = new jaws.Sprite({x:x, y:y, image: this.sprite_sheet.frames[0]})
        this.sprite_n = new jaws.Sprite({x:x + SPRITE_WIDTH, y:y, image: this.sprite_sheet.frames[1]})
        this.sprite_ne = new jaws.Sprite({x:x + SPRITE_WIDTH + edge_width, y:y, image: this.sprite_sheet.frames[2]})
        this.sprite_w = new jaws.Sprite({x:x, y:y + SPRITE_WIDTH, image: this.sprite_sheet.frames[3]})
        this.sprite_e = new jaws.Sprite({x:x + SPRITE_WIDTH + edge_width, y:y + SPRITE_WIDTH, image: this.sprite_sheet.frames[4]})
        this.sprite_sw = new jaws.Sprite({x:x, y:y + SPRITE_WIDTH + edge_height, image: this.sprite_sheet.frames[5]})
        this.sprite_s = new jaws.Sprite({x:x + SPRITE_WIDTH, y:y + SPRITE_WIDTH + edge_height, image: this.sprite_sheet.frames[6]})
        this.sprite_se = new jaws.Sprite({x:x + SPRITE_WIDTH + edge_width, y:y + SPRITE_WIDTH + edge_height, image: this.sprite_sheet.frames[7]})

        // fix widths and heights for edges
        this.sprite_n.width = this.sprite_s.width = edge_width
        this.sprite_w.height = this.sprite_e.height = edge_height
      }

      this.setup(x,y,width)

      // provide coordinates of clicks with respect to menu item index
      this.menuCoordinates = function(x,y,right_click) {

        // find click coordinates with respect to board's top-left position in canvas
        var menu_x = x - this.x
        var menu_y = y - this.y

        var outside_x = false
        var outside_y = false

        if (menu_x < 0 || menu_x > this.width)
          outside_x = true
        if (menu_y < 0 || menu_y > this.height)
          outside_y = true

        if (outside_x || outside_y) {
          this.mouse_inside = false
          return this.index
        }

        var index = (menu_y - 30)/20 - ((this.title == "") ? 0 : 1)

        if (index < 0)
          index = 0
        else if (index > this.items.length - 1)
          index = this.items.length - 1

        this.mouse_inside = true
        return Math.round(index)
      }

      this.scroll_action = function() {

        console.log("scrolling action")
        for (var i = 0; i < this.star_sprites.length; i++) {
          this.star_sprites[i].active = false
        }
        var level_name = this.items[this.index].text

        // activate ok submenu of this item is unlocked
        var level_index = 0
        for (var i = 0; i < this.items.length; i++)
          if (this.items[i].text == level_name) {
            level_index = i
            break
          }
        if (this.items[level_index].locked) {
          for (var i=0; i < this.submenus[0].menu_box.sprites.length; i++) {
            this.submenus[0].menu_box.sprites[i].active = true
          }
          this.submenus[0].menu_box.items[0].text = "      x " + ((this.items[level_index].star_lock == undefined) ? "?" : this.items[level_index].star_lock)
        } else {
          for (var i=0; i < this.submenus[0].menu_box.sprites.length; i++) {
            this.submenus[0].menu_box.sprites[i].active = false
          }
          this.submenus[0].menu_box.items[0].text = "OK"
        }

        // display how many stars player has earned for this level
        level_name = level_name.split("-")
        var level = parseInt(level_name[0])
        var stage = level_name[1]
        var these_stars = 0     
        console.log("star_progress = ")
        console.dir(star_progress)       
        if (star_progress[level][stage] != undefined) {
          for (var i = 0; i < star_progress[level][stage].length; i++) {        
            these_stars += star_progress[level][stage][i]
          }
        }
        for (var i = 0; i < these_stars; i++) {
          if (this.star_sprites[i] != undefined)
            this.star_sprites[i].active = true
        }

        // TODO: display star lock

      }

      this.up_action = function() {
        console.log("up_action")
        if (this.index > 0) 

          if (this.scrolling) {
            var old_index = this.index
            this.index--
            while (!this.items[this.index].active && this.index > 0) {
              this.index--    
            }
            if (this.items[this.index].active)
              this.scroll_action()
            else
              this.index = old_index

          } else {
            this.index--
            while (!this.items[this.index].active) {
              this.index--
            }
          }
      }

      this.down_action = function() {
        console.log("down_action")
        if (this.index < this.items.length - 1) 

          if (this.scrolling) {
            var old_index = this.index
            this.index++
            while (!this.items[this.index].active && this.index < this.items.length - 1) {
              this.index++
            }
            if (this.items[this.index].active)
              this.scroll_action()     
            else 
              this.index = old_index         

          } else {
            this.index++
            while (!this.items[this.index].active) {
              this.index++
            }
          }
      }

      this.controls = function(menu,ok_submenu,menus) {

        jaws.on_keydown(["up","w"], function() {
          (menu.scrolling) ? menu.down_action() : menu.up_action()
        })

        jaws.on_keydown(["down","s"], function() {
          (menu.scrolling) ? menu.up_action() : menu.down_action()
        })

        jaws.on_keydown(["enter","space","k"], function() {
          if (menu.items[menu.index].active && !menu.items[menu.index].locked) {
            console.log("performing action")
            menu.items[menu.index].action(jaws)
          }
        })

        jaws.on_keydown(["right","d"], function() {
          if (!right_for_ok)
            return
          if (menu.items[menu.index].active && !menu.items[menu.index].locked) {
            console.log("performing action")
            menu.items[menu.index].action(jaws)
          }
        })

        jaws.on_keydown(["esc","a","left","j","z","c"], function() {
          if (scrolling)
            menus.pop()
          menu.back()
        })

        jaws.on_keydown(["left_mouse_button"], function() {

          if (menu.scrolling) {

            console.log("click button")
            if (menu.sprites[0].mouse_over) {
              menu.down_action()
              console.log("up button")
            }
            else if (menu.sprites[1].mouse_over) {
              console.log("click on down arrow")
              menu.up_action()
            }
            else if (ok_submenu.menu_box.mouse_inside) {
              if (!menu.items[menu.index].locked)
                menu.items[menu.index].action()
            } else if (menu.mouse_inside)
              return
            else {
              menus.pop()
              menu.back()
            }

          } else {
            if(menu.mouse_inside) {
              if(!menu.items[menu.index].locked && menu.items[menu.index].active)
                menu.items[menu.index].action()
            } else
              menu.back()
          }

        })

      }

      // sets the game to acknowledge a new active menu
      this.setActiveMenu = function(new_active,active_menu,ok_submenu) {
          console.log("set active menu!")
          this.active = false
          active_menu = new_active
          active_menu.active = true
          active_menu.controls(active_menu,ok_submenu)
          return active_menu
      }

      this.update = function() {

        if (this.scrolling) {
          // update arrow sprites
          for (var s=0; s < 2; s++) {
            var this_sprite = this.sprites[s]

            if (jaws.mouse_x > this_sprite.x && jaws.mouse_x < this_sprite.x + this_sprite.width &&
                jaws.mouse_y > this_sprite.y && jaws.mouse_y < this_sprite.y + this_sprite.height) {
              this_sprite.mouse_over = true
            }
            else
              this_sprite.mouse_over = false

            if (this_sprite.mouse_over && this_sprite.image == this.arrow_sprites.frames[s])
              this_sprite.image = this.arrow_sprites.frames[s+2]
            else if (!this_sprite.mouse_over && this_sprite.image == this.arrow_sprites.frames[s+2])
              this_sprite.image = this.arrow_sprites.frames[s]
          }
        }

        for (var s=0; s < this.submenus.length; s++) {
          this.submenus[s].update()
        }

        return
      }

      this.draw = function() {

        // update index according to mouse position if menu is active
        if (this.active && !this.scrolling && this.old_mouse_x != jaws.mouse_x && this.old_mouse_x != jaws.mouse_x)
          this.index = this.menuCoordinates(jaws.mouse_x,jaws.mouse_y)

        this.old_mouse_x = jaws.mouse_x
        this.old_mouse_y = jaws.mouse_y

        jaws.context.fillStyle = "Black"
        jaws.context.fillRect(this.x + 2,this.y + 2,this.width - 4,this.height - 4)

        // draw edges
        this.sprite_nw.draw()
        this.sprite_n.draw()
        this.sprite_ne.draw()
        this.sprite_w.draw()
        this.sprite_e.draw()
        this.sprite_sw.draw()
        this.sprite_s.draw()
        this.sprite_se.draw()

        // draw title
        var j = 0
        if (this.title != "") {
          jaws.context.font = MENU_FONT
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  "Red"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(this.title, this.x + 20, this.y + 30)
          j++
        }

        if (this.scrolling) {

          var this_item = this.items[this.index]

          jaws.context.font = MENU_FONT
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  (this_item.locked) ? "Brown" : "Red"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(this_item.text, this.x + 20, this.y + 20 * (1 + j) + 10)

        } else {

          // draw menu items
          for (var i=0; i < this.items.length; i++) {

            var this_item = this.items[i]

            if (!this_item.active)
              continue

            jaws.context.font = MENU_FONT
            jaws.context.lineWidth = 10
            jaws.context.fillStyle =  (this_item.color == undefined) ? ((this.index == i) ? ((this_item.locked) ? "Brown" : "Red") : ((this_item.locked) ? "Grey" : "White")) : this_item.color
            jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
            jaws.context.fillText(this_item.text, this.x + 20, this.y + 20 * (i + 1 + j) + 10)

            // draw this menu item's sprites
            for (var s=0; s < this_item.sprites.length; s++) {
              this_item.sprites[s].draw()
            }

          }
        }

        // draw sprites
        for (var s=0; s < this.sprites.length; s++) {

          var this_sprite = this.sprites[s]

          if (!this_sprite.active) {
            this_sprite.mouse_over = false
            continue
          }

          this_sprite.draw()
        }

      }

    }

    // ok sub menu class
    function OkSubMenu(title,parent,action) {

      this.menu_box = new MenuBox(title,parent,parent.x, parent.y + parent.height, parent.width, [new MenuItem(parent,"OK",function() {
        action()
      })])

      this.sprites = new Array()

      this.update = function() {
        if (this.menu_box.active) {
          if (this.menu_box.mouse_inside)
            this.menu_box.index = 0
          else
            this.menu_box.index = -1
        }
      }

      this.draw = function() {
        this.menu_box.draw()
        for(var s=0; s<this.sprites.length; s++) {
          this.sprites[s].draw()
        }
      }

    }

    function MainMenu() {

      var active_menu
      var menus = new Array()
      var level_select_string = (player_progress.length-1) + "-" + player_progress[player_progress.length-1][0]
      var star_total_sprite
      var description_box
      var level_record

      // unhide progress buttons
      var progress_buttons = $("progressButtons")
      progress_buttons.hidden = false
      $("live_info").innerHTML = ""

      var player_save = $("saveData")
      player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)  
      // update cookie save
      setCookie("player_save",player_save.innerHTML,360000)

      this.back = function() {
          var this_menu = menus.pop()
          active_menu = this_menu.setActiveMenu(this_menu.parent,active_menu)
      }

      this.setup = function() {        

        // main menu
        var main_menu_items = new Array()
          main_menu_items.push(new MenuItem(main_menu,"Puzzle Mode",function() {
            menus.push(level_select_menu)
            menus.push(level_select_ok)
            level_select_menu.submenus.push(level_select_ok)
            // level_select_ok.active = true
            level_select_ok.menu_box.active = true
            if (level_select_menu)
            active_menu = level_select_menu.parent.setActiveMenu(level_select_menu,active_menu,level_select_ok)
            level_edit = false
            marathon = false
            level_select_menu.controls(level_select_menu,level_select_ok,menus)
            var level_count = 1
            for (var i = 0; i < player_progress.length; i++) {
              console.log(player_progress[i][0])
              level_count += parseInt(player_progress[i][0])
            }
            console.log("level_count = " + level_count)
            if (level_count + 1 >= level_select_menu.items.length)
              level_select_menu.index = level_select_menu.items.length - 1
            else
              level_select_menu.index = level_count
          
            for (var i = 0; i < level_select_menu.star_sprites.length; i++) {
              level_select_menu.star_sprites[i].active = false
            }
            level_select_menu.scroll_action()
              

          }))
          main_menu_items[main_menu_items.length-1].description
            = "Brew potions to destroy robots. Clear\n" +
            "all robots from the board to advance to\n" +
            "the next level."
          main_menu_items.push(new MenuItem(main_menu,"Marathon",function() {
            level_edit = false
            marathon = true
            jaws.start(Game)
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Stacks rise toward the top of the board.\n" +
            "Try to survive and beat your high score!"

          var marathon_menu_item = main_menu_items[main_menu_items.length-1]
          marathon_menu_item.star_lock = MARATHON_STAR_LOCK
          marathon_menu_item.locked = (starTotal() >= marathon_menu_item.star_lock) ? false : true
          main_menu_items.push(new MenuItem(main_menu,"Change Name",function() {
            jaws.start(PlayerNameState)
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Change your name."
          main_menu_items.push(new MenuItem(main_menu,"Level Editor",function() {
            menus.push(level_select_menu)
            menus.push(level_select_ok)
            level_select_menu.submenus.push(level_select_ok)
            // level_select_ok.active = true
            level_select_ok.menu_box.active = true
            active_menu = level_select_menu.parent.setActiveMenu(level_select_menu,active_menu,level_select_ok)
            level_select_menu.controls(level_select_menu,level_select_ok,menus)
            level_edit = true
            marathon = false
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Let's make some levels, Kris."
          main_menu_items.push(new MenuItem(main_menu,"How to Play",function() {
            menus.push(help_menu)
            active_menu = help_menu.parent.setActiveMenu(help_menu,active_menu)
          }))
          // main_menu_items[main_menu_items.length-1].active = false
          main_menu_items[main_menu_items.length-1].description
            = "Learn about the controls and score system."
          main_menu_items.push(new MenuItem(main_menu,"Save Progress",function() {
            menus.push(save_menu)
            active_menu = save_menu.parent.setActiveMenu(save_menu,active_menu)
            console.dir(active_menu)
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Save, Load, or Reset your progress.\n"
          main_menu_items.push(new MenuItem(main_menu,"Replay Mode",function() {
            var input_string = window.prompt("enter replay string","")

            var replay_data = JSON.parse(input_string)

            var input_level = window.prompt("enter level","world-level")
            var level_name = input_level.split("-")
            player_level = parseInt(level_name[0])
            player_stage = level_name[1]

            console.log("REPLAY DATA")
            console.dir(replay_data)
            console.dir(input_level)

            jaws.start(Game)

          }))
        var main_menu = new MenuBox("",main_menu,ITEM_WIDTH,ITEM_WIDTH,200,main_menu_items,false,true)

        main_menu.items[3].active = false // set level editor to be inactive

        menus.push(main_menu)
        active_menu = main_menu
        active_menu.active = true


        // level select menu
        var level_select_menu = new MenuBox("Level",main_menu,main_menu.x + main_menu.width + 1, main_menu.y, 150, new Array(),true,true)
        level_select_menu.back = this.back

        var level_select_ok = new OkSubMenu("",level_select_menu,function() {
          level_select_menu.items[menu.index].action(jaws)
        })

        // add level menu items
        var item_count = 0
        for (var i = 0; i < level_data.levels.length; i++) {
          for (var j = 0; j < level_data.levels[i].length; j++) {
            if (i == 1 && j+1 == 1)
              level_select_menu.index = item_count
            var this_level = new MenuItem(level_select_menu,(i + "-" + (j+1)),function() {
                var level_name = level_select_menu.items[level_select_menu.index].text
                level_name = level_name.split("-")
                player_level = level_name[0]
                player_stage = level_name[1]
                jaws.start(Game)
            })
            var this_level_star_lock = level_data.levels[i][j].split('\n')[8]
            this_level.star_lock = (this_level.text[0] != "1") ? ((this_level_star_lock == undefined) ? ZERO_STAR_LOCK : this_level_star_lock) : this_level_star_lock

            // set "l-1" to be active but locked unless star_lock met
            if (j == 0) {
              this_level.active = true
              this_level.locked = (starTotal() >= this_level.star_lock) ? false : true

            // set other puzzles to be inactive unless previous puzzle completed
            } else {
              if (j > player_progress[i][0])
                this_level.active = false
              else
                this_level.active = true
            }

            // set world 0 to be inactive
            if (i == 0)
              this_level.active = false

            level_select_menu.items.push(this_level)
            item_count++
          }
        }
        console.log("level_select_menu")
        console.dir(level_select_menu)

        // level select arrows
        level_select_menu.arrow_sprites = new jaws.SpriteSheet({
          image: "./static/images/ARROWS.gif", frame_size: [20,10]})

        level_select_menu.up_arrow = new jaws.Sprite({x:level_select_menu.x + 100, y:level_select_menu.y + 20, image: level_select_menu.arrow_sprites.frames[0]})
        level_select_menu.down_arrow = new jaws.Sprite({x:level_select_menu.x + 100, y:level_select_menu.y + 38, image: level_select_menu.arrow_sprites.frames[1]})

        level_select_menu.up_arrow.height = 15
        level_select_menu.down_arrow.height = 15

        level_select_menu.up_arrow.mouse_over = false
        level_select_menu.down_arrow.mouse_over  = false

        level_select_menu.up_arrow.active = true
        level_select_menu.down_arrow.active = true

        level_select_menu.sprites.push(level_select_menu.up_arrow)
        level_select_menu.sprites.push(level_select_menu.down_arrow)

        // level select stars
        level_select_menu.star_sprites = new Array()
        var star_sprite_1 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+36,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_1.width = 15
        star_sprite_1.height = 15
        level_select_menu.sprites.push(star_sprite_1)
        level_select_menu.star_sprites.push(star_sprite_1)
        star_sprite_1.active = false

        var star_sprite_2 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+21,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_2.width = 15
        star_sprite_2.height = 15
        level_select_menu.sprites.push(star_sprite_2)
        level_select_menu.star_sprites.push(star_sprite_2)
        star_sprite_2.active = false

        var star_sprite_3 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+6,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_3.width = 15
        star_sprite_3.height = 15
        level_select_menu.sprites.push(star_sprite_3)
        level_select_menu.star_sprites.push(star_sprite_3)
        star_sprite_3.active = false

        var star_sprite_4 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+51,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_4.width = 15
        star_sprite_4.height = 15
        level_select_menu.sprites.push(star_sprite_4)
        level_select_menu.star_sprites.push(star_sprite_4)
        star_sprite_4.active = false

        level_select_menu.star_sprites = new Array()

        star_total_sprite = new jaws.Sprite({x:ITEM_WIDTH+140,y:13,image:"./static/images/STAR.gif",anchor:"left"})        
        star_total_sprite.width = 15
        star_total_sprite.height = 15
        console.log("star_total_sprite")
        console.dir(star_total_sprite)

        // lock sprite
        var lock_sprite = new jaws.Sprite({x:level_select_ok.menu_box.x+21,y:level_select_ok.menu_box.y,image:"./static/images/LOCK.gif",anchor:"left"})        
        console.log("lock_sprite")
        console.dir(lock_sprite)
        console.dir(level_select_ok)
        level_select_ok.menu_box.sprites.push(lock_sprite)
        lock_sprite.active = true

        // star lock sprite
        var star_lock_sprite = new jaws.Sprite({x:level_select_ok.menu_box.x+64,y:level_select_ok.menu_box.y+17,image:"./static/images/STAR.gif",anchor:"left"})        
        star_lock_sprite.width = 15
        star_lock_sprite.height = 15
        console.log("star_lock_sprite")
        console.dir(star_lock_sprite)
        console.dir(menus[0].submenus)
        level_select_ok.menu_box.sprites.push(star_lock_sprite)
        star_lock_sprite.active = true

        // marathon star lock menu
        var marathon_star_lock_menu = new OkSubMenu("",main_menu,function(){})
        marathon_star_lock_menu.menu_box.items[0].text = "      x " + main_menu.items[1].star_lock
        main_menu.submenus.push(marathon_star_lock_menu)
        marathon_star_lock_menu.menu_box.setup(main_menu.x + main_menu.width/2 + ITEM_WIDTH*2, main_menu.y + 20,level_select_ok.menu_box.width)
        marathon_star_lock_menu.menu_box.index = -1



        // help menu
        var help_menu_items = new Array()
        help_menu_items.push(new MenuItem(help_menu, "Keyboard Control", function() {
          menus.push(keyboard_menu)
          active_menu = keyboard_menu.parent.setActiveMenu(keyboard_menu,active_menu)
          }))
        help_menu_items[help_menu_items.length-1].description
          = "Move cursor with the arrow keys (or WASD).\n"
          + "Press SPACE (or J) to grab items.\n"
          + "While holding, SPACE (or J) drops an item.\n"
          + "Press C (or K) to grab/drop a whole stack."
        help_menu_items.push(new MenuItem(help_menu, "Mouse Control", function() {
          menus.push(mouse_menu)
          active_menu = mouse_menu.parent.setActiveMenu(mouse_menu,active_menu)
          }))
        help_menu_items[help_menu_items.length-1].description
          = "Click items to grab them.\n"
          + "While holding, click the board to drop an\n"
          + "item or click on held items to drop them.\n"
          + "Right click to grab/drop a whole stack."
        help_menu_items.push(new MenuItem(help_menu, "Scoring", function() {return}))
        help_menu_items[help_menu_items.length-1].description
          = "Melt block    : \u03BB100\n"
          + "Brew potion   : \u03BB100\n"
          + "Destroy robot : \u03BB500\n"
          + "Perform chains to multiply your score."
        help_menu_items.push(new MenuItem(help_menu, "Misc.", function() {return}))
        help_menu_items[help_menu_items.length-1].description
          = "Press CTRL+Z to undo your last move.\n"
          + "(no stars can be earned if you undo)\n"
          + "Press L or click outside of the board\n"
          + "to make the stacks rise in marathon."
        var help_menu = new MenuBox("",main_menu,main_menu.x + main_menu.width + 1, main_menu.y + 40, 200, help_menu_items)
        help_menu.back = this.back

        if (starTotal() <= 0)
          main_menu.index = 4

        // save menu
        var save_menu_items = new Array()
          save_menu_items.push(new MenuItem(save_menu, "Save", function() {
            var player_save = $("saveData")
            player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
            // update cookie save
            setCookie("player_save",player_save.innerHTML,360000)

            save_menu_items[0].description += "\n\nSaved."
          }))
          save_menu_items.push(new MenuItem(save_menu, "Export Save", function() {
            var save_string = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
            save_string = sjcl.encrypt("zonky",save_string)
            window.prompt("Copy this text and keep it somewhere safe!",save_string)
          }))
          save_menu_items.push(new MenuItem(save_menu, "Import Save", function() {

            var input_string = window.prompt("enter save string","")

            input_string = sjcl.decrypt("zonky",input_string)

            // load save file
            var open_data = input_string.split("|")
            if (open_data[0] == "SuperWizardPotionSave") {

              console.log("open_data = ")
              console.dir(open_data)
              // window.alert("OPEN DATA")

              player_name = open_data[1]
              player_progress = JSON.parse(open_data[2])
              star_progress = JSON.parse(open_data[3])
              marathon_progress = JSON.parse(open_data[4])
              $("openData").innerHTML = ""
              jaws.start(MainMenu)
            }
          }))
          save_menu_items.push(new MenuItem(save_menu, "Reset", function() {
            menus.push(reset_menu)
            reset_menu.index = 1
            active_menu = reset_menu.parent.setActiveMenu(reset_menu,active_menu)
          }))
        var save_menu = new MenuBox("",main_menu,main_menu.x + main_menu.width + 1, main_menu.y + 40, 160, save_menu_items, false, true)
        save_menu.back = this.back
        save_menu_items[0].description = "Save your progress manually\n"
          + "(the game autosaves after each level)."
        save_menu_items[1].description = "Back up your progress by exporting\n"
          + "it as a save string."
        save_menu_items[2].description = "Load your progress with\n"
          + "a save string."
        save_menu_items[3].description = "Delete all your progress.\n"

        // reset sub menu
        var reset_menu_items = new Array()
          reset_menu_items.push(new MenuItem(reset_menu, "Yes", function() {
            player_name = ""
            player_progress = [[0,{}],[0,{}],[0,{}],[0,{}],[0,{}],[0,{}],[0,{}]]
            star_progress = [{},{},{},{},{},{},{}]
            marathon_progress = ["00:00",0]
            player_level = 1
            player_stage = 1
            main_menu_auto = undefined
            jaws.start(PlayerNameState)
          }))
          reset_menu_items.push(new MenuItem(reset_menu, "No", function() {
            reset_menu.back()
          }))
        var reset_menu = new MenuBox("Really?",save_menu,save_menu.x + save_menu.width + 1, save_menu.y, 150, reset_menu_items)
        reset_menu.index = 1
        reset_menu.back = function() {
          menus.pop()
          active_menu = reset_menu.setActiveMenu(reset_menu.parent,active_menu)
        }
        reset_menu_items[0].description = "Delete all your progress.\n"
          + "\nNo take-backsies. You might want\n"
          + "to Export Save first."
        reset_menu_items[1].description = "Delete all your progress.\n"
          + "\nNo take-backsies. You might want\n"
          + "to Export Save first."

        description_box = new MenuBox("",description_box,main_menu.x,main_menu.y+main_menu.height+1+ITEM_WIDTH/2,500, [new MenuItem(description_box,"",function(){}),new MenuItem(description_box,"",function(){}),new MenuItem(description_box,"",function(){}),new MenuItem(description_box,"",function(){})])
        description_box.index = -1

        // level record data
        var level_record_items = new Array()
        level_record_items.push(new MenuItem(level_record,"Completed!",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Time:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Score:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"",function() {return}))

        level_record = new MenuBox("",level_record,level_select_menu.x + level_select_menu.width - 30, level_select_menu.y+5, 230, level_record_items)
        level_record.index = -1

        // add star sprites for level record data
        for (var s=0; s < level_record_items.length; s++) {
          var this_sprite = new jaws.Sprite({x:level_record.x,y:level_record.y+36 + 20*(s-1),anchor:"left",image:"./static/images/STAR.gif"})
          this_sprite.width = 15
          this_sprite.height = 15
          this_sprite.active = false
          level_record.sprites.push(this_sprite)

        }

        // go to submenu if specified by player quitting a level
        console.log("MAINMENUAUTO")
        console.dir(main_menu_auto)
        if (main_menu_auto != undefined) {
          if (main_menu_auto[0] == 0 || main_menu_auto[0] == 3) {
            
            main_menu.items[main_menu_auto[0]].action()
            main_menu.index = main_menu_auto[0]

            console.log("here")

            var item_count = 0
            for (var i = 0; i < level_data.levels.length; i++) {
              for (var j = 0; j < level_data.levels[i].length; j++) {
                var this_level = level_select_menu.items[item_count]
                var level_name = this_level.text.split("-")
                if (main_menu_auto[1]==level_name[0] && main_menu_auto[2]==level_name[1]) {
                  level_select_menu.index = item_count
                  break
                }
                item_count++
              }
            }
            console.log("there")
          } else if (main_menu_auto[0] == 1) {
              main_menu.index = 1
              active_menu.controls(active_menu)
            }
        } else
        // controls
        active_menu.controls(active_menu)
      }

      this.update = function() {

        // load save file
        var open_data = $("openData").innerHTML.split("|")
        if (open_data[0] == "SuperWizardPotionSave") {

          console.log("open_data = ")
          console.dir(open_data)
          // window.alert("OPEN DATA")

          player_name = open_data[1]
          player_progress = JSON.parse(open_data[2])
          star_progress = JSON.parse(open_data[3])
          marathon_progress = JSON.parse(open_data[4])
          $("openData").innerHTML = ""
          jaws.start(MainMenu)
        }

        // update description box
        // var description = menus[0].items[menus[0].index].description.split("\n")
        var description = active_menu.items[active_menu.index].description.split("\n")
        for (var i=0; i < description_box.items.length; i++) {
          description_box.items[i].text = (description[i] == undefined) ? "" : description[i]
        }
          
        for (var i = 0; i < menus.length; i++) {
          menus[i].update()
        }

      }

      this.draw = function() {

        jaws.context.fillStyle = "Black"
        jaws.context.fillRect(0,0,jaws.width,jaws.height)

        // player name
        jaws.context.font = MENU_FONT
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Red"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText(player_name, ITEM_WIDTH + 17, 28)

        // star sprite
        star_total_sprite.x = ITEM_WIDTH + 19 + player_name.length*12.5
        star_total_sprite.draw()

        // player star count
        jaws.context.font = MENU_FONT
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "White"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText("x " + starTotal(), star_total_sprite.x + star_total_sprite.width + 10, 28)

        for (var i = 0; i < menus.length; i++) {
          menus[i].draw()
        }

        // draw description box
        if (menus[0].index == 1 && menus[0].items[1].locked) {
          var marathon_submenu = menus[0].submenus[0]
          marathon_submenu.sprites.push(new jaws.Sprite({x:marathon_submenu.menu_box.x+21,y:marathon_submenu.menu_box.y,image:"./static/images/LOCK.gif",anchor:"left"}))
          var star_lock_sprite = new jaws.Sprite({x:marathon_submenu.menu_box.x+64,y:marathon_submenu.menu_box.y+17,image:"./static/images/STAR.gif",anchor:"left"})
          star_lock_sprite.width = 15
          star_lock_sprite.height = 15
          marathon_submenu.sprites.push(star_lock_sprite)
          menus[0].submenus[0].draw()
        } else if (menus[0].index == 1){
          var marathon_submenu = menus[0].submenus[0]
          console.dir(marathon_submenu.menu_box)
          marathon_submenu.menu_box.items[0].text = "Best Time:  " + marathon_progress[0]
          if (marathon_submenu.menu_box.items[1] == undefined) {
            marathon_submenu.menu_box.items.push(new MenuItem(marathon_submenu.menu_box,"High Score:",function(){return}))
            marathon_submenu.menu_box.setup(marathon_submenu.menu_box.x,marathon_submenu.menu_box.y,marathon_submenu.menu_box.width+30)
          }
          marathon_submenu.menu_box.items[1].text = "High Score: \u03BB" + marathon_progress[1]
          marathon_submenu.menu_box.index = -1
          marathon_submenu.draw()
        }
        if (active_menu.items[active_menu.index].description != "")
          description_box.draw()

        // draw level record
        if (menus[0].index == 0 && menus[1] != undefined && menus[1].title == "Level") {
          var level_select_submenu = menus[1]
          var level_menu_item = level_select_submenu.items[level_select_submenu.index]
          var level_name = level_menu_item.text.split("-")
          var level = parseInt(level_name[0])
          var stage = level_name[1]
          if (player_progress[level][1][stage] != undefined) {
            level_record.items[1].text = "Best Time:  " + player_progress[level][1][stage][0]
            level_record.items[2].text = "High Score: \u03BB" + player_progress[level][1][stage][1]
            
            // show appropriate stars
            level_record.sprites[0].active = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? true : false
            level_record.sprites[1].active = (star_progress[level][stage] != undefined && star_progress[level][stage][1] > 0) ? true : false
            level_record.sprites[2].active = (star_progress[level][stage] != undefined && star_progress[level][stage][2] > 0) ? true : false
            level_record.sprites[3].active = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? true : false
            level_record.items[0].text = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? "Completed!" : "Completed (undo)"
            if (star_progress[level][stage] == undefined) {
              level_menu_item.description = "Complete the level without\n"
                + "undoing to earn stars."
            } else
              level_menu_item.description = ""
            level_record.items[3].text = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? "Perfect" : ""
            if (!level_menu_item.locked) {
              level_record.draw()
            }
          }
        }

      }

    }

    function PlayerNameState() {

      messageConsole = function() {
        console.log("player_name = " + player_name)
      }

      var name_text = "       " + player_name
      if (player_name.length < 10) name_text = name_text + "_"

      var enter_name
      var enter_name_items = new Array()
        enter_name_items.push(new MenuItem(enter_name,"Please enter your name: ",function(){return
        }))
        enter_name_items.push(new MenuItem(enter_name,name_text,function(){
          return
        }))

      enter_name = new MenuBox("",enter_name,ITEM_WIDTH,ITEM_WIDTH,300,enter_name_items)
      enter_name.index = 1

      // enter name OK sub menu
      var enter_name_ok = new MenuBox("",enter_name,enter_name.x, enter_name.y + enter_name.height, 300, [new MenuItem(enter_name_ok,"          OK",function() {
        if (player_name.length > 0)
          jaws.switchGameState(MainMenu)
      })])
      enter_name_ok.active = true

      this.setup = function() {

        this.controls(enter_name,enter_name_ok)
      }

      this.draw = function() {

        // load save file
        var open_data = $("openData").innerHTML.split("|")
        if (open_data[0] == "SuperWizardPotionSave") {
          player_name = open_data[1]
          player_progress = JSON.parse(open_data[2])
          star_progress = JSON.parse(open_data[3])
          marathon_progress = JSON.parse(open_data[4])
          $("openData").innerHTML = ""
          jaws.start(MainMenu)
        }

        jaws.context.clearRect(0,0,jaws.width,jaws.height)

        jaws.context.fillStyle = "Black"
        jaws.context.fillRect(0,0,jaws.width,jaws.height)

        // update name_text
        name_text = "       " + player_name
        if (player_name.length < 10) name_text = name_text + "_"
        enter_name.items[1].text = name_text
        enter_name.draw()

        if (enter_name_ok.active) {
          if (enter_name_ok.mouse_inside)
            enter_name_ok.index = 0
          else
            enter_name_ok.index = -1
        }
        enter_name_ok.draw()

        jaws.context.font = "bold 30pt terminal";
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Black"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText("Please enter your name:", 125, 225)

        jaws.context.font = "bold 30pt terminal";
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Black"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"

        var name_text = player_name
        if (player_name.length < 10) name_text += "_"

        jaws.context.fillText(name_text, 210, 275)
      }

      this.controls = function(menu,ok_submenu) {


        var shift = false

        jaws.on_keydown(["left_mouse_button"], function() {

          if (ok_submenu.mouse_inside) {
            ok_submenu.items[ok_submenu.index].action()
          }
        })

        jaws.on_keydown(["shift"], function () {
          shift = true
        })

        jaws.on_keyup(["shift"], function () {
          shift = false
        })

        jaws.on_keydown(["enter"],  function()  {
          if (player_name.length > 0)
            jaws.switchGameState(MainMenu)
        } )

        jaws.on_keydown(["backspace"], function() {
          player_name = player_name.substring(0,player_name.length-1)
          messageConsole()
        })

        jaws.on_keydown(["space"], function () {
          if (player_name.length < 10)
            player_name += " "
          messageConsole()
        })

        jaws.on_keydown(["a"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "A" : "a"
          messageConsole()
        })

        jaws.on_keydown(["b"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "B" : "b"
          messageConsole()
        })

        jaws.on_keydown(["c"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "C" : "c"
          messageConsole()
        })

        jaws.on_keydown(["d"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "D" : "d"
          messageConsole()
        })

        jaws.on_keydown(["e"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "E" : "e"
          messageConsole()
        })

        jaws.on_keydown(["f"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "F" : "f"
          messageConsole()
        })

        jaws.on_keydown(["g"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "G" : "g"
          messageConsole()
        })

        jaws.on_keydown(["h"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "H" : "h"
          messageConsole()
        })

        jaws.on_keydown(["i"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "I" : "i"
          messageConsole()
        })

        jaws.on_keydown(["j"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "J" : "j"
          messageConsole()
        })

        jaws.on_keydown(["k"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "K" : "k"
          messageConsole()
        })

        jaws.on_keydown(["l"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "L" : "l"
          messageConsole()
        })

        jaws.on_keydown(["m"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "M" : "m"
          messageConsole()
        })

        jaws.on_keydown(["n"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "N" : "n"
          messageConsole()
        })

        jaws.on_keydown(["o"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "O" : "o"
          messageConsole()
        })

        jaws.on_keydown(["p"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "P" : "p"
          messageConsole()
        })

        jaws.on_keydown(["q"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "Q" : "q"
          messageConsole()
        })

        jaws.on_keydown(["r"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "R" : "r"
          messageConsole()
        })

        jaws.on_keydown(["s"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "S" : "s"
          messageConsole()
        })

        jaws.on_keydown(["t"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "T" : "t"
          messageConsole()
        })

        jaws.on_keydown(["u"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "U" : "u"
          messageConsole()
        })

        jaws.on_keydown(["v"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "V" : "v"
          messageConsole()
        })

        jaws.on_keydown(["w"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "W" : "w"
          messageConsole()
        })

        jaws.on_keydown(["x"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "X" : "x"
          messageConsole()
        })

        jaws.on_keydown(["y"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "Y" : "y"
          messageConsole()
        })

        jaws.on_keydown(["z"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "Z" : "z"
          messageConsole()
        })

        jaws.on_keydown(["0"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? ")" : "0"
          messageConsole()
        })

        jaws.on_keydown(["1"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "!" : "1"
          messageConsole()
        })

        jaws.on_keydown(["2"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "@" : "2"
          messageConsole()
        })

        jaws.on_keydown(["3"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "#" : "3"
          messageConsole()
        })

        jaws.on_keydown(["4"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "$$" : "4"
          messageConsole()
        })

        jaws.on_keydown(["5"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "%" : "5"
          messageConsole()
        })

        jaws.on_keydown(["6"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "^" : "6"
          messageConsole()
        })

        jaws.on_keydown(["7"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "&" : "7"
          messageConsole()
        })

        jaws.on_keydown(["8"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "*" : "8"
          messageConsole()
        })

        jaws.on_keydown(["9"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "(" : "9"
          messageConsole()
        })
      }
    }

    jaws.onload = function() {
      console.log("Bugs: need to check if there's enough flasks for lose condition")
      jaws.unpack()
      var assets_array = ["./static/images/CURSOR.gif","./static/images/STAR.gif","./static/images/STAR_BORDER.gif","./static/images/STAR_SHADOW.gif","./static/images/LOCK.gif","./static/images/BLUE.gif","./static/images/GREEN.gif","./static/images/RED.gif","./static/images/YELLOW.gif","./static/images/PURPLE.gif","./static/images/WHITE.gif","./static/images/ORANGE.gif","./static/images/POTION_EMPTY.gif","./static/images/POTION_BLUE.gif","./static/images/POTION_GREEN.gif","./static/images/POTION_RED.gif","./static/images/POTION_YELLOW.gif","./static/images/POTION_PURPLE.gif","./static/images/POTION_WHITE.gif","./static/images/POTION_ORANGE.gif","./static/images/POTION_SPRITES.gif","./static/images/ROBOT_RED.gif","./static/images/ROBOT_WHITE.gif","./static/images/ROBOT_YELLOW.gif","./static/images/ROBOT_PURPLE.gif","./static/images/ROBOT_GREEN.gif","./static/images/ROBOT_BLUE.gif","./static/images/ROBOT_ORANGE.gif","./static/images/ROBOT_RED_DEATH.gif","./static/images/ROBOT_YELLOW_DEATH.gif","./static/images/ROBOT_PURPLE_DEATH.gif","./static/images/ROBOT_RED_SPLASH.gif","./static/images/ROBOT_BLUE_SPLASH.gif","./static/images/ROBOT_YELLOW_SPLASH.gif","./static/images/ROBOT_GREEN_SPLASH.gif","./static/images/ROBOT_PURPLE_SPLASH.gif","./static/images/ROBOT_ORANGE_SPLASH.gif","./static/images/POTION_SPLASH.gif","./static/images/BOARD.gif","./static/images/CHAIN.gif","./static/images/MENUBOX_SPRITES.gif","./static/images/ARROWS.gif"]

      // "./static/sfx/grab.wav","./static/sfx/drop.wav","./static/sfx/robot_death.wav","./static/sfx/brew.wav","./static/sfx/break.wav","./static/sfx/melt1.wav","./static/sfx/white3.wav"

      jaws.assets.add(assets_array)

      console.log("loading levels")
      loadLevels(function(data) {

        level_data = JSON.parse(data)
        console.log("level_data = ")
        console.dir(level_data)
        latest_edit = level_data.levels[0].length + 1
        player_progress[0][0] = latest_edit - 2
        console.log("player_progress = " + player_progress[0][0])
        console.dir(player_progress)

        if (name_entered)
          jaws.start(MainMenu)  // Our convenience function jaws.start() will load assets, call setup and loop update/draw in 60 FPS
        else
          jaws.start(PlayerNameState)
      })

    }

  </script>

</body>
</html>


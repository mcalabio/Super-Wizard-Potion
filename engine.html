$def with (name)

<html>
  <head>
    <script src="./static/jawsjs/jaws.js"></script>
    <script src="./static/jawsjs/audio.js"></script>
    <script src="./static/json/json.js"></script>
    <script src="./static/howler/howler.js"></script>
    <script src="./static/sjcl/sjcl.js"></script>
    <script type="text/javascript" src="./static/jquery/jquery-1.10.2.min.js"></script>
    <link type="text/css" rel="stylesheet" href="./static/style.css" />
    <title>Super Wizard Potion</title>
  </head>
<body>

  <a id="muteButton" href="#" onClick="toggleMute()" style="visibility:hidden;float:right">Sound: On</a>  
  <canvas id="gameScreen" width=600 height=500 style="position:fixed; top:10px; margin-top:10px"></canvas>
  <br>
  <div id="progressButtons" margin="100">
    <div id="saveData" hidden="true">Data to save comes from here.</div>
    <div id="openData" hidden="true">Data to save comes from here.</div>
  </div>
  <div id="live_info"></div>
  <div hidden="true">
    <canvas id="puzzleScreen" width=240 height=400></canvas>
  </div>

  <script>

    // CONSTANTS
    var SLOW = 10
    var FAST = 60
    var BOARD_WIDTH = 6
    var BOARD_HEIGHT = 10
    var ITEM_WIDTH = 40
    var PURPLE_HEX = '#350028'//'#700054'
    var MAX_RAISE_LEVEL_TIME = 20
    var MIN_RAISE_LEVEL_TIME = 20
    var FREQ_RAISE_LEVEL_TIME = 20  // decrease raise_level_time every 20 seconds
    var MARATHON_STAR_LOCK = 0
    var ZERO_STAR_LOCK = 0
    var MENU_FONT = "bold 12pt Menu Text"
    var ROB_SCORE = 2
    var WINLOSE_DELAY = 60
    var DEATH_COUNTER_START = 40


    var COLORS = new Array("RED","GREEN","PURPLE","BLUE","YELLOW","ORANGE","EMPTY","WHITE","UNSTABLE")
    var TYPES = new Array("BLOCK","POTION","ROBOT","CAULDRON")
    var RED = 0
    var GREEN = 1
    var PURPLE = 2
    var BLUE = 3
    var GOLD = 4
    var UNSTABLE = COLORS.length - 1
    var WHITE = COLORS.length - 2
    var EMPTY = COLORS.length - 3

    var COLOR = {
      RED : 0,
      GREEN : 1,
      PURPLE : 2,
      BLUE : 3,
      YELLOW : 4,
      ORANGE : 5,
      EMPTY : 6,
      WHITE : 7
    }

    // LEVEL BRANCHING
    var LEVEL_PATHS = [

      [1,2,3,4,6],
      [1,2,3,4,7],
      [1,2,3,5,7],
      [1,2,3,5,8]

    ]

    var thanks_for_coming = "Thanks for playing! Stay tuned for more puzzles! If you have friends that you think might also be interested in play-testing, please direct them to us."

    // PROBABILITIES FOR
    // GENERATING RANDOM ITEMS IN MARATHON
    var ITEM_PROBS = {

    // BLOCKS
      "0|0" : [4,7,10,7,10,7,10,10,10,10,10,10,10,8] , // RED
      "0|1" : [0,7,10,7,10,7,10,04,04,10,10,10,10,8] , // GREEN
      "0|2" : [0,0,00,0,00,7,10,04,04,04,04,10,10,8]  , // PURPLE
      "0|4" : [0,0,00,0,00,0,00,10,10,10,10,10,10,6]  , // YELLOW
      "0|7" : [0,0,00,7,10,7,10,10,10,10,10,10,10,16] , // WHITE

    // POTIONS               //  //  //
      "1|0" : [0,1,1,1,1,1,1,0,1,1,1,1,1,1] , // RED
      "1|1" : [0,1,1,1,1,1,1,0,0,0,1,1,1,1] , // GREEN
      "1|2" : [0,0,0,0,0,1,1,0,0,0,0,0,1,1] , // PURPLE
      "1|4" : [0,0,0,0,0,0,0,2,2,2,2,2,2,1] , // YELLOW
      "1|6" : [0,0,0,2,4,3,4,4,4,4,4,4,4,3] , // EMPTY
      "1|7" : [1,3,3,1,1,2,2,2,3,4,4,5,5,3] , // WHITE

    // ROBOTS                //  //  //
      "2|0" : [4,6,6,6,6,6,6,0,4,3,3,3,3,6] , // RED
      "2|1" : [0,6,6,6,6,6,6,0,0,0,3,3,3,6] , // GREEN
      "2|2" : [0,0,0,0,0,6,6,0,0,0,0,0,3,6] , // PURPLE
      "2|3" : [0,0,0,0,0,0,0,6,6,6,6,6,6,1] , // RED ARMOR
      "2|4" : [0,0,0,0,0,0,0,0,0,6,6,6,6,1] , // GREEN ARMOR
      "2|5" : [0,0,0,0,0,0,0,0,0,0,0,6,6,1] , // PURPLE ARMOR
    }

    var raise_count_level = [1,8,8,8,6,5,5,5,5,5,5,5]

    // GLOBALS
    var X_SPEED = SLOW
    var Y_SPEED = FAST
    var name_entered = false
    var player_name = ""
    var player_uid = ""
    var level_data
    var player_level = 1
    var player_stage = 1
    var player_path = 0
    var player_progress = []
    var star_progress = []
    var marathon_progress = ["00:00",0]
    var control_scheme = 1
    var game_mode = 1
    var game_record = ""
    var level_edit = false
    var level_edit_play = false
    var puzzle_mode_active = true
    var level_editor_active = true
    var change_name_active = true
    var replay_mode_active = true
    var marathon = false
    var marathon_debug = false
    var marathon_level_debug = 1
    var marathon_level = marathon_level_debug
    var sprint = false
    var replay = null
    var replay_actions = 0
    var replay_index = -1
    var latest_edit
    var pause = false
    var main_menu_auto = undefined
    var mute = true
    var sound_effects = new Array()
    var paused_sound_effects = new Array()
    var playing_sound_effects = new Array()
    // player sound effects
    var grab_sound
    var drop_sound
    var break_audio
    var brew_audio
    var splash_audio
    var melt_audio
    var white_audio
    // setupSounds()

    var cookie_save = getCookie("player_save")
    var replay_records = []

    // json object storing line game puzzles in story mode
    var cauldron_ticker = 0
    var sprints //= {"1-6":{"blk_red":4,"pot_red":1,"rob_red":4,"height":5,"depth":1,"max_raise":20,"min_raise":20,"freq_raise":20}}

    function Game() {
      var player
      var star_sprites = new Array()
      var viewport
      var need_to_restart = false
      var game_end = ""
      var game_start = false
      var level_editor
      var pause_menu
      var winlose_data
      var winlose_menu
      var winlose_delay = WINLOSE_DELAY
      var score_sheet_data
      var replay_menu
      var continue_lock_box
      var level_record
      var level_edit_menu
      var level_select_menu
      var level_select_ok
      var winlose = false
      var raise_level_time = MAX_RAISE_LEVEL_TIME
      var raise_count = 0
      var continue_menu_item
      var undo_menu_item
      var back_menu_item
      var restart_menu_item = new MenuItem(pause_menu,"Restart",function() {
        // update marathon progress
        if (marathon) {
          if (player.timer.clock_text > marathon_progress[0])
            marathon_progress[0] = player.timer.clock_text
          if (player.score > marathon_progress[1])
            marathon_progress[1] = player.score
          // update player_save data and cookie data
          updateSaveAndCookie()
        }
        if (!level_edit) {
          var record = buildRecordString(player.board,"R")
          saveRecord(record)
          game_end = "R"
        }
        jaws.start(Game)
      })

      var save_menu_item = new MenuItem(pause_menu,"Save Level",function() {
        saveLevel(player_level,player_stage,player.board,star_time,star_score,star_lock,level_name,function() {
          loadLevels(function(data) {
            level_data = JSON.parse(data)
            latest_edit = level_data.levels[0].length + 1
            player_progress[0][0] = latest_edit - 2
          })
        })
      })

      var randomization_array = new Array()
      var sprint_randomization = new Array()

      var player_data
      var screen_data
      var puzzle_data
      var marathon_data
      var star_time
      var star_score
      var star_lock
      var level_name = (level_data.levels[player_level][player_stage-1]==undefined)?
        "new" :
        (level_data.levels[player_level][player_stage-1].split('\n')[9]==undefined)?
          (player_level.toString() + "-" + player_stage.toString()) :
          level_data.levels[player_level][player_stage-1].split('\n')[9]
      var beat_marathon_time = false
      var beat_marathon_score = false
      var drew_puzzle_screen = false

      // undo states
      var player_undid = false
      var undo_hand = new Array()
      var undo_board = new Array()

      // hide progress buttons
      var progress_buttons = $("progressButtons")
      progress_buttons.hidden = true

      var replay_length = 0

      marathon_level = marathon_level_debug

      // line game
      var sprint_data = (sprints != undefined) ? sprints[level_name] : undefined
      if (sprint_data != undefined)
        sprint = true
      else
        sprint = false

      /*  Called once when a game state is activated. Use it for one-time setup code. */
      this.setup = function() {
        // live_info = document.getElementById("live_info")
        live_info = $("live_info")

        viewport = new jaws.Viewport({max_x: 600, max_y: 500})

        console.dir("jaws.context = " + jaws.context.strokeRect)

        // initialize player
        player = new Player(3,0)


        // setup player data in a menu box
        player_data = new MenuBox(
          (replay == null) ? player_name : replay_records[replay_index]["name"], // title
          screen_data,
          player.board.board.x + player.board.board.width + ITEM_WIDTH,
          player.board.board.y,
          160,
          [new MenuItem(screen_data,"  x " + player.stars,function(){return})]
        )
        player_data.index = -1
        var player_stars_sprite = new jaws.Sprite({x:player_data.x+20,y:player_data.y+36,image:"./static/images/STAR.gif",anchor:"left"})   
        player_stars_sprite.width = 15
        player_stars_sprite.height = 15
        star_sprites.push(player_stars_sprite) 
        console.log("starsprite")
        console.dir(player_stars_sprite)       

        // setup screen data in a menu box
        var screen_data_items = new Array()
        screen_data_items.push(new MenuItem(screen_data,
          (marathon) ?
            ("Marathon") :
            ((level_name==undefined || level_name=="") ?
              ("player_level + "-" + player_stage") :
              level_name
            ),function(){return}
            ))
        if (!level_edit) {

          // display level and stage number
          screen_data_items[0].text = (!marathon)?(player_level + "-" + player_stage):(marathon_level)

          // display timer and score
          screen_data_items.push(new MenuItem(screen_data,player.timer.clock_text,function(){return}))
          screen_data_items.push(new MenuItem(screen_data,'\u03BB'+player.score,function(){return}))
        }
        screen_data = new MenuBox(
          "Level",
          screen_data,
          (level_edit) ? player_data.x + player_data.width + 1 : player.board.board.x + player.board.board.width + ITEM_WIDTH,
          (level_edit) ? player_data.y : player_data.y + player_data.height + 1,
          125,
          screen_data_items
        )

        screen_data.index = -1

        console.log("creating box for screen data")

        // Player Controls
        player.controls()

        // fill up the level with items
        // and setup screen data for marathon
        if (marathon) {
          console.log("MARATHON")
          raise_level_time = MAX_RAISE_LEVEL_TIME
          player.board.marathonLevel(5)

          var marathon_data_items = new Array()
          marathon_data_items.push(new MenuItem(marathon_data,"Best Time:  " + marathon_progress[0],function(){return}))
          marathon_data_items.push(new MenuItem(marathon_data,"High Score: \u03BB" + marathon_progress[1],function(){return}))

          marathon_data = new MenuBox("",marathon_data,screen_data.x,screen_data.y + screen_data.height + 1,150 + ITEM_WIDTH*2,marathon_data_items)
          marathon_data.index = -1

          // start timer immediately
          game_start = true

          // marathon_star_lock_menu.menu_box.setup(main_menu.x + main_menu.width/2 + ITEM_WIDTH*2, main_menu.y + 20,level_select_ok.menu_box.width)

        } else if (sprint) {
          raise_level_time = sprint_data.game["max_raise"]
          player.board.sprintLevel(sprint_data)

          if (level_data.levels[player_level][player_stage-1] != undefined || level_edit) {
            if (player_progress[player_level][1][player_stage.toString()] != undefined || level_edit) {
              var puzzle_data_items = new Array()
              puzzle_data_items.push(new MenuItem(puzzle_data,"Star Time:  " + star_time,function(){
                  var result = window.prompt("enter star time",(star_time==undefined)?"MM:SS":star_time)
                  if (result != null) star_time = result
                  puzzle_data_items[0].text = "Star Time:  " + star_time
              }))
              puzzle_data_items.push(new MenuItem(puzzle_data,"Star Score: \u03BB" + star_score,function(){
                  var result = window.prompt("enter star score",(star_score)==undefined?"":star_score)
                  if (result != null) star_score = result
                  puzzle_data_items[1].text = "Star Score: \u03BB" + star_score
              }))
              if (level_edit) puzzle_data_items.push(new MenuItem(puzzle_data,"Star Lock:  " + star_lock,function(){
                  var result = window.prompt("enter star lock",(star_lock)==undefined?"":star_lock)
                  if (result != null) star_lock = result
                  puzzle_data_items[2].text = "Star Lock:  " + star_lock
              }))
              puzzle_data = new MenuBox("",puzzle_data,(level_edit)?screen_data.x - 2*ITEM_WIDTH:screen_data.x,screen_data.y + screen_data.height + 1,150 + ITEM_WIDTH*2,puzzle_data_items)
              puzzle_data.index = -1
              puzzle_data.active = (level_edit) ? true : false
            }
          }

          game_start = true
        } else {
          console.dir(level_data)
          if (level_data.levels[player_level][player_stage-1] != undefined || level_edit) {
            if (!level_edit)
              player.board.fillLevel(LEVEL_PATHS[player_path][player_level-1],player_stage)
            else
              player.board.fillLevel(player_level,player_stage)
            addStateForUndo(player.hand,player.board)
            if (player_progress[player_level][1][player_stage.toString()] != undefined || level_edit) {
              var puzzle_data_items = new Array()
              puzzle_data_items.push(new MenuItem(puzzle_data,"Star Time:  " + star_time,function(){
                  var result = window.prompt("enter star time",(star_time==undefined)?"MM:SS":star_time)
                  if (result != null) star_time = result
                  puzzle_data_items[0].text = "Star Time:  " + star_time
              }))
              puzzle_data_items.push(new MenuItem(puzzle_data,"Star Score: \u03BB" + star_score,function(){
                  var result = window.prompt("enter star score",(star_score)==undefined?"":star_score)
                  if (result != null) star_score = result
                  puzzle_data_items[1].text = "Star Score: \u03BB" + star_score
              }))
              if (level_edit) puzzle_data_items.push(new MenuItem(puzzle_data,"Star Lock:  " + star_lock,function(){
                  var result = window.prompt("enter star lock",(star_lock)==undefined?"":star_lock)
                  if (result != null) star_lock = result
                  puzzle_data_items[2].text = "Star Lock:  " + star_lock
              }))
              puzzle_data = new MenuBox("",puzzle_data,(level_edit)?screen_data.x - 2*ITEM_WIDTH:screen_data.x,screen_data.y + screen_data.height + 1,150 + ITEM_WIDTH*2,puzzle_data_items)
              puzzle_data.index = -1
              puzzle_data.active = (level_edit) ? true : false
            }
          }
        }

        // pause menu
        pause = false

        var menu_x = player.board.board.x + player.board.board.width/2 - (4*ITEM_WIDTH+15)/2
        var menu_y = player.board.board.y + player.board.board.height/2 - 3*ITEM_WIDTH

        var pause_menu_items = new Array()
        if (level_edit &&!level_edit_play) {
          pause_menu_items.push(new MenuItem(pause_menu,"Play Level",function() {
            pause = false
            level_edit_play = true
            jaws.start(Game)
            // playPausedSounds()
          }))
        } else {
          pause_menu_items.push(new MenuItem(pause_menu,"Resume",function() {
            pause = false
            // playPausedSounds()
            player.controls()
          }))
        }
        pause_menu_items.push(((level_edit) ? save_menu_item : restart_menu_item))
        pause_menu_items.push(new MenuItem(pause_menu,"Back to Menu",function() {
          if (level_edit)
            main_menu_auto = [3,player_level,player_stage]
          else if (marathon)
            main_menu_auto = [1,0,0]
          else if (replay != null)
            main_menu_auto = [6,0,0]
          else
            main_menu_auto = [0,player_level,player_stage]
          jaws.start(MainMenu)
        }))

        this.pause_back = function() {
          pause = false
          player.controls()
        }

        pause_menu = new MenuBox("Pause!",pause_menu,menu_x, menu_y,4*ITEM_WIDTH+15,pause_menu_items)
        pause_menu.back = this.pause_back

        // winlose data
        var winlose_data_items = new Array()
        winlose_data_items.push(new MenuItem(winlose_data_items,"YOU WIN!",function() {return}))
        winlose_data_items.push(new MenuItem(winlose_data_items,"Time:",function() {return}))
        winlose_data_items.push(new MenuItem(winlose_data_items,"Score:",function() {return}))
        winlose_data_items.push(new MenuItem(winlose_data_items,"",function() {return}))

        winlose_data = new MenuBox("",winlose_data,menu_x, menu_y, 4*ITEM_WIDTH+15, winlose_data_items)

        // score sheet data
        if (marathon) {
          score_sheet_data = new MenuBox("",score_sheet_data,menu_x,menu_y, 5*ITEM_WIDTH+15, [])
        }

        // add star sprites for winlose data
        for (var s=0; s < winlose_data_items.length; s++) {
          var this_sprite = new jaws.Sprite({x:winlose_data.x,y:winlose_data.y+36 + 20*(s-1),anchor:"left"})
          this_sprite.width = 15
          this_sprite.height = 15
          winlose_data_items[s].sprites.push(this_sprite)

          console.log("winlose sprite, s = " + s)
          console.dir(winlose_data_items[s].sprites[0])
        }

        // winlose menu
        continue_menu_item = new MenuItem(winlose_menu,"Continue",function() {

          // advance the player to the next level
          console.log("player_stage = " + player_stage)
          console.dir(level_data)
          if (player_stage < level_data["levels"][player_level].length) {
            player_stage++
          } else {
            player_level++
            player_stage = 1
          }
          console.log("player_stage = " + player_stage)

          // reset board
          jaws.start(Game)
        })
        continue_menu_item.active = false
        undo_menu_item = new MenuItem(winlose_menu,"Undo (CTRL+Z)",function() {
          winlose = false
          winlose_menu.active = false

          winlose_menu.y = winlose_data.y + winlose_data.height
          winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

          // color timer to be red to indicate game end
          screen_data.index = -1
          game_end = ""
          player.controls()
          undoLastMove(true)
        })
        back_menu_item = new MenuItem(winlose_menu,"Back to Menu",function() {
          if (level_edit)
            main_menu_auto = [3,player_level,player_stage]
          else if (marathon)
            main_menu_auto = [1,0,0]
          else if (replay != null)
            main_menu_auto = [6,0,0]
          else
            main_menu_auto = [0,player_level,player_stage]
          jaws.start(MainMenu)
        })
        winlose_menu = new MenuBox(" ",winlose_menu,menu_x, winlose_data.y + winlose_data.height,4*ITEM_WIDTH+15,[])

        // to display star lock to continue to next world
        continue_lock_box = new OkSubMenu("",winlose_menu,function() { return })
        continue_lock_box.menu_box.setup(winlose_menu.x + winlose_menu.width - 50, winlose_menu.y+40,continue_lock_box.menu_box.width)
        continue_lock_box.menu_box.index = -1

        // lock sprite
        var lock_sprite = new jaws.Sprite({x:continue_lock_box.menu_box.x+21,y:continue_lock_box.menu_box.y,image:"./static/images/LOCK.gif",anchor:"left"})        
        continue_lock_box.menu_box.sprites.push(lock_sprite)
        lock_sprite.active = true

        // star lock sprite
        var star_lock_sprite = new jaws.Sprite({x:continue_lock_box.menu_box.x+64,y:continue_lock_box.menu_box.y+17,image:"./static/images/STAR.gif",anchor:"left"})        
        star_lock_sprite.width = 15
        star_lock_sprite.height = 15
        continue_lock_box.menu_box.sprites.push(star_lock_sprite)
        star_lock_sprite.active = true        

        // level record data
        var level_record_items = new Array()
        level_record_items.push(new MenuItem(level_record,"Completed!",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Time:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Score:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"",function() {return}))

        level_record = new MenuBox("",level_record,winlose_menu.x + winlose_menu.width - 50, winlose_menu.y+40, 230, level_record_items)
        level_record.index = -1
        level_record.active = false

        // add star sprites for level record data
        for (var s=0; s < level_record_items.length; s++) {
          var this_sprite = new jaws.Sprite({x:level_record.x,y:level_record.y+36 + 20*(s-1),anchor:"left",image:"./static/images/STAR.gif"})
          this_sprite.width = 15
          this_sprite.height = 15
          this_sprite.active = false
          level_record.sprites.push(this_sprite)

        }


        // level editor
        if (level_edit) {
          level_editor = new LevelEditor(player.board)

          // level edit menu
          var level_edit_menu_items = new Array()
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"New",function() {
            player.level_new()
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Open",function() {
            player.level_open()
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Save",function() {
            if (player_level > 0)
              return
            player.level_save()
          }))
          level_edit_menu_items[level_edit_menu_items.length-1].locked = (player_level > 0) ? true : false
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Save As",function() {
            player.level_save_as()
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Publish",function() {
            console.log("Publish")
            if (player_level > 0)
              player.level_save()
            else
              player.level_publish()
          }))          
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Delete",function() {
            player.level_delete()
          }))
          level_edit_menu_items.push(new MenuItem(level_edit_menu,"Quit",function() {
            console.log("Quit")
            jaws.start(MainMenu)
          }))

          level_edit_menu = new MenuBox("",level_edit_menu,level_editor.board.x + level_editor.board.width + 10, puzzle_data.y + puzzle_data.height + 1,3*ITEM_WIDTH,level_edit_menu_items)

          level_edit_menu.active = true

          var level_select_string = player_level + "-" + player_stage

          // level select menu
          level_select_menu = new MenuBox("Level",level_edit_menu,level_edit_menu.x, level_edit_menu.y + level_edit_menu.height + 1, level_edit_menu.width, [],true)
          level_select_menu.back = function() {
            level_select_menu.active = false
            level_select_ok.menu_box.active = false
            player.controls()
          }

          // add level menu items
          console.log("ADDING LEVEL MENU ITEMS")
          var item_count = 0
          for (var i = 0; i < level_data.levels.length; i++) {
            for (var j = 0; j < level_data.levels[i].length; j++) {
              if (i == 1 && j+1 == 1)
                level_select_menu.index = item_count
              console.log("i = " + i + ", j = " + j)
              var this_level = new MenuItem(level_select_menu,(i + "-" + (j+1)),function() {
                  player_level = this.level
                  player_stage = this.stage
                  replay = null
                  level_edit_play = false
                  jaws.start(Game)
              })

              var data = level_data.levels[i][j].split('\n')
              this_level.text = (data[9]!=undefined)?data[9]:(i+"-"+(j+1).toString())
              this_level.level = i
              this_level.stage = j+1
              level_select_menu.items.push(this_level)
              console.dir(this_level)
              item_count++
            }
          }

          console.log("level_select_menu")
          console.dir(level_select_menu)

          // level select arrows
          level_select_menu.arrow_sprites = new jaws.SpriteSheet({
            image: "./static/images/ARROWS.gif", frame_size: [20,10]})

          level_select_menu.up_arrow = new jaws.Sprite({x:level_select_menu.x + 85, y:level_select_menu.y + 20, image: level_select_menu.arrow_sprites.frames[0]})
          level_select_menu.down_arrow = new jaws.Sprite({x:level_select_menu.x + 85, y:level_select_menu.y + 38, image: level_select_menu.arrow_sprites.frames[1]})

          level_select_menu.up_arrow.height = 15
          level_select_menu.down_arrow.height = 15

          level_select_menu.up_arrow.mouse_over = false
          level_select_menu.down_arrow.mouse_over  = false

          level_select_menu.up_arrow.active = true
          level_select_menu.down_arrow.active = true

          level_select_menu.sprites.push(level_select_menu.up_arrow)
          level_select_menu.sprites.push(level_select_menu.down_arrow)


          level_select_menu.controls = function(menu,ok_submenu) {

            menu.up_action = function() {

              console.log("up_action")

              if (level_select_menu.index < level_select_menu.items.length-1)
                level_select_menu.index++

            }

            menu.down_action = function() {

              console.log("up_action")

              if (level_select_menu.index > 0)
                level_select_menu.index--

            }

            jaws.on_keydown(["up","w"], function() {

              menu.up_action()

            })

            jaws.on_keydown(["down","s"], function() {

              menu.down_action()

            })

            jaws.on_keydown(["enter","space"], function() {
              console.log("performing action")
              menu.items[menu.index].action(jaws)
            })

            jaws.on_keydown(["esc"], function() {
              console.log("MENU BACK")
              menu.back()
            })

            jaws.on_keydown(["left_mouse_button"], function() {
              console.log("click button")
              if (menu.sprites[0].mouse_over) {
                menu.up_action()
                console.log("up button")
              }
              else if (menu.sprites[1].mouse_over) {
                console.log("click on down arrow")
                menu.down_action()
              }
              else if (ok_submenu.menu_box.mouse_inside) {
                console.log("ok!")
                player_level = menu.level
                player_stage = menu.stage
                menu.items[menu.index].action()
              }
              else if (menu.mouse_inside)
                return
              else {
                console.log("elsing")
                menu.active = false
                ok_submenu.menu_box.active = false
                player.controls()
              }
            })

          }

          level_select_ok = new OkSubMenu("",level_select_menu,function() {
            level_select_menu.items[menu.index].action(jaws)
          })

        }

        // replay mode
        if (replay != null) {


          var key = 0;
          for(key in replay) {
            if(replay.hasOwnProperty(key)) {
              replay_length++;
            }
          }

          replay_actions = 0
          
          replay_menu = new MenuBox("Replay",replay_menu,menu_x, winlose_data.y + winlose_data.height,4*ITEM_WIDTH+15,[],true)

          console.log("replay_records = ")
          console.dir(replay_records)
          
          // construct replay mode menu
          for (var i =0; i < replay_records.length; i++) {
            var this_replay = replay_records[i]
            var this_item = new MenuItem(replay_menu,this_replay["name"] + ":" + this_replay["puzzle"],function() {
              var level_name = replay_records[this.index]["puzzle"].split("-")
              
              // marathon mode
              if (level_name[0] == "MRTHN") {
                player_level = 1
                player_stage = 1
                marathon = true

              // puzzle mode
              } else {
                player_level = level_name[0]
                player_stage = level_name[1]
                marathon = false
              }

              replay = replay_records[this.index]["replay"]
              replay_index = this.index
              jaws.start(Game)

            })
            this_item.index = i
            console.log("adding item to relpay menu")
            replay_menu.items.push(this_item)
          }          
        }

        console.log("setup game")
        console.log("player_name = " + player_name)
        console.log("live_info = " + live_info)

        jaws.context.mozImageSmoothingEnabled = false;  // non-blurry, blocky retro scaling
        jaws.preventDefaultKeys(["w", "s", "a", "d", "k"])

      }

      /* update() will get called each game tick with your specified FPS. Put game logic here. */
      this.update = function() {

        if (need_to_restart)
          jaws.start(Game)

        if (game_end == "W" || game_end == "L") {
          if (winlose_delay > 0) {
            winlose_delay--
          } else if (winlose_delay == 0) {
            if (replay == null)
              winlose_menu.controls(winlose_menu)
            winlose_delay--
          }
          if (!winlose)
            player.board.winLose()
        }

        if (pause) {
          // console.log(pause_menu)
          pause_menu.controls(pause_menu)
        }

        player.update()

        if (marathon) {
          if (!beat_marathon_time) {
            if (player.timer.clock_text > marathon_progress[0]) {
              beat_marathon_time = true
              marathon_data.items[0].color = "Grey"
            }
          }
          // check if player beat marathon high score
          if (!beat_marathon_score) {
            if (player.score > marathon_progress[1]) {
              beat_marathon_score = true
              marathon_data.items[1].color = "Grey"
            }
          }
        }

        if(level_edit) {
          level_editor.update()
          if(!puzzle_data.mouse_inside)
            puzzle_data.index = -1
          if(!level_edit_menu.mouse_inside)
            level_edit_menu.index = -1
          if(level_select_menu.active)
            level_select_menu.update()
          if(level_select_ok.menu_box.active)
            level_select_ok.update()
        }

        if (winlose_menu.active && game_end == "W" && !level_edit) {
          if (player_progress[player_level][0] >= level_data.levels[player_level].length){
            if (winlose_menu.index > 0 && winlose_menu.index <= level_data.levels[player_level].length) {
              level_record.active = true
              continue_lock_box.active = false
              var level_item = winlose_menu.items[winlose_menu.index]
              var level_name = level_item.text.split("-")
              var level = parseInt(level_name[0])
              var stage = level_name[1]
              if (player_progress[level] != undefined && player_progress[level][1][stage] != undefined) {
                level_record.items[1].text = "Best Time:  " + player_progress[level][1][stage][0]
                level_record.items[2].text = "High Score: \u03BB" + player_progress[level][1][stage][1]
                
                // show appropriate stars
                level_record.sprites[0].active = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? true : false
                level_record.sprites[1].active = (star_progress[level][stage] != undefined && star_progress[level][stage][1] > 0) ? true : false
                level_record.sprites[2].active = (star_progress[level][stage] != undefined && star_progress[level][stage][2] > 0) ? true : false
                level_record.sprites[3].active = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? true : false
                level_record.items[0].text = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? "Completed!" : "Completed (undo)"
                level_record.items[3].text = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? "Perfect" : ""
              }
            } else if (winlose_menu.index == 0) {
              level_record.active = false
              if (winlose_menu.items[0].active && winlose_menu.items[0].locked) {
                continue_lock_box.active = true
                var next_level = (level_data.levels[parseInt(player_level) + 1] != undefined) ? level_data.levels[parseInt(player_level) + 1][0] : undefined
                var next_star_lock = (next_level != undefined) ? next_level.split('\n')[8] : undefined   
                continue_lock_box.menu_box.items[0].text = "      x " + ((next_star_lock == undefined) ? "?" : next_star_lock)

              }
            } else {
              level_record.active = false
              continue_lock_box.active = false
            }
          }
        }

        live_info.innerHTML = jaws.game_loop.fps + " fps. Player: " + parseInt(player.x) + "/" + parseInt(player.y) + ". "
        live_info.innerHTML += "Viewport: " + parseInt(viewport.x) + "/" + parseInt(viewport.y) + "."

      }

      /* Directly after each update draw() will be called. Put all your on-screen operations here. */
      this.draw = function() {
        jaws.clear()

        // background
        jaws.context.fillStyle = 'Black' //PURPLE_HEX
        jaws.context.fillRect(0,0,600,500)

        // the viewport magic. wrap all draw()-calls inside viewport.apply and it will draw those relative to the viewport.
        viewport.apply( function() {
          player.draw()
          player_data.draw()
          screen_data.draw()
          if(level_edit) {
            level_editor.draw()
            level_edit_menu.draw()
            if (level_select_menu.active)
              level_select_menu.draw()
            if (level_select_ok.menu_box.active)
              level_select_ok.draw()
          }
          if (marathon)
            marathon_data.draw()
          else (!level_edit)
            if (puzzle_data != undefined) puzzle_data.draw()
          for (var s=0; s < star_sprites.length; s++) {
            star_sprites[s].draw()
          }
        });

        // display board on puzzleScreen
        if (!drew_puzzle_screen && level_edit) {
          var gamescreen_canvas = $("gameScreen")
          var puzzleScreen_canvas = $("puzzleScreen")
          puzzleScreen.getContext("2d").drawImage(gamescreen_canvas,40,40,240,400,0,0,240,400)

          // save as jpg
          var data_url = puzzleScreen_canvas.toDataURL( "image/png" , 1 )

          // window.prompt("encoded data",data_url.substring(data_url.indexOf(",")+1,data_url.length))

          saveImage(player_level,player_stage,level_name,data_url.substring(data_url.indexOf(",")+1,data_url.length))

          // window.open(data_url, '_blank')

          drew_puzzle_screen = true          
        }

        if (continue_lock_box.active)
          continue_lock_box.draw()

        if (level_record.active && winlose_delay <= 0)
          level_record.draw()

      }

      /* Constructor for Player */
      function Player(x,y) {

        // player consists of a board and hand
        // board consists of six stacks, hand is a stack
        // stack consists of items
        // an item has type and color

        this.x = x
        this.y = y
        this.board = new Board(this)
        this.hand = new Stack(this.board, -1) // passing in Player board
        this.cursor_speed = X_SPEED
        this.score = 0
        this.control_scheme = 0
        this.keyboard_actions = 0
        this.mouse_actions = 0
        this.stars = starTotal()
        this.new_stars = 0 // new stars player acquired for this

        this.sprite_sheet = new jaws.SpriteSheet({
          image: "./static/images/CURSOR.gif", frame_size: [40,20]})

        this.cursor_top = new jaws.Sprite({x:this.board.posx(x), y:this.board.posy(y), image: this.sprite_sheet.frames[0]})
        this.cursor_bottom = new jaws.Sprite({x:this.board.posx(x), y:(this.board.posy(y)+20), image: this.sprite_sheet.frames[1]})
        this.wizard = new jaws.Sprite({x:this.board.board.x + this.board.board.width + ITEM_WIDTH ,
                                        y:this.board.board.y + this.board.board.height / 2,
                                          anchor:"left"})
        var anim = new jaws.Animation({sprite_sheet: "./static/images/WIZARD.gif", frame_size: [104,128], frame_duration: 100})
        this.wizard.anim_default = anim.slice(0,3)
        this.wizard.setImage(this.wizard.anim_default.next())


        // player timer
        this.timer = new Timer(this)

        // count player actions
        this.moves = 0

        // record player actions
        this.replay_data = {"stack_queue":[[],[],[],[],[],[]]}        

        // record player score
        this.score_sheet = {"blocks":0,"potions":0,"robots":0,

          "combos":{},  // key for each combo c
          "chains":{},  // key for each chain c
          "power_ups":{}

        }

        this.addScore = function(type,combo,chain) {

          // add to player's score
          points = Math.pow( (type==0)?combo:RobotCombo(combo),chain )
          this.score += points

          // update screen data
          if (!level_edit)
            screen_data.items[2].text = '\u03BB' + this.score
          else
            console.log("SCORE = " + this.score)

          // update player's score sheet
          if (combo > 0) {
            if (this.score_sheet.combos[combo.toString()] == undefined) {
              this.score_sheet.combos[combo.toString()] = 1
            } else
              this.score_sheet.combos[combo.toString()] += 1
          }
          if (chain > 0) {
            if (this.score_sheet.chains[chain.toString()] == undefined) {
              this.score_sheet.chains[chain.toString()] = 1
            } else
              this.score_sheet.chains[chain.toString()] += 1
          }

          console.log("updating score sheet!")
          console.dir(this.score_sheet)

        }

        // player controls
        this.controls = function() {

          jaws.on_keydown(["enter","esc","p"], function() {

            if (game_end == "")
              pauseGame(pause_menu,player,restart_menu_item,save_menu_item)

          })

          jaws.on_keydown(["l"], function() {
            if ((marathon || sprint) && !player.board.stacksBreaking() && !player.board.stacksFull()) {
              player.board.raiseStacks()
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"raise",0]
            }
          })

          jaws.on_keydown(["n"], function() {
            if (level_edit && ctrl) {
              player.level_new()
            }
          })

          jaws.on_keydown(["o"], function() {
            if (level_edit && ctrl) {
              player.level_open()
            }
          })

          jaws.on_keydown(["left","a"], function() {
            if (pause || game_end != "") return
            X_SPEED = SLOW
            player.control_scheme = 0
            if(player.x > 0) {
              if (player.canMoveX(-1)) {
                // record this action
                player.replay_data[player.timer.frame_ticker.toString()]
                  = [player.x,player.y,"move_x",-1]   
                player.moveX(-1)
              } else {
                // drop minimum amount of items on hand so hand can move left
                var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x - 1].items.length)
                if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x - 1].items.length > 0) {
                  // record this action
                  player.replay_data[player.timer.frame_ticker.toString()]
                    = [player.x-1,player.y,"drop",drop_amount]                    
                  player.drop(player.board.stacks[player.x],drop_amount)
                  player.moveX(-1)
                }
              }
            }
            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["right","d"], function() {
            if (pause || game_end != "") return
            X_SPEED = SLOW
            player.control_scheme = 0
            if(player.x < BOARD_WIDTH - 1) {
              if (player.canMoveX(1)) {
                // record this action
                player.replay_data[player.timer.frame_ticker.toString()]
                  = [player.x,player.y,"move_x",1]   
                player.moveX(1)
              } else {
                // drop minimum amount of items on hand so hand can move right
                var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x + 1].items.length)
                if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x + 1].items.length > 0) {
                  // record this action
                  player.replay_data[player.timer.frame_ticker.toString()]
                    = [player.x+1,player.y,"drop",drop_amount]                    
                  player.drop(player.board.stacks[player.x],drop_amount)
                  player.moveX(1)
                }

              }
            }
            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["up","w"], function() {
            if (pause || game_end != "") return
            player.control_scheme = 0
            if(player.y < BOARD_HEIGHT-1) {
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"move_y",1]
              player.y += 1
            }
            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["down","s"], function() {

            if (pause || game_end != "") return

            if (level_edit) {
              if (ctrl && shift) {
                player.level_save_as()
                return
              } else if (ctrl) {
                player.level_save()
                return
              }

            }

            player.control_scheme = 0
            if(player.hand.items.length>0) {
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"drop",player.hand.items.length]   
              player.drop(player.board.stacks[player.x],player.hand.items.length)
            } else if(player.y > 0) {
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"move_y",-1]
              player.y -= 1
            }


            console.log("player (" + player.x + " , " + player.y + ")")
          })
          jaws.on_keydown(["k","c"], function() {
            if (pause || game_end != "") return
            if(player.hand.items.length == 0) {
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"grab",player.board.stacks[player.x].items.length]
              player.grab(player.board.stacks[player.x],player.board.stacks[player.x].items.length)
            } else {
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"drop",player.hand.items.length]   
              player.drop(player.board.stacks[player.x],player.hand.items.length)
            }
            player.control_scheme = 0
            player.keyboard_actions++
          })
          jaws.on_keydown(["x","j","space"], function() {
            if (pause || game_end != "") return
            if(player.hand.items.length == 0) {
              //grab depth determined by cursor y-position
              var depth = player.board.stacks[player.x].items.length - player.y
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"grab",depth]
              player.grab(player.board.stacks[player.x],depth)
            } else {
              //drop
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [player.x,player.y,"drop",1]
              player.drop(player.board.stacks[player.x],1)
            }
            player.control_scheme = 0
            player.keyboard_actions++
          })


          var ctrl = false
          jaws.on_keydown(["ctrl"], function () {
            ctrl = true
          })
          jaws.on_keyup(["ctrl"], function () {
            ctrl = false
          })

          var shift = false
          jaws.on_keydown(["shift"], function () {
            shift = true
          })
          jaws.on_keyup(["shift"], function () {
            shift = false
          })

          jaws.on_keydown(["z"], function() {
            if (ctrl)
              undoLastMove()
            else {
              if (pause || game_end != "") return
              if(player.hand.items.length == 0) {
                // record this action
                player.replay_data[player.timer.frame_ticker.toString()]
                  = [player.x,player.y,"grab",depth]
                player.grab(player.board.stacks[player.x],player.board.stacks[player.x].items.length)
              } else {
                player.drop(player.board.stacks[player.x],player.hand.items.length)
              }
              player.control_scheme = 0
              player.keyboard_actions++
            }
          })

          jaws.on_keydown(["r"], function() {

            if (!ctrl)
              return

            if (level_edit) {
              if (shift) {
                player.level_shuffle()
                return
              }
            }

            // stop all sounds currently playing
            for (var i=0; i<player.board.sounds.length;i++) {
              var this_sound = player.board.sounds[i]
              this_sound.stop()
              removeFromPlayingSounds(this_sound)
            }
            // update marathon progress
            if (marathon) {
              if (player.timer.clock_text > marathon_progress[0])
                marathon_progress[0] = player.timer.clock_text
              if (player.score > marathon_progress[1])
                marathon_progress[1] = player.score
              // update player_save data and cookie data
              updateSaveAndCookie()
            }
            var record = buildRecordString(player.board,"R")
            saveRecord(record)
            game_end = "R"
            jaws.start(Game)
          })

          jaws.on_keydown(["left_mouse_button"], function() {
            if (pause || game_end != "") return
            var click_coordinates = new Array()
            click_coordinates = player.board.boardCoordinates(jaws.mouse_x,jaws.mouse_y)
            console.log("click coordinates on board: (" + click_coordinates[0] + "," + click_coordinates[1] + ")")
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [click_coordinates[0],click_coordinates[1],"click",0]
            player.clickAction(click_coordinates)
          })

          jaws.on_keydown(["right_mouse_button"], function() {
            if (pause || game_end != "") return
            var click_coordinates = new Array()
            click_coordinates = player.board.boardCoordinates(jaws.mouse_x,jaws.mouse_y)
            console.log("right click coordinates on board: (" + click_coordinates[0] + "," + click_coordinates[1] + ")")
              // record this action
              player.replay_data[player.timer.frame_ticker.toString()]
                = [click_coordinates[0],click_coordinates[1],"click",1]
            player.clickAction(click_coordinates,true)
          })

        }

        // level edit menu actions
        this.level_new = function() {
          console.log("New")
          player_level = 0
          player_stage = level_data.levels[0].length + 1
          console.log("editing level 0-" + player_stage)
          level_edit_play = false
          jaws.start(Game)
        }

        this.level_open = function() {
          console.log("Open")
          level_select_menu.active = true
          level_select_menu.controls(level_select_menu,level_select_ok)
          level_select_ok.menu_box.active = true
          level_select_menu.index = (player_level==0)?(player_stage-1):((player_level-1)*6+parseInt(player_stage)-1+level_data.levels[0].length)
        }

        this.level_save = function() {
          console.log("Save")
          var result = (level_name == "new")?
            window.prompt("enter level name","") :
            result = level_name
          if (result == null)
            return
          else
            level_name = (player_level==0)?result:(player_level+"-"+player_stage)
            saveLevel(player_level,player_stage,player.board,star_time,star_score,star_lock,level_name,function() {
                loadLevels(function(data) {
                  level_data = JSON.parse(data)
                  latest_edit = level_data.levels[0].length + 1
                  player_progress[0][0] = latest_edit - 2
                  level_edit_play = false
                  jaws.start(Game)
                })
            })
        }

        this.level_save_as = function() {
          console.log("Save As")
          var result = window.prompt("enter level name","")
          if (result == null)
            return
          else {
            level_name = result
            player_level = 0
            saveLevel(player_level,player_stage,player.board,star_time,star_score,star_lock,level_name,function() {
                loadLevels(function(data) {
                  level_data = JSON.parse(data)
                  latest_edit = level_data.levels[0].length
                  player_progress[0][0] = latest_edit - 1

                  window.alert("level_name = " + level_name)
                  player_level = 0
                  player_stage = 1
                  // find stage number of level_name
                  for (var i = 0; i < level_data.levels[0].length; i++) {
                    if (level_data.levels[0][i].split('\n')[9]==level_name) {
                      player_stage = i + 1
                      break
                    }
                  }

                  level_edit_play = false
                  jaws.start(Game)
                })
            })
          }
        }

        this.level_publish = function() {
          console.log("Publish")

          var level_count = level_data.levels.length - 1
          var latest_stage = level_data.levels[level_count].length

          if (latest_stage >= 6) {
            player_level = level_count + 1
            player_stage = 1
          } else {
            player_level = level_count
            player_stage = latest_stage + 1
          }

          var level_name = player_level.toString() + "-" + player_stage.toString()
          saveLevel(player_level,player_stage,player.board,star_time,star_score,star_lock,level_name,function() {
              loadLevels(function(data) {
                level_data = JSON.parse(data)
                latest_edit = level_data.levels[0].length + 1

                // load save file
                var open_data = cookie_save.split("|")
                if (open_data[0] == "SuperWizardPotionSave") {
                  var loaded_progress = loadProgress(level_data,open_data)
                  player_progress = loaded_progress[0]
                  star_progress = loaded_progress[1]
                }

                player_progress[0][0] = latest_edit - 2
                level_edit_play = false
                jaws.start(Game)
              })
          })
        }

        this.level_delete = function() {
          console.log("Delete")
          deleteLevel (player_level,level_name,function(latest){
            loadLevels(function(data) {
              level_data = JSON.parse(data)
              latest_edit = latest - 1
              player_progress[0][0] = latest_edit
              player_level = 0
              player_stage = level_data.levels[0].length + 1
              level_edit_play = false
              jaws.start(Game)
            })
          })
        }

        this.level_shuffle = function() {
          console.log("Shuffle")

          var this_board = this.board
          var all_items = []

          // push all items into an array
          for (var s = 0; s < this_board.stacks.length; s++) {
            var this_stack = this_board.stacks[s]
            for (var i = 0; i < this_stack.items.length; i++) {
              all_items.push(this_stack.items[i])
            }
          }

          // clear the board
          this_board.clearBoard()

          // shuffle all items
          fisherYates(all_items)

          // push back all items into random stacks
          while(all_items.length > 0) {
            var random_s = Math.floor(Math.random()*6)
            var this_stack = this_board.stacks[random_s]

            while (this_stack.items.length >= BOARD_HEIGHT) {
              random_s = Math.floor(Math.random()*6)
              this_stack = this_board.stacks[random_s]
            }

            var this_item = all_items.pop()
            
            // update stack items
            this_item.x = random_s
            this_item.y = this_stack.items.length
            this_item.stack = this_stack

            // update sprite destination
            this_item.sprite.dx = this_board.posx(this_item.x)
            this_item.sprite.dy = this_board.posy(this_item.y)

            this_stack.items.push(this_item)
          }



        }

        // check if player hand can move in x direction
        this.canMoveX = function(x) {

          // check if stacks overlap
          if (this.board.stacks[this.x + x].items.length + this.hand.items.length > BOARD_HEIGHT)
            return false

          return true
        }

        // move the player hand in x direction
        this.moveX = function(x) {

          this.x += x

          //update each item in hand
          for (var i=0; i<this.hand.items.length; i++) {
            var item = this.hand.items[i]
            item.x = this.x
            item.sprite.dx = this.board.posx(this.x)
          }

          console.log("player x = " + this.x)
        }

        this.moveX_click = function(x) {

          var sign = x?x<0?-1:1:0
          var hit_wall = false

          for (var i=0; i < Math.abs(x); i++) {
            if (this.canMoveX(sign)) player.moveX(sign)
            else {
              // drop minimum amount of items on hand so hand can move left
              var drop_amount = player.hand.items.length - (BOARD_HEIGHT - player.board.stacks[player.x + sign].items.length)
              hit_wall = true
              if (drop_amount > 0 && BOARD_HEIGHT - player.board.stacks[player.x + sign].items.length > 0) {
                player.drop(player.board.stacks[player.x],drop_amount)
                player.moveX(sign)
              }
            }
          }

          return hit_wall

        }

        // grab depth amount of items from stack
        this.grab = function(stack,depth) {

          // start the timer
          if (!game_start)
            game_start = true

          // count player moves
          this.moves++

          // move the cursor quickly to the top of the screen
          Y_SPEED = FAST
          this.cursor_speed = Y_SPEED

          // loop through the items of the stack according to depth passed in
          // pop items and push to the player hand, one by one
          for(var i=0; i<depth; i++) {

            // push top of stack to hand
            var item = stack.items.pop()

            // if the player grabs a cauldron
            if (i==0 && item.type==3) {
              this.hand.items.push(item)
              // update hand position
              item.x = this.x
              item.y = BOARD_HEIGHT - 1 - i
              item.stack = this.hand

              // update sprite destination
              item.sprite.dx = this.board.posx(item.x)
              item.sprite.dy = this.board.posy(item.y)

              // reset chain
              item.chain = 0

              game_end = "W"

              this.drop(stack,1)

              break
            }

            if (item.breaking || item.type == 3) {
              stack.items.push(item)
              break
            }
            this.hand.items.push(item)

            // update hand position
            item.x = this.x
            item.y = BOARD_HEIGHT - 1 - i
            item.stack = this.hand

            // update sprite destination
            item.sprite.dx = this.board.posx(item.x)
            item.sprite.dy = this.board.posy(item.y)

            // reset chain
            item.chain = 0

          }

          // add current state of board and hand to undo arrays
          addStateForUndo(this.hand,this.board)

          // play sound effect
          // if (depth > 0) {
          //   grab_sound.stop()
          //   removeFromPlayingSounds(grab_sound)
          //   if (!mute)
          //     drop_sound.play()
          // }
        }

        // drop depth amount of items onto stack
        this.drop = function(stack,depth) {       

          this.moves++
          console.log("player moves = " + this.moves)

          Y_SPEED = FAST

          var hand_items = this.hand.items
          var stack_items = stack.items

          for(var i=0; i<depth; i++) {
            stack.items.push(hand_items.pop())

            // update stack items
            var item = stack_items.pop()
            item.x = this.x
            item.y = stack_items.length
            item.stack = stack

            // update sprite destination
            item.sprite.dx = this.board.posx(item.x)
            item.sprite.dy = this.board.posy(item.y)

            stack_items.push(item)

          }

          // reset chain for all items on stack if none are breaking
          if (!stack.itemsBreaking())
            stack.setChain(stack.items,0)

          // check for matches
          stack.checkForMatches()

          // reposition player's y position if hand is now empty
          if (hand_items.length == 0)
            this.y = stack_items.length - depth // at item at bottom of hand stack

          // add current state of board and hand to undo arrays
          addStateForUndo(this.hand,this.board)

          // play sound effects
          // drop_sound.stop()
          // removeFromPlayingSounds(drop_sound)
          // grab_sound.stop()
          // removeFromPlayingSounds(grab_sound)
          // if (!mute)
          //   grab_sound.play()

        }

        this.clickAction = function(click_coordinates,right_click) {

          var click_x = click_coordinates[0]
          var click_y = click_coordinates[1]
          right_click = typeof right_click !== 'undefined' ? right_click : false;

          var click_outside_board = false

          // normal gameplay
          if (!level_edit) {
            this.mouse_actions++
            this.control_scheme = 1

            if (click_x < 0 || click_y < 0)
              click_outside_board = true

            if (click_outside_board && (marathon || sprint)) {
              if ((marathon || sprint) && !player.board.stacksBreaking() && !player.board.stacksFull()) {
                player.board.raiseStacks()
                // record this action
                player.replay_data[player.timer.frame_ticker.toString()]
                  = [player.x,player.y,"raise",0]
              }
              return
            }

            // move player cursor to clicked x coordinate
            if (Math.abs(click_x - this.x) > 1) X_SPEED = FAST
            else X_SPEED = SLOW

            var this_stack = this.board.stacks[click_x]
            var depth = 0
            var old_x = this.x

            // move the hand and catch if it hit a wall
            var hit_wall = this.moveX_click(click_x - this.x)
            this_stack = this.board.stacks[this.x] // update this_stack

            // grab if hand is empty
            if (this.hand.items.length == 0) {

              // grab if item on stack is clicked
              if (right_click)
                depth = this_stack.items.length
              else if (this_stack.items.length >= click_y) {
                depth = this_stack.items.length - click_y // how many items to grab
              }

              this.grab(this_stack,depth)

            // drop if hand is holding items
            } else {

              // determine y coordinate of bottom of hand stack
              var cutoff = BOARD_HEIGHT - this.hand.items.length
              console.log("click_y = " + click_y)
              console.log("cutoff = " + cutoff)
              if (right_click)
                depth = this.hand.items.length
              else if (click_y < cutoff) {
                depth = 1
              } else if (old_x == click_x) {
                depth = click_y - cutoff + 1
              } else if (old_x != click_x) {
                if (click_y == this_stack.items.length)
                  depth = 1
              }

              // drop remaining items on hand
              console.log("depth = " + depth)
              this.drop(this_stack,depth)

            }

          // controls for level editor
          } else if (level_edit) {

            level_editor.controls(click_x, click_y, right_click)
            if (level_edit_menu.mouse_inside) {
              level_edit_menu.items[level_edit_menu.index].action()
            } else if (puzzle_data.mouse_inside) {
              puzzle_data.items[puzzle_data.index].action()
            }

          }
        }



        // update player sprites positions
        this.updatePlayerSprites = function(dx,dy) {

          var cursor_top = this.cursor_top
          var cursor_bottom = this.cursor_bottom

          cursor_top.dx = cursor_bottom.dx = this.board.posx(this.x)

          if (this.hand.items.length == 0) {
            cursor_top.dy = this.board.posy(this.y)
            cursor_bottom.dy = this.board.posy(this.y) + cursor_bottom.height
          } else {
            cursor_top.dy = this.board.posy(BOARD_HEIGHT-1)
            cursor_bottom.dy = this.board.posy(BOARD_HEIGHT - this.hand.items.length) + cursor_bottom.height
          }

          spriteMove(cursor_top,X_SPEED,this.cursor_speed)
          spriteMove(cursor_bottom,X_SPEED,this.cursor_speed)

          // reset cursor speed when it reaches dy
          if (this.hand.items.length == 0 && cursor_top.dy == cursor_top.y) this.cursor_speed = X_SPEED

          // animate wizard
          this.wizard.setImage(this.wizard.anim_default.next())


        }

        // update player sprites, board sprites, etc.
        this.update = function() {

          if (pause)
            return

          // update timer
          this.timer.update()

          // update cursor position
          var cursor = this.cursor

          this.updatePlayerSprites(this.board.posx(this.x),this.board.posy(this.y))

          this.board.update() // updates sprites for each stack
          this.hand.update()  // updates sprites for items in hand

        }

        // draw everything that was just updated
        this.draw = function() {

          this.board.draw()

          if (pause || game_end != "")
            return

          // draw wizard
          this.wizard.draw()

          if (marathon || sprint) {
            // draw hand, flash if stack is full
            var this_stack = this.board.stacks[this.x]
            var this_stack_full = (this_stack.items.length + this.hand.items.length == BOARD_HEIGHT)
            // var danger_time = (player_timer.raise_level_timer < raise_level_time/4) ? ((player_timer.ticker%8==0) ? true : false) : false
            var danger_time = (this.timer.ticker%8==0) ? true : false
            if (!this_stack_full || !danger_time || this_stack.itemsBreaking()) {
              this.hand.draw()
            }
          } else
            this.hand.draw()
          // jaws.context.drawImage(jaws.assets.get("images/CURSOR.gif"), this.cursor.x, this.cursor.y)

          if (control_scheme == 2 && this.hand.items.length == 0)
            return

          if (this.control_scheme == 0 || this.hand.items.length > 0) {
            this.cursor_top.draw()
            this.cursor_bottom.draw()
          }
        }

      }

      function LevelEditor(board) {

        this.x = board.board.x + ITEM_WIDTH * (BOARD_WIDTH + 1)
        this.y = board.board.y + ITEM_WIDTH * 2
        this.board = new jaws.Sprite({x:this.x,y:this.y,image:"./static/images/BOARD.gif",anchor:"left"})
        this.board.width = ITEM_WIDTH * 3
        this.board.height = ITEM_WIDTH * 8

        this.flasks = new Array()
        this.blocks = new Array()
        this.robots = new Array()

        // provide position with respect to this Board
        this.posx = function(x) { return this.x + x * ITEM_WIDTH }
        this.posy = function(y) { return this.y + (8 - 1 - y)*ITEM_WIDTH }

        // flasks
        for (var f = 0; f < 8; f++) {

          if (f == 3 || f == 4 || f == 5) {
            this.flasks.push(new jaws.Sprite({x:this.posx(0),y:this.posy(f),image:"./static/images/POTION_" + COLORS[(f==6) ? 7 : ((f==7) ? 6 : f)] + ".gif",anchor:"left"}))
          } else {
            this.flasks.push(new jaws.Sprite({x:this.posx(0),y:this.posy(f), anchor:"left"}))
            var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_" + COLORS[(f==6) ? 7 : ((f==7) ? 6 : f)] + ".gif", frame_size: [40,40], frame_duration: 100})
            this.flasks[f].anim_default = anim.slice(0,5)
            this.flasks[f].setImage(this.flasks[f].anim_default.next())
          }
        }

        // blocks
        for (var b = 0; b < 7; b++) {
          this.blocks.push(new jaws.Sprite({x:this.posx(1),y:this.posy(b),image:"./static/images/" + COLORS[(b==6) ? 7: b] + ".gif", anchor:"left"}))
          this.blocks[b].width = ITEM_WIDTH
          this.blocks[b].height = ITEM_WIDTH
          console.log("creating block_sprite = " + this.blocks[b])
        }

        for (var r = 0; r < 6; r++) {
          // create sprite for this robot
          this.robots.push(new jaws.Sprite({x:this.posx(2),y:this.posy(r), anchor: "left"}))
          var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + COLORS[r] + ".gif", frame_size: [40,40], frame_duration: 100})
          this.robots[r].anim_default = anim.slice(0,5)
          this.robots[r].setImage(this.robots[r].anim_default.next())
          console.log("creating robot_sprite = " + this.robots[r])
        }

        this.hand = new jaws.Sprite(this.flasks[this.flasks.length-1])
        this.hand.type = 1
        this.hand.color = EMPTY

        this.controls = function(click_x, click_y, right_click) {
          var color

          // catch clicks made in toolbox
          if (click_x >= 7 && click_x <= 9) {

            if (click_y >= 0 && click_y <= 5) {
              color = click_y
            } else if (click_y == 6) {
              if (click_x <= 8)
                color = WHITE
            } else if (click_y == 7) {
              if (click_x == 7)
                color = EMPTY
            }

            if (click_x == 7) {
              level_editor.hand = new jaws.Sprite(level_editor.flasks[click_y])
              level_editor.hand.type = 1
            }
            else if (click_x == 8) {
              if (click_y > 6)
                return
              level_editor.hand = new jaws.Sprite(level_editor.blocks[click_y])
              level_editor.hand.type = 0
            }
            else if (click_x == 9) {
              if (click_y > 5)
                return
              level_editor.hand = new jaws.Sprite(level_editor.robots[click_y])
              level_editor.hand.type = 2
            }
            level_editor.hand.color = color

            level_editor.hand.width = ITEM_WIDTH
            level_editor.hand.height = ITEM_WIDTH

            console.log("click with type = " + level_editor.hand.type + " and color = " + level_editor.hand.color)

          // catch clicks made on board
          } else if (click_x >=0 && click_x <= 5) {

            var this_stack = player.board.stacks[click_x]
            console.log("player = " + player)
            console.log("player.board = " + player.board)
            console.log("player.board.stacks = " + player.board.stacks)
            var cutoff = this_stack.items.length

            // add item if above stack
            if (click_y >= cutoff) {

              if (right_click) {

                while (this_stack.items.length < BOARD_HEIGHT) {
                  this_stack.items.push(new Item(this_stack,level_editor.hand.type,level_editor.hand.color,click_x,this_stack.items.length))

                  // items fall after spawn
                  var this_item = this_stack.items[this_stack.items.length-1]
                  console.log("this_item = " + this_item)
                  this_item.sprite.x = player.board.posx(click_x)
                  this_item.sprite.y = player.board.posy(click_y)

                }

              // add item on hand
              } else {

                if (this_stack.items.length < BOARD_HEIGHT) {
                  this_stack.items.push(new Item(this_stack,level_editor.hand.type,level_editor.hand.color,click_x,this_stack.items.length))

                  // items fall after spawn
                  var this_item = this_stack.items[this_stack.items.length-1]
                  console.log("this_item = " + this_item)
                  this_item.sprite.x = player.board.posx(click_x)
                  this_item.sprite.y = player.board.posy(click_y)

                }

              }

            // remove item clicked on stack
            } else {

              var this_item = this_stack.items[click_y]

              if (right_click) {

                // remove clicked item
                this_stack.removeItem(this_item)

                var sprite_stack = (this_item.type == 0) ? this.blocks : (
                  (this_item.type == 1) ? this.flasks : this.robots
                  )

                if(this_item.color == WHITE)
                  color = 6
                else if (this_item.color == EMPTY)
                  color = 7
                else
                  color = this_item.color

                this.hand = new jaws.Sprite(sprite_stack[color])
                this.hand.type = this_item.type
                this.hand.color = this_item.color

              } else {

                // remove clicked item
                this_stack.removeItem(this_item)

                // replace clicked item with item on hand by:

                // remove but save all items above clicked item
                var stack_above = new Array()
                for (var i=this_stack.items.length-1; i>=click_y; i--) {
                  this_item = this_stack.items[i]
                  stack_above.push(this_item)
                  this_stack.removeItem(this_item)
                }

                // first add item from hand
                this_stack.items.push(new Item(this_stack,level_editor.hand.type,level_editor.hand.color,click_x,this_stack.items.length))
                this_item = this_stack.items[this_stack.items.length-1]
                this_item.sprite.x = player.board.posx(click_x)
                this_item.sprite.y = player.board.posy(click_y)

                // then add back the stack above
                var i = 1
                while (stack_above.length>0) {
                  this_stack.items.push(stack_above.pop())
                  this_item = this_stack.items[this_stack.items.length-1]
                  this_item.y = this_stack.items.length - 1
                  i++
                }

                // stack.items.push(hand_items.pop())

                // // update stack items
                // var item = stack_items.pop()
                // item.x = this.x
                // item.y = stack_items.length
                // item.stack = stack

                // // update sprite destination
                // item.sprite.dx = this.board.posx(item.x)
                // item.sprite.dy = this.board.posy(item.y)

                // stack_items.push(item)

                // OLD CODE FOR REVERSE FILL
                // var matches = new Array()
                // var last_match = this_stack.items[0]
                // var this_match
                // var touched_this_item = false

                // matches.push(last_match)
                // console.log("pushing onto matches: (" + last_match.type + "," + last_match.color + ")")

                // // THIS WAS DONE WITH TRIAL AND ERROR.
                // for (var i=1; i < this_stack.items.length; i++) {

                //   console.log("i = " + i)

                //   this_match = this_stack.items[i]

                //   if (this_match.type==last_match.type && this_match.color==last_match.color) {
                //     matches.push(this_match)
                //     console.log("pushing onto matches: (" + this_match.type + "," + this_match.color + ")")
                //     last_match = this_match
                //   } else {

                //     if (i > click_y)
                //       touched_this_item = true

                //     if (!touched_this_item) {
                //       matches = new Array()
                //       matches.push(this_match)
                //       console.log("pushing onto matches: (" + this_match.type + "," + this_match.color + ")")
                //       last_match = this_match
                //     } else {
                //       break
                //     }

                //   }

                // }

                // console.log("matches = " + matches)
                // this_stack.removeItems(matches)

              }

            }
          }
        }

        this.update = function() {
          this.hand.x = jaws.mouse_x - ITEM_WIDTH/2
          this.hand.y = jaws.mouse_y - ITEM_WIDTH/2
        }

        this.draw = function() {

          this.hand.draw()
          this.board.draw()

          for (var f = 0; f < this.flasks.length; f++) {
            this.flasks[f].draw()
          }
          for (var b = 0; b < this.blocks.length; b++) {
            this.blocks[b].draw()
          }
          for (var r = 0; r < this.robots.length; r++) {
            this.robots[r].draw()
          }

        }

      }

      /* Constructor for board */
      function Board(player) {
        this.player = player
        this.stacks = new Array()
        this.board = new jaws.Sprite({x:ITEM_WIDTH,y:ITEM_WIDTH,image:"./static/images/BOARD.gif",anchor:"left"})

        this.block_count = [0,0,0,0,0,0,0,0]
        this.flask_count = [0,0,0,0,0,0,0,0,0]
        this.robot_count = [0,0,0,0,0,0]

        this.cauldron_count = 0

        this.effects = new Array()
        this.sounds = new Array()

        this.undo_alpha = 0

        this.item_queue = []

        // provide position with respect to this Board
        this.posx = function(x) { return this.board.x + x * ITEM_WIDTH }
        this.posy = function(y) { return this.board.y + (BOARD_HEIGHT - 1 - y)*ITEM_WIDTH }

        this.clearBoard = function() {

         for (var s = 0; s < this.stacks.length; s++) {
          var this_stack = this.stacks[s]
          this_stack.items = new Array()
         }

        }

        // generate random item
        this.randomItem = function(stack,x,y) {


          if (replay == null || replay["stack_queue"][x].length == 0) {


            // before generating random item, first check if there are specific items on queue
            if (this.item_queue.length > 0) {

              for (var i = 0; i < this.item_queue.length; i++) {
                var this_item = this.item_queue[i]
                if (this_item.x == x) {
                  this.item_queue.splice(i,1)
                  return this_item
                }
              }

            }

            if (marathon) {
              var type_color_string = randomization_array[marathon_level-1].pop()
              randomization_array[marathon_level-1].push(type_color_string)
              fisherYates(randomization_array[marathon_level-1])
            } else if (sprint) {
              var type_color_string = sprint_randomization.pop()
              sprint_randomization.push(type_color_string)
              fisherYates(sprint_randomization)
            }
            var type_color = type_color_string.split("|")
            var type = type_color[0]
            var color = type_color[1]

            // add this item to replay data
            this.player.replay_data["stack_queue"][x].push(type_color_string)

          // for replays, get recorded item in stack queue
          } else {

            console.log("RANDOME")
            console.dir(replay)
            var type_color_string = replay["stack_queue"][x].shift()
            var type_color = type_color_string.split("|")
            var type = type_color[0]
            var color = type_color[1]

          }

          return new Item(stack,type,color,x,y)

        }

        // spawn specific item
        this.spawnItem = function(type,color) {
          var rand_stack = Math.floor(Math.random()*6)
          this.item_queue.push(new Item(this.stacks[rand_stack],type,color,rand_stack,-1))
        }

        // checks if a stack contains breaking items
        this.stacksBreaking = function() {
          var this_stack
          for (var s=0; s < this.stacks.length; s++) {
            this_stack = this.stacks[s]
            if (this_stack.itemsBreaking())
              return true
          }
          return false
        }

        // checks if any stack is full
        this.stacksFull = function() {

          var this_stack
          for (var s=0; s < this.stacks.length; s++) {
            this_stack = this.stacks[s]
            if (this_stack.items.length + ((this_stack.x == player.x)?(player.hand.items.length):0) >= BOARD_HEIGHT)
              return true
          }

          return false

        }

        // raise level using random items in each stack's queue
        this.raiseStacks = function() {


          // reset board y position
          this.board.y = ITEM_WIDTH

          var this_stack
          for (var s = 0; s < BOARD_WIDTH; s++) {
            this_stack = this.stacks[s]
            console.log("raising this stack using random item:")
            console.dir(this_stack.next_random_item)

            // pop each item of this stack onto a temporary array
            var temp_stack = new Array()
            while (this_stack.items.length > 0) {
              temp_stack.push(this_stack.items.pop())
            }

            // push next random item onto this stack and update it's location and sprite
            this_stack.items.push(this_stack.next_random_item)
            this_stack.next_random_item.y = 0
            this_stack.next_random_item.sprite.dy = this.posy(0)
            this_stack.next_random_item.active = true

            // push temporary stack onto this stack
            while (temp_stack.length > 0) {
              var this_item = temp_stack.pop()
              this_stack.items.push(this_item)
              this_item.y = this_stack.items.length-1
              this_item.chain = 0
              this_item.sprite.dy = this.posy(this_stack.items.length-1)
            }

            // drop player hand if stack exceeds the top, end game if nothing breaks
            if (this_stack.items.length > (BOARD_HEIGHT - ((this_stack.x==player.x)?(player.hand.items.length):0) )) {
              player.drop(player.board.stacks[player.x],player.hand.items.length)
              if (this_stack.x!=player.x)
                this_stack.checkForMatches()
              if (!this_stack.itemsBreaking())
                game_end = "L"
            } else {
              // check for matches
              this_stack.checkForMatches()
            }

            // randomize next random item
            this_stack.next_random_item = this.randomItem(this_stack,s,-1)

          }

          // move player cursor up
          player.y++

          if (player.y >= BOARD_HEIGHT)
            player.y = BOARD_HEIGHT - 1

          // reset timer
          player.timer.raise_level_timer = raise_level_time

          // increment raise_count
          raise_count++

          console.log("raising stack with raise_count = " + raise_count)

          if (marathon && !marathon_debug) {
            if (raise_count == raise_count_level[marathon_level-1]) {
              if (marathon_level < ITEM_PROBS["0|0"].length) {
                raise_count = 0
                marathon_level++
              }
            }
          } else if (sprint) {
            if (raise_count >= sprint_data.game["depth"]) {
              if (player.board.cauldron_count < 1)
                player.board.spawnItem(3,EMPTY)
            }
          }

          // update screen data
          screen_data.items[0].text = marathon_level + ":" + raise_count

          Y_SPEED = SLOW

        }

        // generate marathon board
        this.marathonLevel = function(level) {

          var value

          // fill up the randomization array
          for (var i = 0; i < ITEM_PROBS["0|0"].length; i++) {
            randomization_array.push([])
            for (var key in ITEM_PROBS) {
              if (ITEM_PROBS.hasOwnProperty(key)) {
                value = ITEM_PROBS[key]
                for (var j = 0; j < value[i]; j++) {
                  randomization_array[i].push(key)
                }
              }
            }
            // shuffle the randomization array
            fisherYates(randomization_array[i])
          }

          // create stacks for the board
          var random_item
          for (var s = 0; s < BOARD_WIDTH; s++) {
            this.stacks.push(new Stack(this,level,s))
            var this_stack = this.stacks[s]
            // add level amount of random items to this stack
            for (var l = 0; l < level; l++) {

              random_item = this.randomItem(this_stack,s,l)
              this_stack.items.push(random_item)

            }

            this_stack.next_random_item = this.randomItem(this_stack,s,-1)
            console.log("this stack's next random item:")
            console.dir(this_stack.next_random_item)

            // check for matches
            this_stack.checkForMatches()
          }

        }

        // generate sprint board
        this.sprintLevel = function(sprint_data) {

          var value

          // fill up the randomization array
          for (var key in sprint_data.prop) {
            if (sprint_data.prop.hasOwnProperty(key)) {
              value = sprint_data.prop[key]
              for (var j = 0; j < value; j++) {
                sprint_randomization.push(key)
              }
            }
          }
          // shuffle the randomization array
          fisherYates(sprint_randomization)

          // create stacks for the board
          var random_item
          for (var s = 0; s < BOARD_WIDTH; s++) {
            this.stacks.push(new Stack(this,sprint_data.game.height,s))
            var this_stack = this.stacks[s]
            // add level amount of random items to this stack
            for (var l = 0; l < sprint_data.game.height; l++) {

              random_item = this.randomItem(this_stack,s,l)
              this_stack.items.push(random_item)

            }

            this_stack.next_random_item = this.randomItem(this_stack,s,-1)
            console.log("this stack's next random item:")
            console.dir(this_stack.next_random_item)

            // check for matches
            this_stack.checkForMatches()
          }          

        }

        this.fillLevel = function(level,stage,undo) {

          console.log("level_data")
          console.dir(level_data)

          console.log("level = " + level)
          console.log("stage = " + stage)

          console.log(level_data.levels[0])
          console.log(level_data.levels[0][6])

          var undo_state = undo || undefined

          var data = (undo_state != undefined) ? undo_state : level_data.levels[level][stage-1]

          console.log("level_data")
          console.dir(level_data)

          // SANITY CHECK
          if (data == "" || data == "\n\n\n\n\n\n" || data == undefined) {
            if (level_edit) {
              for (var s=0; s < BOARD_WIDTH; s++)
                this.stacks.push(new Stack(this,level,s))
              return
            } else {
              player_level = 1
              player_stage = 1
              jaws.start(MainMenu)
            }
          }

          // array of stacks in string form
          var stacks_string = data.split('\n')
          var items
          star_time = stacks_string[6]
          star_score = stacks_string[7]
          star_lock = stacks_string[8]

          // go through each stack
          for (var s=0; s < BOARD_WIDTH; s++) {

            this.stacks.push(new Stack(this,level,s))

            var this_stack = this.stacks[s]

            // array of items in string form
            items = stacks_string[s].split(',')

            // skip empty stacks
            if (items == "")
              continue

            // go through each item in this stack
            for (var i=0; i < items.length; i++) {

              var item = items[i]
              var item_string = item.split('|')

              var type = item_string[0]
              var color = item_string[1]

              console.log("stack(" + s + ") looking though item of type = " + type + ", color = " + color)

              this_stack.items.push(new Item(this_stack,type,color,s,i))

            }

          }

          console.log("block_count = " + this.block_count)
          console.log("flask_count = " + this.flask_count)
          console.log("robot_count = " + this.robot_count)



        }

        // fill up the board with items depending on level-stage
        this.fill = function(level,stage) {

          console.log("Setting up level " + level + "-" + stage + ".")

          // determine what needs to be placed on the board for this level-stage
          var total_flasks = level + 1 // except for 1-1, 1-2
          if (level == 1 && (stage == 1 || stage == 2))
            total_flasks = 1
          console.log("total_flasks = " + total_flasks)

          var total_robots = level + stage // except for level 1
          if (level == 1) {
            total_robots = stage
          }
          console.log("total_robots = " + total_robots)

          var total_blocks = 6 * (level + 1) + stage // except for 1-1,1-2,1-3,1-4,1-5
          if (level == 1) {
            if (stage == 1) total_blocks = 5
            else if (stage == 2) total_blocks = 6
            else if (stage == 3) total_blocks = 10
            else if (stage == 4) total_blocks = 12
            else if (stage == 5) total_blocks = 14
          }
          console.log("total_blocks = " + total_blocks)

          var total_colors = level + 1 // except for 1-1,1-2
          if (level == 1) {
            if (stage <= 2) total_colors = 1
          } else if (level == 6) total_colors = 6
          console.log("total_colors = " + total_colors)

          // put everything that's needed into an Array then randomize
          var items_array = new Array() // will contain tuple = [type,color]

          // put items in array for each color
          for (var c=0; c < total_colors; c++) {

            // put robots into array
            var robots_of_color = total_robots / total_colors
            for (var r=0; r < robots_of_color; r++) {
              items_array.push([2,c])
              if (items_array.length >= total_robots) break
            }

            // put at least one flask for each color, fill up flasks with white for mode: 1
            //items_array.push([1, (game_mode == 1) ? WHITE : EMPTY])

            // put at least three blocks for each color
            items_array.push([0,c])
            items_array.push([0,c])
            items_array.push([0,c])

          }

          // put in flasks
          var num_empty_flasks = Math.floor(total_colors / 2)

          // exceptions
          // 1-3
          if (player_level == 1) {
            if (player_stage == 3)
              num_empty_flasks = 0
            else if (player_stage == 6) {
              num_empty_flasks = 1
            }
          } else if (player_level == 6) {
            if (player_stage == 1)
              num_empty_flasks = 2
            else if (player_stage == 6)
              num_empty_flasks = 1
          }

          console.log("num_empty_flasks = " + num_empty_flasks)

          var num_white_flasks = total_colors - num_empty_flasks

          for (var e=0; e < num_empty_flasks; e++) {
            items_array.push([1, EMPTY])
            // put at least three white blocks for each empty flask
            items_array.push([0,WHITE])
            items_array.push([0,WHITE])
            items_array.push([0,WHITE])
          }
          for (var w=0; w < num_white_flasks; w++)
            items_array.push([1, WHITE])

          console.log("item_count = " + items_array.length)

          // fill up with random blocks and flasks until total_blocks reached
          while (items_array.length < total_blocks) {

            var rand_color = Math.floor(Math.random()*7)

            if (rand_color > total_colors - 1) {
              items_array.push(
                [2,Math.floor(Math.random()*total_colors)]
              )
            } else if (rand_color < 6) {

              var rand_int = Math.floor(Math.random()*2)
              if (rand_int == 0) items_array.push([0,rand_color])
              else items_array.push([2,rand_color])

            }
            else {
              items_array.push([1,WHITE])
              console.log("color(" + WHITE + ")")
            }



            console.log(items_array[items_array.length - 1])

          }

          console.log("done filling up items_array")
          console.log("item_count = " + items_array.length)

          // shuffle the item_array
          fisherYates(items_array)
          for(var i=0; i < items_array.length; i++) {
            console.log("[" + items_array[i][0] + "," + items_array[i][1] + "]")
          }

          // push BOARD_WIDTH amount of stacks
          for (var i=0; i < BOARD_WIDTH; i++) {
            this.stacks.push(new Stack(this,level,i))
          }

          console.log("items_array = " + items_array)

          // randomly decide which stack to place items in
          while (items_array.length > 0) {

            var rand_stack = Math.floor(Math.random()*6)
            var this_stack = this.stacks[rand_stack]
            if (this_stack.items.length >= level + 3) {
              console.log(items_array.length)
              console.log("top of stack reached")
              continue
            }
            var item_top = items_array.pop()

            console.log("color(" + item_top[1] + ")")
            this_stack.items.push(
              new Item(this_stack,item_top[0],item_top[1],rand_stack,this_stack.items.length)
            )

          }

          // make sure that stacks don't contain matches
          for(var s=0; s < player.board.stacks.length; s++) {
            var this_stack = player.board.stacks[s]
            if (this_stack.checkForMatches()) {
              // will restart at the beginning of this.update()
              need_to_restart = true
            }
          }

          // check if there are 5 blocks of some color
          for(var c=0; c < COLORS.length; c++) {
            if(this.block_count[c] == 5) {
              console.log("5 blocks of color(" + COLORS[c] + ") found. Resetting board.")
              need_to_restart = true
            }
          }

          // make sure that robot don't shed to add up to more than 9
          for(var i=0; i < 3; i++) {
            if(this.robot_count[i] + this.robot_count[i+3] > 9) {
              need_to_restart = true
              break
            }
          }

          console.log("block_count = " + this.block_count)
          console.log("flask_count = " + this.flask_count)
          console.log("robot_count = " + this.robot_count)

        }

        // provide coordinates of clicks with respect to (stack, depth)
        this.boardCoordinates = function(x,y) {
          console.log("converting click coordinates to board coordinates")

          // find click coordinates with respect to board's top-left position in canvas
          var board_x = x - this.board.x
          var board_y = y - this.board.y

          if (marathon || sprint) {
            if (board_x < 0 || board_x > this.board.width || board_y < 0 || board_y > this.board.height) {
              return [-1,-1]
            }
          }

          // figure out which stack player clicked above or on
          // bitwise OR operator to truncate float point figures
          board_x = (board_x / ITEM_WIDTH) | 0

          // figure out depth the player clicked into the stack
          board_y = BOARD_HEIGHT + (BOARD_HEIGHT - board_y) / ITEM_WIDTH | 0

          console.log([board_x, board_y])

          return [board_x, board_y]



        }

        // check if the player has reached a win/lose condition and act accordingly
        this.checkWinLose = function() {

          if (marathon || sprint)
            return

          console.log("CHECKING")

          cauldron_ticker += this.player.timer.frame_ticker

          // WIN CONDITION: robots cleared
          console.log("checking win condition")
          if (!(this.robot_count<[0,0,0,0,0,0] || [0,0,0,0,0,0]<this.robot_count)) { // array equality
            game_end = "W"
            return
          }

          // LOSE CONDITION: no more blocks/flasks to clear robots

          // calculate how many potions can be brewed for each color
          var potential_color_potions = [0,0,0,0,0,0,0,0]
          for (var c=0; c < COLORS.length; c++) {
            potential_color_potions[c] = this.block_count[c]/3 + this.flask_count[c]
          }

          // calculate how many potions are needed for each color
          var needed_color_potions    = [0,0,0,0,0,0,0,0]
          for (var c=0; c < 6; c++) {

            if (c == 3 || c > 5)
              continue

            // need 1 potion of color = c for 9 robots
            needed_color_potions[c] = Math.ceil(this.robot_count[c] / 9)

            // need 1 white potion for each unbrewed color potion
            if (needed_color_potions[c] - this.flask_count[c] > 0)
              needed_color_potions[WHITE] += needed_color_potions[c] - this.flask_count[c]

            console.log("potential [" + c + "] = " + potential_color_potions[c])
            console.log("needed [" + c + "] = " + needed_color_potions[c])

            // player loses if not enough potions to clear all robots
            if (potential_color_potions[c] < needed_color_potions[c]) {
              // window.alert("Lose! not enough potinos to clear all robots")
              game_end = "L"
              return
            }

          }

          // check if there are enough white potions to brew necessary color potions
          console.log("potential [WHITE] = " + potential_color_potions[WHITE])
          console.log("needed [WHITE] = " + needed_color_potions[WHITE])
          if (potential_color_potions[WHITE] < needed_color_potions[WHITE]) {
            // window.alert("Lose! not enough white potinos to brew color potions")
            game_end = "L"
            return
          }

          // console.log("checking lose conditions")
          // var remaining_robot_colors = 0
          // var remaining_armor_robots = 0
          // for (var c=0; c < 6; c++) {

          //   // catch all armored robots
          //   if (c > 2 && this.robot_count[c] > 0) {
          //     remaining_armor_robots++
          //     continue
          //   }

          //   if (this.robot_count[c] > 0)
          //     remaining_robot_colors++
          //   if (this.flask_count[c] > 0)
          //     remaining_robot_colors --
          // }

          // if (remaining_armor_robots > 0)
          //   remaining_robot_colors++
          // if (this.flask_count[GOLD] > 0)
          //   remaining_robot_colors--

          // var potential_white_potions = this.block_count[WHITE] / 3 + this.flask_count[WHITE]

          // console.log("potential_white_potions = " + potential_white_potions)
          // console.log("remaining_robot_colors = " + remaining_robot_colors)

          // for (var c=0; c < 6; c++) {

          //   if (c == 3 || c > 5)
          //     continue

          //   if (this.robot_count[c] > 0) {
          //     console.log("robots of color " + COLORS[c] + " still exist!")
          //     console.log("block count = " + this.block_count[c])
          //     console.log("flask_count = " + this.flask_count[c])
          //     if (this.flask_count[c] <= 0) {
          //       if (this.block_count[c] < 3) {
          //         console.log("lose! here for color = " + c)
          //         game_end = "L"
          //         return
          //       } else if (potential_white_potions < remaining_robot_colors){
          //         console.log("lose! not enough white blocks, checking color = " + COLORS[c])
          //         game_end = "L"
          //         return
          //       }
          //     }

          //   }
          // }

        }

        this.winLose = function() {

          winlose = true

          if (replay == null) {

            winlose_menu.active = true
            // winlose_menu.controls(winlose_menu)   
            var winlose_menu_items = new Array()       

            if (game_end == "W") {

              winlose_data.items[1].text += "  " + player.timer.clock_text
              winlose_data.items[2].text += " \u03BB" + player.score

              // update star progress
              if (!player_undid)
                player.new_stars = updateStarProgress(player,player_level,player_stage,star_time,star_score,winlose_data)

              player.stars = starTotal()
              player_data.items[0].text = "  x " + player.stars

              winlose_menu.title = ""

              // allow player to advance to next level if they have enough stars     
              console.log("level_data")
              console.dir(level_data)
              var level_check
              var stage_check
              if (player_stage < level_data["levels"][player_level].length) {
                level_check = player_level
                stage_check = player_stage
              } else {
                level_check = parseInt(player_level) + 1
                stage_check = 0
              }
              console.log("level_check = " + level_check)
              console.log("stage_check = " + stage_check)
              var next_level = (level_data.levels[level_check] != undefined) ? level_data.levels[level_check][stage_check] : undefined
              var next_star_lock = (next_level != undefined) ? next_level.split('\n')[8] : undefined

              // stage menu if beat last stage (already)
              if (player_stage == level_data.levels[player_level].length ||
                  player_progress[player_level][0] >= level_data.levels[player_level].length) {

                winlose_menu_items.push(continue_menu_item)              

                // add MenuItem for each stage of this level
                for (var s = 0; s < level_data.levels[player_level].length; s++) {
                  var stage_menu_item = new MenuItem(winlose_menu,player_level.toString() + "-" + (s+1).toString(), function() {
                    player_stage = parseInt(this.text[2])
                    console.dir(this)
                    jaws.start(Game)
                  })
                  winlose_menu_items.push(stage_menu_item)
                }
                if (level_edit) {
                  winlose_menu_items.push(restart_menu_item)
                  restart_menu_item.text = "Back to Editor"
                  restart_menu_item.action = function() {
                    level_edit_play = false
                    jaws.start(Game)
                  }
                }
                // add Back to Menu item
                winlose_menu_items.push(back_menu_item)
                winlose_menu.items = winlose_menu_items
                winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

                next_level = (level_data.levels[LEVEL_PATHS[player_path][parseInt(player_level)]] != undefined) ?
                  level_data.levels[LEVEL_PATHS[player_path][parseInt(player_level)]][0] : undefined

                // next_level = (level_data.levels[parseInt(player_level) + 1] != undefined) ? level_data.levels[parseInt(player_level) + 1][0] : undefined
                next_star_lock = (next_level != undefined) ? next_level.split('\n')[8] : undefined       

                // continue
                if (next_level != undefined && !level_edit) {
                  console.log("killed my wife")
                  winlose_menu.items[0].active = true
                  if (next_star_lock == undefined || starTotal() >= next_star_lock)
                    winlose_menu.items[0].locked = false
                  else
                    winlose_menu.items[0].locked = true
                  winlose_menu.items[0].text = "Cont. to " + (parseInt(player_level) + 1) + "-1"
                  winlose_menu.items[0].action = function() {
                    player_level++
                    player_stage = 1
                    jaws.start(Game)
                  }
                } else if (next_level == undefined) { 
                  if (player_stage == 6)
                    setTimeout(function() {window.alert(thanks_for_coming)}, 500)
                }

                // default index
                if (player_progress[player_level][0] >= player_stage)
                  winlose_menu.index = player_stage                         

              // beating puzzles for the first time
              } else {

                winlose_menu_items.push(continue_menu_item)
                winlose_menu_items.push(restart_menu_item)
                if (level_edit) {
                  restart_menu_item.text = "Back to Editor"
                  restart_menu_item.action = function() {
                    level_edit_play = false
                    jaws.start(Game)
                  }
                }
                winlose_menu_items.push(back_menu_item)
                winlose_menu.items = winlose_menu_items
                winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

                // continue
                if (next_level != undefined) {
                  winlose_menu.items[0].active = true
                }

                // default index
                // restart if beat this level already
                if (player_progress[player_level][0] >= player_stage)
                  winlose_menu.index = 1
              }

              // update player progress
              if (player_progress[player_level][0] < player_stage)
                player_progress[player_level][0] = parseInt(player_stage)

              // update best time and score for this level-stage
              var this_level_progress = player_progress[player_level][1]
              var this_stage_progress = this_level_progress[player_stage.toString()]
              if (this_stage_progress == undefined) // create new array if stage newly beaten
                this_stage_progress = this_level_progress[player_stage.toString()] = ["99:99",0]
              if (player.timer.clock_text < this_stage_progress[0]) {
                this_stage_progress[0] = player.timer.clock_text
                if (puzzle_data != undefined)
                  puzzle_data.items[0].color = "Grey"
              }
              if (player.score > this_stage_progress[1]) {
                this_stage_progress[1] = player.score
                if (puzzle_data != undefined)
                  puzzle_data.items[1].color = "Grey"
              }

              console.log("player_progress = ")
              console.dir(player_progress)

              // update player_save data and cookie data
              updateSaveAndCookie()

            } else if (game_end == "L") {

              // drop player hand
              player.drop(player.board.stacks[player.x],player.hand.items.length)

              // but don't add this action to the undo_state
              undo_hand.pop()
              undo_board.pop()


              winlose_menu.y = winlose_data.y
              winlose_menu_items.push(undo_menu_item)
              winlose_menu_items.push(restart_menu_item)
              restart_menu_item.action = function () {
                jaws.start(Game) // no need to save record here
              }
              winlose_menu_items.push(back_menu_item)
              winlose_menu.items = winlose_menu_items
              winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

              // change menu item text
              if (marathon) {
                undo_menu_item.active = false
                restart_menu_item.text = "Play again"
              }


              winlose_menu.title = (marathon) ? "GAME OVER!" : "YOU LOSE!"

              winlose_menu.index = 1

            }

            if (marathon) {

              // update marathon progress
              if (player.timer.clock_text > marathon_progress[0])
                marathon_progress[0] = player.timer.clock_text
              if (player.score > marathon_progress[1])
                marathon_progress[1] = player.score

              // display score sheet
              var score_sheet_items = new Array()
              score_sheet_data.active = true

              // sheet item for each n-chain
              var n_chains = []
              for (var key in player.score_sheet["chains"]) {
                if (key == 1)
                  continue
                else
                  n_chains.push(parseInt(key))
              }
              n_chains.sort(function(a,b){return b-a})
              for (var c=0; c<n_chains.length; c++) {
                score_sheet_items.push(new MenuItem(score_sheet_data,n_chains[c].toString()+"-Chains:       "+ player.score_sheet["chains"][n_chains[c].toString()],function() {return}))
                score_sheet_items[score_sheet_items.length-1].color = "Orange"            
              }

              // sheet item for each n-combo
              var n_combos = []
              for (var key in player.score_sheet["combos"]) {
                if (key == 1)
                  continue
                else
                  n_combos.push(parseInt(key))
              }
              n_combos.sort(function(a,b){return b-a})
              for (var c=0; c<n_combos.length; c++) {
                score_sheet_items.push(new MenuItem(score_sheet_data,n_combos[c].toString()+"-Combos:       "+ player.score_sheet["combos"][n_combos[c].toString()],function() {return}))
                score_sheet_items[score_sheet_items.length-1].color = "Blue"
              }


              score_sheet_items.push(new MenuItem(score_sheet_data,"Robots cleared: " + player.score_sheet["robots"],function() {return}))
              score_sheet_items[score_sheet_items.length-1].color = "Brown"
              score_sheet_items.push(new MenuItem(score_sheet_data,"Potions brewed: " + player.score_sheet["potions"],function() {return}))
              score_sheet_items[score_sheet_items.length-1].color = "Brown"
              score_sheet_items.push(new MenuItem(score_sheet_data,"Blocks melted:  " + player.score_sheet["blocks"],function() {return}))
              score_sheet_items[score_sheet_items.length-1].color = "Brown"
              // score_sheet_items.push(new MenuItem(score_sheet_data,"Zonks zonked:   0",function() {return}))

              score_sheet_data.items = score_sheet_items

              winlose_menu.setup(winlose_menu.x,ITEM_WIDTH,winlose_menu.width)
              score_sheet_data.center(player.board.board.x,player.board.board.width)
              score_sheet_data.setup(score_sheet_data.x,winlose_menu.y + winlose_menu.height,score_sheet_data.width)

              // update player_save data and cookie data
              updateSaveAndCookie()
            }

            var record = buildRecordString(this,game_end)
            saveRecord(record)

          } else {

            replay_menu.active = true
            replay_menu.index = (replay_index < replay_records.length - 1) ? (replay_index + 1) : replay_index
            replay_menu.controls(replay_menu)
            jaws.on_keydown(["esc"], function() {
              jaws.start(MainMenu)
            })

          }

          // color timer to be red to indicate game end
          screen_data.index = 1
        }

        // check for items of specified type,color that are breaking
        this.checkForBreaking = function(type,color) {

          console.log("checking for breaking robot of color: " + color)

          for (var i=0; i < this.stacks.length; i++) {

            var this_stack = this.stacks[i]

            // check each item of the stack
            for (var j=0; j < this_stack.items; j++) {
              var this_item = this_stack.items[j]
              if (this_item.type == type && this_item.color == color) {
                console.log("breaking robot of color (" + color + ") found!")
                return true
              }
            }

          }

          return false

        }

        // update all stacks and effects in this board
        this.update = function() {

          // update stacks
          for (var s=0; s<this.stacks.length; s++) {
            this.stacks[s].update()
          }

          // update effects
          for (var e=0; e<this.effects.length; e++) {
            this.effects[e].update()
          }
        }

        // draw all stacks and effects on this board
        this.draw = function() {

          // draw pause menu
          if (pause) {
            jaws.context.fillStyle = PURPLE_HEX //"Black"
            jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)
            jaws.context.fillStyle = "rgba(10,0,10," + this.undo_alpha + ")"
            jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)
            pause_menu.draw()
            return
          }

          // draw background
          jaws.context.fillStyle = PURPLE_HEX //"Black"
          jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)

          // draw undo background
          if (player_undid) {
            if (this.undo_alpha < 1)
              this.undo_alpha += .05
            jaws.context.fillStyle = "rgba(10,0,10," + this.undo_alpha + ")"
            jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH,this.board.width,this.board.height)            
          }

          // draw all stacks in this board and containing items
          for (var i=0; i < this.stacks.length; i++) {
            this.stacks[i].draw()
          }

          // hide next random items
          var alpha = player.timer.raise_level_timer/raise_level_time/2 + .5
          jaws.context.fillStyle =  "rgba(0,0,0," + alpha + ")"//"rgba(112,0,84," + alpha + ")"
          jaws.context.fillRect(ITEM_WIDTH,ITEM_WIDTH+this.board.height,this.board.width,ITEM_WIDTH)

          // draw all effects on this board
          for (var e=0; e < this.effects.length; e++) {
            this.effects[e].draw()
          }

          // draw winlose menu
          if (game_end != "" && game_end != "R") {
            if (winlose_delay <= 0) {
              if (marathon) {
                score_sheet_data.draw()
              } else
                winlose_data.draw()
              if (replay == null)
                winlose_menu.draw()
              else
                replay_menu.draw()
            }
          } else if (replay_menu != undefined && replay_menu.active) {
            replay_menu.draw()
          }

        }

      }

      /* Constructor for stack */
      function Stack(board,level,x) {

        this.board = board
        this.items = new Array()
        this.level = level
        this.x = x
        this.next_random_item  // string of form "type|color" for use in marathon

        // check for flasks touching robots
        this.breakRobots = function(item) {

          var flasks_to_clear = new Array()
          var robots_to_clear = new Array()
          var clear_flask = false
          
          var above = this.items[item.y + 1]
          var below = this.items[item.y - 1]

          var splash_order = 0

          item.combo = 0
          item.deathcounter = DEATH_COUNTER_START

          if (item.color == WHITE || item.color == EMPTY)
            return

          // don't break robots if they're already breaking from another potion
          if (above != undefined && above.kill_potion != undefined && above.kill_potion != item)
            return

          // check for robots above
          while (above != undefined && above.type == 2 && ((item.color == GOLD)?(above.color > 2):(above.color == item.color))) {

            above.combo = item.combo = item.combo + 1
            above.deathcounter = DEATH_COUNTER_START
            robots_to_clear.push(above)

            if (!clear_flask) {
              clear_flask = true
              if (item.chain <= 0)
                item.chain++
            }

            // get the bigger chain if flask not in robot sandwich
            if (!item.sandwich) {
              if (item.chain > above.chain)
                above.chain = item.chain
              else
                item.chain = above.chain
            } else
              above.chain = item.chain
            
            above.splash_order = splash_order = splash_order + 1

            above = this.items[above.y + 1]

          }

          splash_order = 0

          // check for robots below
          while (below != undefined && below.type == 2 && ((item.color == GOLD)?(below.color > 2):(below.color == item.color))) {

            below.combo = item.combo = item.combo + 1
            below.deathcounter = DEATH_COUNTER_START
            robots_to_clear.push(below)
            
            if (!clear_flask) {
              clear_flask = true
              item.sandwich = true
              if (item.chain <= 0)
                item.chain++
            }

            below.chain = item.chain
            below.splash_order = splash_order = splash_order + 1

            below = this.items[below.y - 1]

          }

          if (clear_flask) {
            flasks_to_clear.push(item)
            this.clearRobotsFlasks(robots_to_clear,flasks_to_clear)
          }



        }

        // find flask and breakRobots()
        this.actionCombo = function(robot) {

          var below = this.items[robot.y - 1]

          // check for robots below
          while (below != undefined) {

            // return the flask to breakRobots()
            if (below.type == 1)
              return below

            below = this.items[below.y - 1]
          }

        }

        // check for matching robots above
        // robot = bottom of the top "bun"
        this.robotSandwich = function(robot,flask) {

          var robots_to_clear = [robot]
          
          var above = this.items[robot.y + 1]

          robot.sandwich = true
          robot.combo = 1
          robot.chain = flask.chain
          robot.deathcounter = flask.deathcounter // sync all death

          // check for robots above
          while (above != undefined && above.type == 2 && ((robot.color == GOLD)?(above.color > 2):(above.color == robot.color))) {

            above.combo = flask.combo = flask.combo + 1
            above.deathcounter = flask.deathcounter // sync all death
            robots_to_clear.push(above)

            if (above.chain > robot.chain)
              robot.chain = above.chain
            else
              above.chain = robot.chain

            above = this.items[above.y + 1]

          }       

          this.clearRobotsFlasks(robots_to_clear,[])   

        }

        // check if the stack contains matches (3 or more consecutive blocks of same color)
        // return true if matches are found
        this.checkForMatches = function() {

          var match_found = false
          var matches = new Array()
          var items = this.items
          var match
          var item

          console.log("checking for matches")

          // loop through each item on the stack, adding them to matches[] array
          for (var i = 0; i < items.length; i++) {

            item = items[i]

            if (item.type == 1 && !item.breaking) {
              this.breakRobots(item)
            }

            matches.push(item)
            match = matches[0]

            if (!match.matchBlocks(item)) {
              matches.pop()
              if (matches.length >= 3) {
                console.log("matches found!!! " + matches.length + " of color (" + matches[0].color + ")")
                this.matchesFound(matches)
                match_found = true
                // melt_audio.stop()
                // removeFromPlayingSounds(melt_audio)
                // if (!mute)
                //   melt_audio.play()
              }

              matches = new Array()
              matches.push(item)
            }

            if (i == items.length - 1) {
              if (matches.length >= 3) {
                console.log("matches found!!! " + matches.length + " of color (" + matches[0].color + ")")
                this.matchesFound(matches)
                match_found = true
                // melt_audio.stop()
                // removeFromPlayingSounds(melt_audio)
                // if (!mute)
                //   melt_audio.play()
              }
            }
          }

          return match_found

        }

        // break matches and update their combos/chains
        this.matchesFound = function(matches) { // matches, an array of blocks

          // keep track of block with largest chain
          var chain = 0

          // break matches
          for (var i=0; i<matches.length; i++) {

            var match = matches[i]
            match.breaking = true
            match.chain += 1

            // update chain
            if (match.chain > chain) chain = match.chain
            match.chain = chain

            if (i==0) {
              match.last_in_chain = true
              match.combo = matches.length
            }

          }

          // ensure that all matches have same chain
          this.setChain(matches,chain)

          console.log("breaking with chain = " + chain)

          console.log("matches:")
          for(var i=0; i<matches.length; i++) {
            console.log(matches[i].breaking)
          }

          return chain

        }

        // sets chain for all items passed in
        this.setChain = function(items,chain) {

          // go through each item and set its chain
          for (var i=0; i<items.length; i++) {
            var item = items[i]
            item.chain = chain
          }

        }

        this.removeItem = function(old_item) {

          console.log("removing (" + old_item.type + ") of color (" + old_item.color + ")" + " with chain = " + old_item.chain + ", y = " + old_item.y)

          // remove old item from items array
          this.items.splice(old_item.y,1)

          // update sprite destination for each item above old_item
          Y_SPEED = FAST
          for (var i=0; i<this.items.length; i++) {
            var item = this.items[i]
            if (item.y > old_item.y) item.y -= 1
              item.sprite.dy = this.board.posy(item.y)
          }

          // update board count
          if (old_item.type == 0) {
            this.board.block_count[old_item.color]--
          } else if (old_item.type == 1) {
            this.board.flask_count[old_item.color]--
          } else if (old_item.type == 2) {
            if (old_item.color > 2) {
              this.board.robot_count[4]--  // all armored robots count as yellow
              console.log("decrement yellow robot count")
            }
            else
              this.board.robot_count[old_item.color]--
          }

          if (level_edit && !level_edit_play)
            return

          // check for win/lose only when blocks and robots are broken since flasks break first
          // but only check when items aren't breaking
          if (!this.board.stacksBreaking()) {
            if (old_item.type == 0 || old_item.type == 1) {
              // if (old_item.color != WHITE)
                this.board.checkWinLose() // check for win/lose conditions
            } else if (old_item.type == 2) {
              // make sure that there are no other robots in the process of being removed
              var below = this.items[old_item.y - 1]
              if(below == undefined) {
                this.board.checkWinLose()
              } else {
                // if there is an item below, check if it is a robot of the same color
                if (!(below.type == 2 && below.color == old_item.color && below.breaking)) {
                  this.board.checkWinLose()
                }
              }

            }
          }

          console.log("block_count = " + this.board.block_count)
          console.log("flask_count = " + this.board.flask_count)
          console.log("robot_count = " + this.board.robot_count)

          this.checkForMatches()

          // show combo/chain effects for blocks
          if (old_item.type == 0) {

            // show chain effects and calculate score if last in chain
            if (old_item.last_in_chain) {
              player.addScore(old_item.type,old_item.combo,old_item.chain)
              this.board.effects.push(new ChainEffect(this,old_item))
            }

            // update player's score sheet
            player.score_sheet["blocks"]++

            // // stop sound effects
            // if (old_item.type == 1) {
            //   console.log("stop sound effect")
            //   // console.dir(old_item.break_audio)
            //   // break_audio.stop()
            //   // removeFromPlayingSounds(break_audio)
            //   if (old_item.chain > 1)
            //     this.board.effects.push(new ChainEffect(this,old_item))
            // }

          // show combo/chain effects for potions
          } else if (old_item.type == 1) {
            player.addScore(old_item.type,old_item.combo,old_item.chain)
            this.board.effects.push(new ChainEffect(this,old_item))

            // update player's score sheet (robots)
            player.score_sheet["robots"] += old_item.combo
          } 

        }

        // only used by level editor
        this.removeItems = function(old_items) {

          for (var i=0; i<old_items.length; i++) {

            this.removeItem(old_items[i])

          }
        }

        this.shedRobot = function(old_item) {

          // sanity check!!!!!!!
          if (old_item.type != 2)
            return

          console.log("shedding (" + old_item.type + ") of color (" + old_item.color + ")")

          // remove old item from items array
          // replace robot with color of (old_item.color - 3)
          var new_item = new Item(this,2,old_item.color-3,old_item.x,old_item.y)
          new_item.active = true
          new_item.chain = old_item.chain
          this.items.splice(old_item.y,1,new_item)

          // update yellow robot count
          this.board.robot_count[4]--

          // check for win/lose only when blocks and robots are broken since flasks break first
          // but only check when items aren't breaking
          if (!this.board.stacksBreaking()) {
            if (old_item.type == 0 || old_item.type == 1) {
              // if (old_item.color != WHITE)
                this.board.checkWinLose() // check for win/lose conditions
            } else if (old_item.type == 2) {
              // make sure that there are no other robots in the process of being removed
              var below = this.items[old_item.y - 1]
              if(below == undefined) {
                this.board.checkWinLose()
              } else {
                // if there is an item below, check if it is a robot of the same color
                if (!(below.type == 2 && below.color == old_item.color && below.breaking)) {
                  this.board.checkWinLose()
                }
              }

            }
          }

          console.log("block_count = " + this.board.block_count)
          console.log("flask_count = " + this.board.flask_count)
          console.log("robot_count = " + this.board.robot_count)

          this.checkForMatches()

        }

        // check if there are items breaking on this stack
        this.itemsBreaking = function() {

          var breaking = false
          var item

          for (var i=0; i<this.items.length; i++) {
            item = this.items[i]
            if (item.breaking) {
              breaking = true
              break
            }
          }

          return breaking

        }

        // clear array of robots followed by array of flasks
        this.clearRobotsFlasks = function(robots_to_clear,flasks_to_clear) {

          var kill_potion = flasks_to_clear[0]

          for (var r = 0; r < robots_to_clear.length; r++) {

            var this_robot = robots_to_clear[r]

            this_robot.breaking = true

            this_robot.kill_potion = kill_potion

            // put splashes here
            var robot_delay = this_robot.deathcounter + this_robot.splash_order
            if (this_robot.splash == undefined)
              this.board.effects.push(new Splash(this,this_robot.type,this_robot.color,this_robot.x,this_robot.y,this.board.effects.length,robot_delay))
            else
              this_robot.splash.delay = robot_delay

            // determine which sprites to use
            var death_color = "RED"
            if (this_robot.color == 1 || this_robot.color == 4)
              death_color = "YELLOW"
            else if (this_robot.color == 2 || this_robot.color == 5)
              death_color = "PURPLE"

            // update sprite data
            this_robot.sprite = new jaws.Sprite({x:this_robot.stack.board.posx(this_robot.x), y:this_robot.stack.board.posy(this_robot.y), anchor: "left"})
            var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + death_color + "_DEATH.gif", frame_size: [40,40], frame_duration: 20})
            this_robot.sprite.anim_default = anim.slice(0,6)

            var rand_color = Math.floor(Math.random()*WHITE)
            for (var c=0; c < rand_color; c++)
              this_robot.sprite.setImage(this_robot.sprite.anim_default.next())

            this_robot.sprite.dx = this_robot.stack.board.posx(this_robot.x)
            this_robot.sprite.dy = this_robot.stack.board.posy(this_robot.y)

          }

          for (var f = 0; f < flasks_to_clear.length; f++) {

            var this_flask = flasks_to_clear[f]

            this_flask.breaking = true

            // put splashes here
            if (this_flask.splash == undefined)
              this.board.effects.push(new Splash(this,this_flask.type,this_flask.color,this_flask.x,this_flask.y,this.board.effects.length,this_flask.deathcounter))
            else
              this_flask.splash.delay = this_flask.deathcounter

            // update sprite data
            this_flask.sprite = new jaws.Sprite({x:this_flask.stack.board.posx(this_flask.x),y:this_flask.stack.board.posy(this_flask.y), anchor: "left"})
            var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_SPRITES.gif", frame_size: [40,40], frame_duration: 20 + Math.floor(Math.random()*((60-20) + 1))})
            this_flask.sprite.anim_default = anim.slice(0,6)

            this_flask.sprite.dx = this_flask.stack.board.posx(this_flask.x)
            this_flask.sprite.dy = this_flask.stack.board.posy(this_flask.y)

            // stop flask's sound effects
            // break_audio.stop()
            // removeFromPlayingSounds(break_audio)

            // // play robot breaking sound effects
            // if (!mute)
            //   break_audio.play()



          }

        }

        // Stack .update() updates each item in the stack
        // update animations, counters, and chains
        // remove items if their death counters set off
        this.update = function() {

          // make sure to break flask last or the game will think lose condition is met
          // put flasks and robots to break into respective arrays
          var flasks_to_clear = new Array()
          var robots_to_clear = new Array()

          // copy stack items into new array so we can loop through all items
          // even if items are removed
          var stack_items = this.items.slice()

          // update each item
          for(var i=0; i<stack_items.length; i++) {
            var item = stack_items[i]
            var above = stack_items[i + 1]

            // for all items breaking (except UNSTABLE flasks)
            // NOTE: eventually will make updateX for X for any type of item
            // animation updates will happen there
            if (item.breaking) {

              // breaking animation
              if (item.type == 0) {
                var old_width = item.sprite.width
                if (old_width > 1) {
                  item.sprite.width = old_width*.75
                  item.sprite.dx += (old_width - item.sprite.width)/2
                } else {
                  item.sprite.dx -= item.sprite.width / 2
                  item.sprite.width = old_width*2
                }

              // animate breaking flasks and robots
              } else {
                item.sprite.setImage(item.sprite.anim_default.next())
              }

              // update deathcounter
              item.deathcounter -= 1

              // add chain to items above
              if (above != undefined && !above.breaking) {
                if (item.type == 0) {
                  above.chain = item.chain + ((above.type != 0)?1:0)
                } else {
                  if (above.type != 0)
                    above.chain = item.chain + 1
                }
                console.log("item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] passing chain (" + above.chain + ") to item [" + TYPES[above.type] + "|" + COLORS[above.color] + "] above")
              }

            }

            // update items in transitory animation
            if (item.sleepcounter > 0) {
              item.sleepcounter -= 1
            }

            // remove item if death counter has expired
            if (item.deathcounter <= 0) {

              // do not destroy blue, yellow, orange robots
              if(item.type == 2 && (item.color == 3 || item.color == 4 || item.color == 5)) {
                this.shedRobot(item)
                console.log("shedRobot")
              }
              else {
                this.removeItem(item)
              }

            }

            // animate robots
            if (item.type == 1 || item.type == 2 || item.type == 3) {
              item.sprite.setImage(item.sprite.anim_default.next())
            }

            // update item sprite positions
            spriteMove(item.sprite,X_SPEED,Y_SPEED)


            // check for breaking conditions
            // skip items on player hand
            if (item.stack != player.hand && !item.breaking) {

              if (level_edit && !level_edit_play)
                continue

              // update flasks
              if (item.type == 1) {

                item.updateFlask(above)

              }

              // update robots
              // check for yellow robots
              else if (item.type == 2) {

                // clear robots

                var above = stack_items[i + 1]
                var below = stack_items[i - 1]
                if (above != undefined) {

                  // break robot and same-colored flask above
                  // if (above.sleepcounter == 0 && above.color == ((item.color > 2) ? 4 : item.color) && above.type == 1) {

                  //   // item.breaking = true
                  //   // above.breaking = true

                  //   robots_to_clear.push(item)
                  //   flasks_to_clear.push(above)

                  //   above.chain += 1
                  //   item.chain = above.chain
                  //   item.splash_order = above.splash_order + 1

                  //   console.log("(" + above.color + ") flask breaking robot of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  // // break if robot above is breaking
                  // } else 
                  if (above.type == 2 && ((item.color > 2) ? (above.color > 2):(above.color == item.color)) && above.breaking) {

                    // item.breaking = true

                    robots_to_clear.push(item)

                    item.chain = above.chain
                    console.log("item [" + TYPES[above.type] + "|" + COLORS[above.color] + "] passing chain (" + above.chain + ") to item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] below")
                    item.splash_order = above.splash_order + 1

                    console.log("robot combo of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  }
                }

                if (below != undefined) {

                  // break robot and same-colored flask below
                  if (below.sleepcounter == 0 && below.color == ((item.color > 2) ? 4 : item.color) && below.type == 1) {

                    if (below.sandwich) {
                      // this.robotSandwich(item,below)
                      this.breakRobots(below)
                    }

                    // robots_to_clear.push(item)
                    flasks_to_clear.push(below)

                    // item.combo = below.combo + 1

                    // item.chain += 1
                    // below.chain = item.chain

                    item.splash_order = below.splash_order + 1

                    below.chain = item.chain
                    console.log("item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] passing chain (" + item.chain + ") to item [" + TYPES[below.type] + "|" + COLORS[below.color] + "] below")

                    console.log("(" + below.color + ") flask breaking robot of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  // break if robot below is breaking (action combo)
                  } else if (below.type == 2 && ((item.color > 2) ? (below.color > 2):(below.color == item.color)) && below.breaking) {

                    var flask = this.actionCombo(item)

                    this.breakRobots(flask)

                    // item.action_combo = (below.action_combo)?false:true
                    // item.combo = below.combo + 1
                    // robots_to_clear.push(item)

                    // item.chain = below.chain
                    console.log("item [" + TYPES[below.type] + "|" + COLORS[below.color] + "] passing chain (" + below.chain + ") to item [" + TYPES[item.type] + "|" + COLORS[item.color] + "] above")
                    item.splash_order = below.splash_order + 1

                    console.log("robot combo of color (" + item.color + ") with chain = " + item.chain + " and splash_order = " + item.splash_order)

                  }
                }
              }
            }
          }

          this.clearRobotsFlasks(robots_to_clear,flasks_to_clear)

        }

        this.draw = function() {

          // // draw all items on stack and next random item
          // for (var i=0; i<this.items.length;i++) {
          //   this.items[i].draw()
          // }
          if (!(marathon || sprint)) {
            for (var i=0; i<this.items.length;i++) {
              this.items[i].draw()
            }
          } else {
            // flash stack when full and player in danger
            var this_stack_full = (this.items.length + ((this.board.player.x != this.x) ? 0 : this.board.player.hand.items.length) == BOARD_HEIGHT)
            var player_timer = this.board.player.timer
            // var danger_time = (player_timer.raise_level_timer < raise_level_time/4) ? ((player_timer.ticker%8==0) ? true : false) : false
            var danger_time = (player_timer.ticker%8==0) ? true : false
            if (!this_stack_full || !danger_time || this.itemsBreaking() || game_end != "") {
              for (var i=0; i<this.items.length;i++) {
                this.items[i].draw()
              }
            }
          }
          if (this.level >= 0 && (marathon || sprint)) {
            this.next_random_item.draw()
          }
        }

      }

      /* Constructor for item */
      function Item(stack,type,color,x,y) {

        console.log("making new item of type(" + type + "), color(" + COLORS[color] + ")")

        // an item has type and color
        this.stack = stack
        this.type = type
        this.color = color
        this.x = x             // x position on the board
        this.y = y             // y position on the board
        this.active = false
        this.breaking = false
        this.deathcounter = DEATH_COUNTER_START
        this.sleepcounter = 0  // used for transitory animations
                               // (eg: potion filling up, items exploding, etc.)
        this.combo = 0
        this.chain = 0
        this.last_in_chain = false
        this.action_combo = false
        this.splash_order = 0
        this.sandwich = false

        this.splash = undefined

        var board = stack.board

        // set appropriate sprite for this item
        if (this.type == 0) {
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y),image:"./static/images/" + COLORS[color] + ".gif",anchor:"left"})
          board.block_count[color] += 1
        } else if (this.type == 1) {

          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), anchor:"left"})
          var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_" + COLORS[this.color] + ".gif", frame_size: [40,40], frame_duration: 100})
          this.sprite.anim_default = anim.slice(0,5)
          this.sprite.setImage(this.sprite.anim_default.next())

          board.flask_count[color] += 1
        } else if (this.type == 2) {
          // create sprite for this robot
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), anchor: "left"})
          var anim = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + COLORS[this.color] + ".gif", frame_size: [40,40], frame_duration: 100})
          this.sprite.anim_default = anim.slice(0,5)
          this.sprite.setImage(this.sprite.anim_default.next())

          // determine which sprites to use
          var death_color = "RED"
          if (this.color == 1 || this.color == 4)
            death_color = "YELLOW"
          else if (this.color == 2 || this.color == 5)
            death_color = "PURPLE"
          var dead_sprites = new jaws.Animation({sprite_sheet: "./static/images/ROBOT_" + death_color + "_DEATH.gif", frame_size: [40,40], frame_duration: 20})
          this.sprite.setImage(dead_sprites.slice(
            (death_color=="RED"||this.color==1)?this.color:((this.color==2)?4:3),
            6).next())

          if (this.color > 2)
            board.robot_count[4] += 1
          else
            board.robot_count[this.color] += 1
        } else if (this.type == 3) {
          this.sprite = new jaws.Sprite({x:this.stack.board.posx(x),y:this.stack.board.posy(y), anchor:"left"})
          var anim = new jaws.Animation({sprite_sheet: "./static/images/CAULDRON.gif", frame_size: [40,40], frame_duration: 100})
          this.sprite.anim_default = anim.slice(0,4)
          this.sprite.setImage(this.sprite.anim_default.next())
          board.cauldron_count++
        }

        this.sprite.width = ITEM_WIDTH
        this.sprite.height = ITEM_WIDTH
        this.sprite.dx = this.stack.board.posx(x)
        this.sprite.dy = this.stack.board.posy(y)

        this.matchBlocks = function(item) { // item to check if this matches with

          if (!this.breaking && this.type == 0 && item.type == this.type && item.color == this.color)
            return true

          return false

        }

        // update all flask items, called by Stack's .update()
        // above: the item above this flask, if any
        this.updateFlask = function(above) {

          // sanity check
          if (this.type != 1) return

          // check if blocks are breaking above
          // fill flask with potion of that color
          if (above != undefined) {
            if (above.breaking && above.type == 0) {

              // fill up the flask with potion of breaking color
              // only if the flask is not empty
              if (this.color == WHITE && above.color != WHITE) {
                this.color = above.color
                this.chain = above.chain + 1
                above.combo++
                this.sleepcounter = 40
                console.log("sleepcounter = " + this.sleepcounter)

                // update player's score sheet
                player.score_sheet["potions"]++

                // update sprite data
                this.sprite = new jaws.Sprite({x:this.stack.board.posx(this.x),y:this.stack.board.posy(this.y), anchor:"left"})
                var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_" + COLORS[this.color] + ".gif", frame_size: [40,40], frame_duration: 100})
                this.sprite.anim_default = anim.slice(0,5)
                this.sprite.setImage(this.sprite.anim_default.next())

                this.sprite.dx = this.stack.board.posx(above.x)
                this.sprite.dy = this.stack.board.posy(above.y - 1)

                // update board count
                this.stack.board.flask_count[WHITE]--
                this.stack.board.flask_count[above.color]++

                // play sound effect for brewing
                // brew_audio.stop()
                // removeFromPlayingSounds(brew_audio)
                // melt_audio.stop()
                // removeFromPlayingSounds(melt_audio)
                // white_audio.stop()
                // removeFromPlayingSounds(white_audio)
                // console.log("brewing color potion")
                // if (!mute) {
                //   brew_audio.play()
                //   white_audio.play()
                // }

              // only accept white blocks above if empty
              // break if other colors brewed
              } else if (this.color == EMPTY) {

                if (above.color == WHITE) {

                  this.color = above.color
                  this.chain = above.chain
                  above.combo++
                  this.sleepcounter = 40
                  console.log("sleepcounter = " + this.sleepcounter)

                  // update player's score sheet
                  player.score_sheet["potions"]++

                  // update sprite data
                  this.sprite = new jaws.Sprite({x:this.stack.board.posx(this.x),y:this.stack.board.posy(this.y), anchor:"left"})
                  var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_" + COLORS[this.color] + ".gif", frame_size: [40,40], frame_duration: 100})
                  this.sprite.anim_default = anim.slice(0,5)
                  this.sprite.setImage(this.sprite.anim_default.next())

                  this.sprite.dx = this.stack.board.posx(above.x)
                  this.sprite.dy = this.stack.board.posy(above.y - 1)

                  // update board count
                  this.stack.board.flask_count[EMPTY]--
                  this.stack.board.flask_count[above.color]++

                  // play sound effect for brewing
                  // white_audio.stop()
                  // removeFromPlayingSounds(white_audio)
                  // melt_audio.stop()
                  // removeFromPlayingSounds(melt_audio)
                  // console.log("brewing white potion")
                  // if (!mute)
                  //   white_audio.play()

                // melting colored blocks over empty flask creates an unstable reaction
                } else {

                  var this_stack = this.stack.items

                  console.log("this_stack:")
                  for (var i=this_stack.length-1; i > 0; i--) {
                    console.log (this_stack[i])
                  }

                  this.color = UNSTABLE
                  this.breaking = true

                  // put splashes here
                  this.stack.board.effects.push(new Splash(this.stack,this.type,this.color,this.x,this.y,this.stack.board.effects.length,this.deathcounter))

                  // update sprite data
                  this.sprite = new jaws.Sprite({x:this.stack.board.posx(above.x),y:this.stack.board.posy(above.y - 1), anchor: "left"})
                  var anim = new jaws.Animation({sprite_sheet: "./static/images/POTION_SPRITES.gif", frame_size: [40,40], frame_duration: 20})
                  this.sprite.anim_default = anim.slice(0,6)

                  this.sprite.dx = this.stack.board.posx(above.x)
                  this.sprite.dy = this.stack.board.posy(above.y - 1)

                  // update board count
                  this.stack.board.flask_count[EMPTY]--
                  this.stack.board.flask_count[this.color]++

                  // play sound effect for unstable reaction
                  // break_audio.stop()
                  // removeFromPlayingSounds(break_audio)
                  // console.log("brewing unstable potion")
                  // if (!mute)
                  //   break_audio.play()
                }

              }

            }
          }

        }

        // player name and timer
        this.draw = function() {

          if (this.y < 0)
            this.sprite.y = this.stack.board.posy(this.y)
          else
            this.sprite.dy = this.stack.board.posy(this.y)

          this.sprite.draw()
        }
      }

      function RobotCombo(combo) {

        // sanity check
        if (combo < 1) {
          return 0
        }

        if (combo == 1)
          return ROB_SCORE
        else
          return (RobotCombo(combo - 1) + (combo*ROB_SCORE))

      }

      function ChainEffect(stack,item) {

        this.stack = stack
        this.combo = (item.type == 0)?item.combo:(RobotCombo(item.combo))
        this.chain = item.chain
        this.item = item
        this.speed = 1
        this.deathcounter = 60

        var action_offset = (item.action_combo || (item.type==2 && item.sandwich)) ? -80 : 0

        this.index = stack.board.effects.length

        this.chain_sprite = new jaws.Sprite({
          x: item.sprite.x,
          y: item.sprite.y + action_offset,
          image: "./static/images/CHAIN.gif",
          anchor: "left"
        })
        this.combo_sprite = new jaws.Sprite({
          x: item.sprite.x,
          y: item.sprite.y + 21 + action_offset,
          image: "./static/images/BLUE.gif",
          anchor: "left"
        })        

        this.combo_sprite.width = 30
        this.combo_sprite.height = 20

        this.removeChainEffect = function() {
          this.stack.board.effects.splice(this.index,1)

          // reset indices
          for (var i = this.index; i < this.stack.board.effects.length; i++) {
            var this_effect = this.stack.board.effects[i]
            this_effect.index = i
          }

        }

        this.update = function() {
          this.chain_sprite.y -= this.speed
          this.combo_sprite.y -= this.speed
          this.deathcounter -= 1
        }

        this.draw = function() {

          if (this.deathcounter < 0) {
            this.removeChainEffect()
            return
          }

          if (this.chain > 1) {
  
            this.chain_sprite.draw()

            jaws.context.font = MENU_FONT
            jaws.context.lineWidth = 10
            jaws.context.fillStyle =  "White"
            jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
            jaws.context.fillText("^" + this.chain, this.chain_sprite.x + 6, this.chain_sprite.y + 16)

          }

          if (this.combo > 0) {

            this.combo_sprite.draw()

            jaws.context.font = MENU_FONT
            jaws.context.lineWidth = 10
            jaws.context.fillStyle =  "White"
            jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
            jaws.context.fillText(this.combo, this.combo_sprite.x + 11, this.combo_sprite.y + 16)

          }
        }

      }

      /* Constructor for Splashes */
      function Splash(stack,type,color,x,y,index,delay) {

        // console.log("adding splash")

        this.stack = stack // the stack this splash comes from
        this.type = type   // type of the item destroyed
        this.color = color // color of the item destroyed
        this.x = x
        this.y = y
        this.index = index
        this.delay = delay // delay animation until counter goes to 0

        // set appropriate sprite for this Splash
        if (type == 1)
          this.sprite_sheet = new jaws.SpriteSheet({
            image: "./static/images/POTION_SPLASH.gif", frame_size: [20,20]})
        else if (type == 2)
          this.sprite_sheet = new jaws.SpriteSheet({
            image: "./static/images/ROBOT_" + COLORS[color] + "_SPLASH.gif", frame_size: [20,20]})

        this.sprite1 = new jaws.Sprite({x:this.stack.board.posx(x), y:this.stack.board.posy(y), image: this.sprite_sheet.frames[0]})
        this.sprite2 = new jaws.Sprite({x:this.stack.board.posx(x)+20, y:this.stack.board.posy(y), image: this.sprite_sheet.frames[1]})
        this.sprite3 = new jaws.Sprite({x:this.stack.board.posx(x), y:this.stack.board.posy(y)+20, image: this.sprite_sheet.frames[2]})
        this.sprite4 = new jaws.Sprite({x:this.stack.board.posx(x)+20, y:this.stack.board.posy(y)+20, image: this.sprite_sheet.frames[3]})

        // determine item this splash belongs to
        this.stack.items[y].splash = this

        this.initSprite = function(sprite, splash, x_offset, y_offset) {

          x_offset = typeof x_offset !== 'undefined' ? x_offset : 0;
          y_offset = typeof y_offset !== 'undefined' ? y_offset : 0;

          sprite.x0 = sprite.dx = this.stack.board.posx(splash.x) + x_offset
          sprite.y0 = sprite.dy = this.stack.board.posy(splash.y) + y_offset
          sprite.t = 0

        }

        this.initSprite(this.sprite1, this)
        this.initSprite(this.sprite2, this, 20)
        this.initSprite(this.sprite3, this, 0, 20)
        this.initSprite(this.sprite4, this, 20, 20)

        this.spriteExplode = function(sprite, splash, direction) {

          // console.log("spriteExplode")
          sprite.t += 3
          sprite.dy = sprite.y0 + .1 * sprite.t * sprite.t - 4 * sprite.t
          sprite.dx = sprite.x0 + (direction) * sprite.t

        }

        this.spritesOffscreen = function() {

          var sprites = new Array(this.sprite1, this.sprite2, this.sprite3, this.sprite4)
          var offscreen = new Array(false, false, false, false)

          for (var s = 0; s < sprites.length; s++) {

            var this_sprite = sprites[s]
            if (this_sprite.x < 0 || this_sprite.x > jaws.width || this_sprite.y > jaws.height)
              offscreen[s] = true

          }

          if (!([true,true,true,true]<offscreen || offscreen<[true,true,true,true]))
            return true

          return false

        }

        // remove old splash from board's effects array
        this.removeSplash = function(old_splash) {
          this.stack.board.effects.splice(old_splash.index,1)

          // reset indices
          for (var i = old_splash.index; i < this.stack.board.effects.length; i++) {
            var this_effect = this.stack.board.effects[i]
            this_effect.index = i
          }

        }

        this.update = function() {

          if (this.delay == 0) {
            console.log("playing break sfx")
            // splash_audio.stop()
            // removeFromPlayingSounds(splash_audio)
            // if (!mute)
            //   splash_audio.play()
          }

          if (this.spritesOffscreen())
            this.removeSplash(this)

          if (this.delay <= 0) {
            // console.log ("updating splash sprites")
            this.spriteExplode(this.sprite1, this, -1)
            this.spriteExplode(this.sprite2, this, 1)
            this.spriteExplode(this.sprite3, this, -.5)
            this.spriteExplode(this.sprite4, this, .5)

            // update splash sprite positions
            spriteMove(this.sprite1,X_SPEED,Y_SPEED)
            spriteMove(this.sprite2,X_SPEED,Y_SPEED)
            spriteMove(this.sprite3,X_SPEED,Y_SPEED)
            spriteMove(this.sprite4,X_SPEED,Y_SPEED)
          }

          this.delay--

        }

        this.draw = function() {

          if (this.delay > 0)
            return

          this.sprite1.draw()
          this.sprite2.draw()
          this.sprite3.draw()
          this.sprite4.draw()

        }

      }

      // replay[frame_ticker] = [player_x,player_y,action,]
      function replayAction(frame_ticker) {
        if (replay[frame_ticker] != undefined) {
          console.log("REPLAY ACTION " + frame_ticker)
          console.dir(replay[frame_ticker])
          var frame = replay[frame_ticker]

          if (frame[2] == "grab") {
            // set player x and y
            player.x = frame[0]
            player.y = frame[1]
            player.grab(player.board.stacks[player.x],frame[3])
          } else if (frame[2] == "drop") {

            var dx = frame[0] - player.x

            player.y = frame[1]
            player.drop(player.board.stacks[player.x],frame[3])
            player.moveX(dx)

          } else if (frame[2] == "move_x") {
            player.control_scheme = 0
            player.moveX(frame[3])
          } else if (frame[2] == "move_y") {
            player.control_scheme = 0
            player.y += frame[3]
          } else if (frame[2] == "click") {
            var click_coordinates = [frame[0],frame[1]]
            player.clickAction(click_coordinates,frame[3])
          }else if (frame[2] == "undo") {
            undoLastMove()
          } else if (frame[2] == "undo_menu") {
            winlose = false
            winlose_menu.active = false
            replay_menu.active = false

            winlose_menu.y = winlose_data.y + winlose_data.height
            winlose_menu.setup(winlose_menu.x,winlose_menu.y,winlose_menu.width)

            // color timer to be red to indicate game end
            screen_data.index = -1
            game_end = ""
            player.controls()
            undoLastMove(true)
          } else if (frame[2] == "raise") {
            player.board.raiseStacks()
          }

          // check if this is the last replay action on the replay array
          replay_actions++

          console.log("replay_actions = " + replay_actions)
          console.log("replay_length = " + replay_length)

          if (replay_actions >= replay_length) {
            replay_menu.active = true
            replay_menu.index = (replay_index < replay_records.length - 1) ? (replay_index + 1) : replay_index
            replay_menu.controls(replay_menu)
            jaws.on_keydown(["esc"], function() {
              jaws.start(MainMenu)
            })
          }
        }
      }

      function Timer(player) {

        this.player = player
        this.minutes = 0
        this.seconds = 0
        this.ticker = 0
        this.frame_ticker = 0
        this.clock_text = "00:00"
        this.raise_level_timer = raise_level_time
        this.raise_level_frequency_timer = 0

        if (cauldron_ticker != 0) {
          this.minutes = Math.floor(cauldron_ticker / 3600)
          this.seconds = Math.floor(cauldron_ticker / 60 % 60)
        }

        // increment the ticker and count the seconds and minutes
        this.update = function() {

          if (replay != null) {
            replayAction(this.frame_ticker)
          }

          // start the timer
          if (game_start && game_end == "") {
            this.ticker++
            this.frame_ticker++
          }
          if (this.ticker >= 60) {
            this.ticker = 0
            this.seconds++
            this.raise_level_frequency_timer++

            if (this.raise_level_frequency_timer >= FREQ_RAISE_LEVEL_TIME) {
              if (raise_level_time > MIN_RAISE_LEVEL_TIME)
                raise_level_time--
              else
                raise_level_time = MAX_RAISE_LEVEL_TIME

              console.log("raise_level_time = " + raise_level_time)
              this.raise_level_frequency_timer = 0
            }

            if ((marathon || sprint) && MAX_RAISE_LEVEL_TIME > 0 && !this.player.board.stacksBreaking())
              this.raise_level_timer--

          }
          if (this.seconds >= 60) {
            this.seconds = 0
            this.minutes++
          }
          if (this.raise_level_timer==0) {

            if (!this.player.board.stacksFull()) {
              this.player.board.raiseStacks()
            } else {
              this.player.board.raiseStacks()
            }

            this.raise_level_timer = raise_level_time
            console.log("raise_level_time = " + raise_level_time)
          }

          var min_text = (this.minutes < 10) ? "0" + this.minutes : this.minutes
          var sec_text = (this.seconds < 10) ? "0" + this.seconds : this.seconds

          this.clock_text = min_text + ":" + sec_text
          if (!level_edit)
            screen_data.items[1].text = this.clock_text

        }

      }

      function spriteMove(sprite,x_speed,y_speed) {
        if (Math.abs(sprite.x - sprite.dx) < x_speed) sprite.x = sprite.dx
        else if (sprite.x < sprite.dx) sprite.x += x_speed
        else sprite.x -= x_speed

        if (Math.abs(sprite.y - sprite.dy) < y_speed) sprite.y = sprite.dy
        else if(sprite.y < sprite.dy) sprite.y += y_speed
        else sprite.y -= y_speed
      }

      // adds the current state of the player hand and board
      // to the undo state arrays
      function addStateForUndo (hand,board,undo) {

        var called_by_undo = undo || false

        // construct level string
        var level_string = ""
        // go through each stack
        for (var s = 0; s < board.stacks.length; s++) {
          // go through each item in the stack
          var this_stack = board.stacks[s]
          for (var i = 0; i < this_stack.items.length; i++) {
            // append this item string to level_string
            var this_item = this_stack.items[i]
            if (i>0) level_string = level_string + ","
            level_string = level_string + this_item.type + "|" + this_item.color
          }
          level_string = level_string + "\n"
        }

        // add level string to undo state array
        undo_board.push(level_string)

        // construct hand string
        var hand_string = ""        
        // go through each item in the stack
        for (var i = 0; i < hand.items.length; i++) {
          // append this item string to hand_string
          var this_item = hand.items[i]
          if (i>0) hand_string = hand_string + ","
          hand_string = hand_string + this_item.type + "|" + this_item.color
        }
        hand_string = hand_string + "\n"

        // update player.x of previous state
        if (undo_hand[undo_hand.length-1] != undefined && !called_by_undo) {
          undo_hand[undo_hand.length-1][0] = player.x
        }

        // add hand string to undo state array
        undo_hand.push([player.x,player.y,player.hand.level,hand_string,player.score])

        console.log("added hand and board states!")
        console.dir(undo_hand)
        console.dir(undo_board)

      }

      // takes back the players last action
      function undoLastMove (from_menu) {

        // SANITY CHECK!!!
        if (undo_hand.length <= 0 || undo_board.length <= 0 || !game_start || marathon)
          return

        var called_by_menu = from_menu || false

        console.log('UNDOING')

        // record this action for replays
        if (called_by_menu) {
          player.replay_data[player.timer.frame_ticker.toString()]
            = [player.x,player.y,"undo_menu",0]
          winlose_delay = WINLOSE_DELAY
        } else {
          player.replay_data[player.timer.frame_ticker.toString()]
            = [player.x,player.y,"undo",0]
        }

        console.log("replay_data")
        console.dir(player.replay_data)

        // disable player from earning stars and beating records
        if (!level_edit) {
          player_undid = true
          screen_data.items[0].locked = true
          screen_data.items[1].locked = true
          screen_data.items[2].locked = true
          winlose_data.items[0].locked = true
          winlose_data.items[1].locked = true
          winlose_data.items[2].locked = true
        }

        // reset item counts
        player.board.block_count = [0,0,0,0,0,0,0,0]
        player.board.flask_count = [0,0,0,0,0,0,0,0,0]
        player.board.robot_count = [0,0,0,0,0,0]

        // empty the players hand
        player.hand.items = new Array()
        Y_SPEED = FAST
        player.cursor_speed = Y_SPEED

        if (undo_hand.length > 1)
          undo_hand.pop()
        var player_state = undo_hand.pop()
        player.x = player_state[0]
        player.y = player_state[1]
        player.hand.level = player_state[2]
        var hand_state = player_state[3].split('\n')[0]
        player.score = player_state[4]
        if (!level_edit)
          screen_data.items[2].text = '\u03BB' + player.score
        else
          console.log("SCORE = " + player.score)

        // go through each item in this stack
        var items = (hand_state.length > 0) ? hand_state.split(',') : []
        for (var i=0; i < items.length; i++) {

          // construct new item from string data
          var item = items[i]
          var item_string = item.split('|')
          var type = item_string[0]
          var color = item_string[1]
          var this_item = new Item(player.hand,type,color,player.x,i)

          // push item to player hand
          player.hand.items.push(this_item)

          // update hand position
          this_item.x = player.x
          this_item.y = BOARD_HEIGHT - 1 - i
          this_item.stack = player.hand

          // update sprite destination
          this_item.sprite.dx = player.board.posx(this_item.x)
          this_item.sprite.dy = player.board.posy(this_item.y)

        }

        if (undo_board.length > 1)
          undo_board.pop()
        var board_state = undo_board.pop()

        player.board.clearBoard()
        player.board.fillLevel(player_level,player_stage,board_state)

        addStateForUndo(player.hand,player.board,true)

        console.log("popped the last hand and board states!")
        console.dir(undo_hand)
        console.dir(undo_board)
        console.dir(hand_state)
        console.dir(board_state)

        // finally, check for matches
        for(var s=0; s < player.board.stacks.length; s++) {
          var this_stack = player.board.stacks[s]
          this_stack.checkForMatches()
        }

      }

    }

    function pauseGame (pause_menu,player,restart_menu_item,save_menu_item) {

      if (pause) {
        return
      } else {
        pause = true
        pause_menu.active = true
        // pause all sounds currently playing
        // stopSounds()
      }


      // construct the pause menu
      pause_menu.items = new Array()
      console.log("CREATING PAUSE MENU")
      console.log("level_edit_play = " + level_edit_play)
      pause_menu.items.push(new MenuItem(pause_menu,"Resume",function() {
        pause = false
        // playPausedSounds()
        player.controls()
      }))
      if (level_edit && !level_edit_play) {
        pause_menu.items.push(new MenuItem(pause_menu,"Play Level",function() {
          pause = false
          level_edit_play = true
          // playPausedSounds()
          player.controls()
          jaws.start(Game)
        }))
      }
      pause_menu.items.push(((level_edit && !level_edit_play) ? save_menu_item : restart_menu_item))
      if (level_edit_play) {
        restart_menu_item.text = "Back to Editor"
        restart_menu_item.action = function() {
          level_edit_play = false
          jaws.start(Game)
        }
      }
      pause_menu.items.push(new MenuItem(pause_menu,"Back to Menu",function() {
        if (!level_edit) {

          // update marathon progress
          if (marathon) {
            if (player.timer.clock_text > marathon_progress[0])
              marathon_progress[0] = player.timer.clock_text
            if (player.score > marathon_progress[1])
              marathon_progress[1] = player.score

            // update player_save data and cookie data
            updateSaveAndCookie()
          }
          var record = buildRecordString(player.board,"Q")
          saveRecord(record)
          game_end = "Q"
        }
        if (level_edit)
          main_menu_auto = [3,player_level,player_stage]
        else if (marathon)
          main_menu_auto = [1,0,0]
        else if (replay != null)
          main_menu_auto = [6,0,0]
        else
          main_menu_auto = [0,player_level,player_stage]
        jaws.start(MainMenu)
      }))

      pause_menu.setup(pause_menu.x,pause_menu.y,pause_menu.width)

      console.log("constructed pause_menu = " + pause_menu.items.length)
    }

    function setupHowls () {
      // player sound effects
      grab_sound = new Howl({
        urls: ['./static/sfx/grab.mp3','./static/sfx/grab.ogg'],
        volume:.3
      })
      sound_effects.push(grab_sound)

      drop_sound = new Howl({
        urls: ['./static/sfx/drop.mp3','./static/sfx/drop.ogg'],
        volume:.3
      })
      sound_effects.push(drop_sound)
      // flask sound effects
      break_audio = new Howl({
        urls: ["./static/sfx/robot_death.mp3","./static/sfx/robot_death.ogg"],
        volume:.25
      })
      sound_effects.push(break_audio)
      brew_audio = new Howl({
        urls: ["./static/sfx/brew.mp3","./static/sfx/brew.ogg"],
        volume:.2
      })
      sound_effects.push(brew_audio)
      splash_audio = new Howl({
          urls: ["./static/sfx/break.mp3","./static/sfx/break.ogg"],
          volume:1
        })
      sound_effects.push(splash_audio)
      melt_audio = new Howl({
          urls: ["./static/sfx/melt1.mp3","./static/sfx/melt1.ogg"],
          volume:.1
      })
      sound_effects.push(melt_audio)
      white_audio = new Howl({
          urls: ["./static/sfx/white3.mp3","./static/sfx/white3.ogg"],
          volume:.5
      })
      sound_effects.push(white_audio)

      // // set onpause callback for each howl object
      // for (var i = 0; i < sound_effects.length; i++) {
      //   var this_sound = sound_effects[i]

      //   // push this sound onto the array of currently playing sounds
      //   this_sound.on('play', function() {
      //     playing_sound_effects.push(this)
      //   })

      //   // push this sound onto the array of currently paused sounds
      //   this_sound.on('pause', function() {
      //     paused_sound_effects.push(this)  
      //   })

      //   // remove this sound from array of currently playing sounds
      //   this_sound.on('end', function() {
      //     removeFromPlayingSounds(this)
      //   })


      // }
    }

    function setupSounds () {
      // player sound effects
      grab_sound = new jaws.Audio({
        volume:.3
      })
      grab_sound.setAudio("./static/sfx/grab.wav")
      sound_effects.push(grab_sound)

      drop_sound = new jaws.Audio({
        volume:.3
      })
      drop_sound.setAudio("./static/sfx/drop.wav")
      sound_effects.push(drop_sound)

      // flask sound effects
      break_audio = new jaws.Audio({
        volume:.25
      })
      break_audio.setAudio("./static/sfx/robot_death.wav")
      sound_effects.push(break_audio)

      brew_audio = new jaws.Audio({
        volume:.2
      })
      brew_audio.setAudio("./static/sfx/brew.wav")
      sound_effects.push(brew_audio)

      splash_audio = new jaws.Audio({
          volume:1
        })
      splash_audio.setAudio("./static/sfx/break.wav")
      sound_effects.push(splash_audio)

      melt_audio = new jaws.Audio({
          volume:.1
      })
      melt_audio.setAudio("./static/sfx/melt1.wav")
      sound_effects.push(melt_audio)

      white_audio = new jaws.Audio({
          volume:.5
      })
      white_audio.setAudio("./static/sfx/white3.wav")
      sound_effects.push(white_audio)

    }

    function stopSounds () {
      // stop all sounds
      for (var i=0; i<sound_effects.length;i++) {
        var this_sound = sound_effects[i]
        this_sound.stop()
      }
      playing_sound_effects = new Array()
    }

    function pauseSounds () {
      // pause all currently playing sounds
      for (var i=0; i<playing_sound_effects.length;i++) {
        var this_sound = playing_sound_effects[i]
        this_sound.pause()
      }
      playing_sound_effects = new Array()
    }

    function playPausedSounds() {

      if (mute)
        return

      // play all paused sounds
      for (var i=0; i<paused_sound_effects.length;i++) {
        var this_sound = paused_sound_effects[i]
        this_sound.play()
      }
      paused_sound_effects = new Array()
    }

    function removeFromPlayingSounds(this_sound) {
      var index = 0
      for (var j = 0; j < playing_sound_effects; j++) {
        if (this_sound == playing_sound_effects[j])
          break
        else
          index++
      }
      playing_sound_effects.splice(index,1);
    }

    function toggleMute() {
      if (mute) {
        $("muteButton").innerHTML = "Sound: On"
        mute = false
        stopSounds()
      } else {
        $("muteButton").innerHTML = "Sound: Off"
        mute = true
      }
    }

    function fisherYates ( myArray ) {
      var i = myArray.length, j, temp;
      if ( i === 0 ) return false;
      while ( --i ) {
         j = Math.floor( Math.random() * ( i + 1 ) );
         temp = myArray[i];
         myArray[i] = myArray[j];
         myArray[j] = temp;
       }
    }

    // construct record string
    function buildRecordString (board, winloss) {

      console.log("Buidling record string")

      var control_text = (board.player.keyboard_actions > board.player.mouse_actions) ? "KB" : (board.player.keyboard_actions == board.player.mouse_actions) ? "KM" : "MS"

      var record_object = {}

      record_object["name"] = player_name
      record_object["puzzle"] = (marathon) ? ("MRTHN-" + MAX_RAISE_LEVEL_TIME + "-" + MIN_RAISE_LEVEL_TIME + "-" + FREQ_RAISE_LEVEL_TIME) : (player_level + "-" + player_stage)
      record_object["result"] = (marathon) ? marathon_level : winloss
      record_object["score"] = board.player.score
      record_object["time"] = board.player.timer.clock_text
      record_object["moves"] = board.player.moves
      record_object["stars"] = starTotal()
      record_object["controls"] = control_text
      record_object["progress"] = star_progress
      record_object["time_end"] = new Date((+new Date()))
      record_object["replay"] = board.player.replay_data
      record_object["uid"] = player_uid
      record_object["score_sheet"] = board.player.score_sheet

      var record = "," + JSON.stringify(record_object) + "]"

      console.dir(record)
      game_record = record

      return record

    }

    function starTotal() {

      var total = 0
      for (var i = 0; i < star_progress.length; i++) {
        for (var key in star_progress[i]) {
          for (var j = 0; j < star_progress[i][key].length; j++)
          total += star_progress[i][key][j]
        }
      }

      return total

    }

    function setCookie(c_name,value,exdays) {
      var exdate=new Date();
      exdate.setDate(exdate.getDate() + exdays);
      var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
      document.cookie=c_name + "=" + c_value;
    }

    function getCookie(c_name) {
      var c_value = document.cookie;
      var c_start = c_value.indexOf(" " + c_name + "=");
      if (c_start == -1)
        {
        c_start = c_value.indexOf(c_name + "=");
        }
      if (c_start == -1)
        {
        c_value = null;
        }
      else
        {
        c_start = c_value.indexOf("=", c_start) + 1;
        var c_end = c_value.indexOf(";", c_start);
        if (c_end == -1)
        {
      c_end = c_value.length;
      }
      c_value = unescape(c_value.substring(c_start,c_end));
      }
      return c_value;
    }

    function updateSaveAndCookie() {
      // update player_save data
      var player_save = $("saveData")
      player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress) + "|" + player_uid + "|" + JSON.stringify(player_path)
      // update cookie save
      setCookie("player_save",player_save.innerHTML,360000)
    }

    function loadProgress(level_data,open_data) {

      var player_data = JSON.parse(open_data[2])
      var player_progress = []

      for (var i=0; i<level_data.levels.length; i++) {
        if (player_data[i]==undefined)
          player_progress.push([0,{}])
        else
          player_progress.push(player_data[i])
      }

      var star_data = JSON.parse(open_data[3])
      var star_progress = []

      for (var i=0; i<level_data.levels.length; i++) {
        if (star_data[i]==undefined)
          star_progress.push({})
        else
          star_progress.push(star_data[i])
      }

      return [player_progress,star_progress]

    }

    function clearProgress(level_data) {
      var player_progress = []
      var star_progress = []
      for (var i=0; i<level_data.levels.length; i++) {
        player_progress.push([0,{}])
        star_progress.push({})
      }

      console.log("CLEAR PROGRESS ARRAYS = ")
      console.dir([player_progress,star_progress])

      return [player_progress,star_progress]
    }

    // update star for a stage
    function updateStarProgress(player,player_level,player_stage,star_time,star_score,winlose_data) {

      var level_star_progress = star_progress[player_level]
      if (level_star_progress == undefined)
        star_progress.push({})
      var stage_star_progress = star_progress[player_level][player_stage.toString()]
      var new_stars = 0

      if (stage_star_progress == undefined) {
        star_progress[player_level][player_stage.toString()] = [1,0,0,0] // [complete,time,score,all]
        stage_star_progress = star_progress[player_level][player_stage.toString()]
        winlose_data.items[0].sprites[0].setImage("./static/images/STAR.gif")
        winlose_data.items[0].sprites[0].width = 15
        winlose_data.items[0].sprites[0].height = 15
        new_stars++
      } else {
        winlose_data.items[0].sprites[0].setImage("./static/images/STAR_BORDER.gif")
        winlose_data.items[0].sprites[0].width = 15
        winlose_data.items[0].sprites[0].height = 15
      }

      console.dir(winlose_data)

      var these_stars = 1

      // check if player got star time
      if (player.timer.clock_text <= star_time) {
        console.log("achieved star time = " + star_time)

        if (stage_star_progress[1] == 0) {
          winlose_data.items[1].sprites[0].setImage("./static/images/STAR.gif")
          winlose_data.items[1].sprites[0].width = 15
          winlose_data.items[1].sprites[0].height = 15
          new_stars++
        } else {
          winlose_data.items[1].sprites[0].setImage("./static/images/STAR_BORDER.gif")
          winlose_data.items[1].sprites[0].width = 15
          winlose_data.items[1].sprites[0].height = 15
        }

        stage_star_progress[1] = 1
        these_stars++
      }

      // check if player got star score
      if (player.score >= star_score) {
        console.log("achieved star score = " + star_score)

        if (stage_star_progress[2] == 0) {
          winlose_data.items[2].sprites[0].setImage("./static/images/STAR.gif")
          winlose_data.items[2].sprites[0].width = 15
          winlose_data.items[2].sprites[0].height = 15
          new_stars++
        } else {
          winlose_data.items[2].sprites[0].setImage("./static/images/STAR_BORDER.gif")
          winlose_data.items[2].sprites[0].width = 15
          winlose_data.items[2].sprites[0].height = 15
        }

        stage_star_progress[2] = 1
        these_stars++
      }

      // check if player got star time and star score
      if (these_stars >= 3) {
        console.log("achieved bonus star = " + star_score)

        if (stage_star_progress[3] == 0) {
          winlose_data.items[3].sprites[0].setImage("./static/images/STAR.gif")
          winlose_data.items[3].sprites[0].width = 15
          winlose_data.items[3].sprites[0].height = 15
          new_stars++
        } else {
          winlose_data.items[3].sprites[0].setImage("./static/images/STAR_BORDER.gif")
          winlose_data.items[3].sprites[0].width = 15
          winlose_data.items[3].sprites[0].height = 15
        }

        winlose_data.items[3].text = "Perfect"
        stage_star_progress[3] = 1
        these_stars++
      }

      console.log("stage_star_progress = ")
      console.dir(stage_star_progress)

      return new_stars

    }

    function replayMode (menus,replay_select_menu,level_select_ok,active_menu,level_record) {

      var input_string = window.prompt("enter player name","0501zonk1")

      if (input_string == null)
        return

      getRecords(function(data) {

        replay_records = []
        var records_data = JSON.parse(data)

        // cleanup script (removing duplicates where result = W)
        if (input_string == "cleanup") {

          var new_records = []

          for (var i = 0; i < records_data.length; i++) {
            var record_data = records_data[i]
            if (record_data["result"] != "W") {
              replay_records.push({"name":record_data["name"],"puzzle":record_data["puzzle"],"replay":record_data["replay"],"result":record_data["result"],"time_end":record_data["time_end"]})
              new_records.push(record_data)
            }
          }

          console.log("CLEANUP")
          console.dir(new_records)
          console.dir(JSON.stringify(new_records))

        } else {

          // get replay data
          for (var i = 0; i < records_data.length; i++) {
            var record_data = records_data[i]
            if (record_data["name"] == input_string)
              replay_records.push({"name":record_data["name"],"puzzle":record_data["puzzle"],"replay":record_data["replay"],"result":record_data["result"],"time_end":record_data["time_end"],"time":record_data["time"],"score":record_data["score"]})
          }

        }

        // construct replay mode menu
        replay_select_menu.items = []
        for (var i =0; i < replay_records.length; i++) {
          var this_replay = replay_records[i]
          var this_item = new MenuItem(replay_select_menu,this_replay["name"] + ":" + this_replay["puzzle"] + "-" + this_replay["result"],function() {
            var level_name = replay_records[this.index]["puzzle"].split("-")

            // marathon mode
            if (level_name[0] == "MRTHN") {
              player_level = 1
              player_stage = 1
              marathon = true
              MAX_RAISE_LEVEL_TIME = level_name[1]
              MIN_RAISE_LEVEL_TIME = level_name[2]
              FREQ_RAISE_LEVEL_TIME = level_name[3]

            // puzzle mode
            } else {
              player_level = level_name[0]
              player_stage = level_name[1]
              marathon = false
            }

            replay = replay_records[this.index]["replay"]
            replay_index = this.index
            jaws.start(Game)

          })
          this_item.index = i
          console.log("adding item to replay menu")
          replay_select_menu.items.push(this_item)
        }

        menus.push(replay_select_menu)
        menus.push(level_select_ok)
        replay_select_menu.submenus.push(level_select_ok)
        // level_select_ok.active = true
        level_select_ok.menu_box.active = true

        active_menu = replay_select_menu.parent.setActiveMenu(replay_select_menu,active_menu,level_select_ok)
        level_edit = false
        marathon = false
        replay_select_menu.controls(replay_select_menu,level_select_ok,menus)

      })

    }

    function getRecords (callback) {

      var json_data = JSON.stringify({'type': "getRecords"})

      console.log("attempting to retrieve records data")
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("records data retrieved! = ")
          console.dir(JSON.parse(data))
          callback(data)
          }
      });

    }

    function saveImage (level,stage,name,encoded_data) {

      var json_data = JSON.stringify({'type': "saveImage", 'data': encoded_data, 'level': [level,stage,name]})

      console.log("saving image with json_data = " + json_data)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("level image saved to server: " + data)
          }
      });

    }

    function saveRecord (record) {

      if (replay != null)
        return

      var json_data = JSON.stringify({'type': "saveRecord", 'data': record})

      console.log("savingRecord() with json_data = " + json_data)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("record POSTed to server: " + data)
          }
      });

    }

    function playerPath (name,callback) {

      if (replay != null)
        return

      var json_data = JSON.stringify({'type': "playerPath", 'data': name})

      console.log("determining player path with name = " + name)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("the path for player " + name + " is " + data)
          callback(data)
          }
      });

    }

    function saveLevel (level,stage,board,star_time,star_score,star_lock,level_name,callback) {

      console.log("saving stage = " + level + "-" + stage)

      // construct level string
      var level_string = ""

      // go through each stack
      console.log("stacks = " + board.stacks)
      for (var s = 0; s < board.stacks.length; s++) {

        var this_stack = board.stacks[s]
        // go through each item in the stack
        console.log("this_stack.items = " + this_stack.items)
        for (var i = 0; i < this_stack.items.length; i++) {

          var this_item = this_stack.items[i]
          if (i>0) level_string = level_string + ","
          level_string = level_string + this_item.type + "|" + this_item.color

          console.log ("adding item, level_string = " + level_string)

        }

        level_string = level_string + "\n"

      }

      level_string = level_string + star_time + "\n"
      level_string = level_string + star_score + "\n"
      level_string = level_string + star_lock + "\n"
      level_string = level_string + level_name + "\n"

      console.log("level_string = " + level_string)

      var json_data = JSON.stringify({'type': "saveLevel", 'data': level_string, 'level': [level,stage], 'name': level_name})

      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          window.alert("level saved to server: " + data)
          callback()
        }
      })

    }

    function updateLevel (level,stage,score,callback) {

      console.log("updating stage = " + level + "-" + stage)

      var this_data = level_data.levels[player_level][player_stage-1]

      // array of stacks in string form
      var stacks_string = this_data.split('\n')
      var star_time = stacks_string[6]
      var star_score = score

      // construct level string
      var level_string = ""
      for (var s = 0; s < BOARD_WIDTH; s++) {
        level_string += stacks_string[s] + "\n"
      }
      level_string += star_time.toString() + "\n"
      level_string += score

      console.log("level_string = " + level_string)

      var json_data = JSON.stringify({'type': "saveLevel", 'data': level_string, 'level': [level,stage]})

      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          window.alert("level saved to server: " + data)
          callback()
        }
      })

    }

    function loadLevel (level,stage,board,callback) {

      var json_data = JSON.stringify({'type': "loadLevel", 'level': [level,stage]})

      console.log("loading stage = " + level)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("retrieved level data from server = " + data)
          callback(data,board)
        }
      })

    }

    function loadLevels (callback) {
      var json_data = JSON.stringify({'type': "loadLevels"})

      console.log("loading levels")
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("retrieved level data from server" + data)
          callback(data)
        }
      })
    }

    function deleteLevel (level,level_name,callback) {

      var json_data = JSON.stringify({'type': "deleteLevel", 'level': [level,level_name,latest_edit]})

      console.log("deleting stage = " + level_name)
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("deleted level data from server. last level found = 0-" + data)
          callback(data)
        }
      })

    }

    function findEditLevels (callback) {

      var json_data = JSON.stringify({'type': "findEditLevels"})

      console.log("finding last edited level")
      jQuery.ajax({
        type: "POST",
        data: json_data,
        success: function(data) {
          console.log("last level found = 0-" + data)
          callback(data)
        }
      })

    }

    function MenuItem(menu,text,action) {

      this.menu = menu
      this.text = text
      this.action = action
      this.active = true
      this.index

      this.locked = false
      this.star_lock = 100

      this.description = ""

      this.color

      this.sprites = new Array()

    }

    function MenuBox(title,parent,x,y,width,items,scrolling,right_for_ok) {

      console.log("constructing menubox with title = " + this.title + " at (" + x + "," + y + ")")


      var SPRITE_WIDTH = 10

      this.title = title
      this.parent = parent // parent menu
      this.submenus = new Array() // submenus (ok box, etc.)

      this.x = x
      this.y = y
      this.width = width
      this.items = items // menu items
      this.index = 0 // item currently chosen
      this.back
      this.active = false
      this.mouse_inside = false
      this.scrolling = scrolling || false
      this.right_for_ok = right_for_ok || false
      this.old_mouse_x = jaws.mouse_x
      this.old_mouse_y = jaws.mouse_y

      this.setup = function(x,y,width) {

        this.x = x
        this.y = y
        // calculate height
        if (this.scrolling) {
          this.height = 70

          // level select arrows
          this.arrow_spritesheet = new jaws.SpriteSheet({
            image: "./static/images/ARROWS.gif", frame_size: [20,10]})

          this.up_arrow = new jaws.Sprite({x:this.x + 100, y:this.y + 20, image: this.arrow_spritesheet.frames[0]})
          this.down_arrow = new jaws.Sprite({x:this.x + 100, y:this.y + 38, image: this.arrow_spritesheet.frames[1]})

          this.up_arrow.height = 15
          this.down_arrow.height = 15

          this.up_arrow.mouse_over = false
          this.down_arrow.mouse_over  = false

          this.up_arrow.active = true
          this.down_arrow.active = true

          this.arrow_sprites = new Array()

          this.arrow_sprites.push(this.up_arrow)
          this.arrow_sprites.push(this.down_arrow)

        }
        else
          this.height = 20 * (this.items.length + ((this.title == "") ? 0 : 1)) + 30

        this.sprites = new Array()

        this.sprite_sheet = new jaws.SpriteSheet({
          image: "./static/images/MENUBOX_SPRITES.gif", frame_size: [SPRITE_WIDTH,SPRITE_WIDTH]})

        var edge_width  = width - SPRITE_WIDTH*2
        var edge_height = this.height - SPRITE_WIDTH*2

        this.sprites.push(new jaws.Sprite({x:x, y:y, image: this.sprite_sheet.frames[0]}))
        this.sprites.push(new jaws.Sprite({x:x + SPRITE_WIDTH, y:y, image: this.sprite_sheet.frames[1]}))
        this.sprites.push(new jaws.Sprite({x:x + SPRITE_WIDTH + edge_width, y:y, image: this.sprite_sheet.frames[2]}))
        this.sprites.push(new jaws.Sprite({x:x, y:y + SPRITE_WIDTH, image: this.sprite_sheet.frames[3]}))
        this.sprites.push(new jaws.Sprite({x:x + SPRITE_WIDTH + edge_width, y:y + SPRITE_WIDTH, image: this.sprite_sheet.frames[4]}))
        this.sprites.push(new jaws.Sprite({x:x, y:y + SPRITE_WIDTH + edge_height, image: this.sprite_sheet.frames[5]}))
        this.sprites.push(new jaws.Sprite({x:x + SPRITE_WIDTH, y:y + SPRITE_WIDTH + edge_height, image: this.sprite_sheet.frames[6]}))
        this.sprites.push(new jaws.Sprite({x:x + SPRITE_WIDTH + edge_width, y:y + SPRITE_WIDTH + edge_height, image: this.sprite_sheet.frames[7]}))

        // fix widths and heights for edges
        this.sprites[1].width = this.sprites[6].width = edge_width
        this.sprites[3].height = this.sprites[4].height = edge_height
      }

      this.setup(x,y,width)

      // provide coordinates of clicks with respect to menu item index
      this.menuCoordinates = function(x,y,right_click) {

        // find click coordinates with respect to board's top-left position in canvas
        var menu_x = x - this.x
        var menu_y = y - this.y

        var outside_x = false
        var outside_y = false

        if (menu_x < 0 || menu_x > this.width)
          outside_x = true
        if (menu_y < 0 || menu_y > this.height)
          outside_y = true

        if (outside_x || outside_y) {
          this.mouse_inside = false
          return this.index
        }

        var index = (menu_y - 30)/20 - ((this.title == "") ? 0 : 1)

        if (index < 0)
          index = 0
        else if (index > this.items.length - 1)
          index = this.items.length - 1

        this.mouse_inside = true
        return Math.round(index)
      }

      this.center = function(container_x,container_width) {

        this.x = container_x + (container_width/2) - (this.width/2)

      }

      this.scroll_action = function() {

        console.log("scrolling action")
        for (var i = 0; i < this.star_sprites.length; i++) {
          this.star_sprites[i].active = false
        }
        var level_name = this.items[this.index].text

        // activate ok submenu of this item is unlocked
        var level_index = 0
        for (var i = 0; i < this.items.length; i++)
          if (this.items[i].text == level_name) {
            level_index = i
            break
          }
        if (this.items[level_index].locked) {
          for (var i=0; i < this.submenus[0].menu_box.sprites.length; i++) {
            this.submenus[0].menu_box.sprites[i].active = true
          }
          this.submenus[0].menu_box.items[0].text = "      x " + ((this.items[level_index].star_lock == undefined) ? "?" : this.items[level_index].star_lock)
        } else {
          for (var i=0; i < this.submenus[0].menu_box.sprites.length; i++) {
            this.submenus[0].menu_box.sprites[i].active = false
          }
          this.submenus[0].menu_box.items[0].text = "OK"
        }

        // display how many stars player has earned for this level
        level_name = level_name.split("-")
        var level = parseInt(level_name[0])
        var stage = level_name[1]
        var these_stars = 0     
        console.log("star_progress = ")
        console.dir(star_progress)       
        if (star_progress[level][stage] != undefined) {
          for (var i = 0; i < star_progress[level][stage].length; i++) {        
            these_stars += star_progress[level][stage][i]
          }
        }
        for (var i = 0; i < these_stars; i++) {
          if (this.star_sprites[i] != undefined)
            this.star_sprites[i].active = true
        }

      }

      this.up_action = function() {
        console.log("up_action")
        if (this.index > 0) 

          if (this.scrolling) {
            var old_index = this.index
            this.index--
            while (!this.items[this.index].active && this.index > 0) {
              this.index--    
            }
            if (this.items[this.index].active)
              this.scroll_action()
            else
              this.index = old_index

          } else {
            this.index--
            while (!this.items[this.index].active && this.index > 0) {
              this.index--
            }
            if (!this.items[this.index].active)
              this.index++
          }
      }

      this.down_action = function() {
        console.log("down_action")
        if (this.index < this.items.length - 1) 

          if (this.scrolling) {
            var old_index = this.index
            this.index++
            while (!this.items[this.index].active && this.index < this.items.length - 1) {
              this.index++
            }
            if (this.items[this.index].active)
              this.scroll_action()     
            else 
              this.index = old_index         

          } else {
            this.index++
            while (!this.items[this.index].active && this.index < this.items.length - 1) {
              this.index++
            }
            if (!this.items[this.index].active)
              this.index--
          }
      }

      this.controls = function(menu,ok_submenu,menus) {

        jaws.on_keydown(["up","w"], function() {
          (menu.scrolling) ? menu.down_action() : menu.up_action()
        })

        jaws.on_keydown(["down","s"], function() {
          (menu.scrolling) ? menu.up_action() : menu.down_action()
        })

        jaws.on_keydown(["enter","space","k"], function() {
          if (menu.items[menu.index].active && !menu.items[menu.index].locked) {
            console.log("performing action")
            menu.items[menu.index].action(jaws)
          }
        })

        jaws.on_keydown(["right","d"], function() {
          if (!right_for_ok)
            return
          if (menu.items[menu.index].active && !menu.items[menu.index].locked) {
            console.log("performing action")
            menu.items[menu.index].action(jaws)
          }
        })

        jaws.on_keydown(["esc","a","left","j","z","c"], function() {
          if (scrolling)
            menus.pop()
          menu.back()
        })

        jaws.on_keydown(["left_mouse_button"], function() {

          if (menu.scrolling) {

            console.log("click button")
            if (menu.arrow_sprites[0].mouse_over) {
              menu.down_action()
              console.log("up button")
            }
            else if (menu.arrow_sprites[1].mouse_over) {
              console.log("click on down arrow")
              menu.up_action()
            }
            else if (ok_submenu.menu_box.mouse_inside) {
              if (!menu.items[menu.index].locked)
                menu.items[menu.index].action()
            } else if (menu.mouse_inside)
              return
            else {
              menus.pop()
              menu.back()
            }

          } else {
            if(menu.mouse_inside) {
              if(!menu.items[menu.index].locked && menu.items[menu.index].active)
                menu.items[menu.index].action()
            } else
              menu.back()
          }

        })

      }

      // sets the game to acknowledge a new active menu
      this.setActiveMenu = function(new_active,active_menu,ok_submenu) {
          console.log("set active menu!")
          this.active = false
          active_menu = new_active
          active_menu.active = true
          active_menu.controls(active_menu,ok_submenu)
          return active_menu
      }

      this.update = function() {

        if (this.scrolling) {
          // update arrow sprites
          for (var s=0; s < this.arrow_sprites.length; s++) {
            var this_sprite = this.arrow_sprites[s]

            if (jaws.mouse_x > this_sprite.x && jaws.mouse_x < this_sprite.x + this_sprite.width &&
                jaws.mouse_y > this_sprite.y && jaws.mouse_y < this_sprite.y + this_sprite.height) {
              this_sprite.mouse_over = true
            }
            else
              this_sprite.mouse_over = false

            if (this_sprite.mouse_over && this_sprite.image == this.arrow_spritesheet.frames[s])
              this_sprite.image = this.arrow_spritesheet.frames[s+2]
            else if (!this_sprite.mouse_over && this_sprite.image == this.arrow_spritesheet.frames[s+2])
              this_sprite.image = this.arrow_spritesheet.frames[s]
          }
        }

        for (var s=0; s < this.submenus.length; s++) {
          this.submenus[s].update()
        }

        return
      }

      this.draw = function() {

        // update index according to mouse position if menu is active
        if (this.active && !this.scrolling && this.old_mouse_x != jaws.mouse_x && this.old_mouse_x != jaws.mouse_x)
          this.index = this.menuCoordinates(jaws.mouse_x,jaws.mouse_y)

        this.old_mouse_x = jaws.mouse_x
        this.old_mouse_y = jaws.mouse_y

        jaws.context.fillStyle = "Black"
        jaws.context.fillRect(this.x + 2,this.y + 2,this.width - 4,this.height - 4)

        // draw edges
        // draw sprites
        for (var s=0; s < this.sprites.length; s++) {

          var this_sprite = this.sprites[s]

          if (s > 7 && !this_sprite.active) {
            this_sprite.mouse_over = false
            continue
          }

          this_sprite.draw()
        }

        // draw title
        var j = 0
        if (this.title != "") {
          jaws.context.font = MENU_FONT
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  "Red"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(this.title, this.x + 20, this.y + 30)
          j++
        }

        if (this.scrolling) {

          var this_item = this.items[this.index]

          jaws.context.font = MENU_FONT
          jaws.context.lineWidth = 10
          jaws.context.fillStyle =  (this_item.locked) ? "Brown" : "Red"
          jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
          jaws.context.fillText(this_item.text, this.x + 20, this.y + 20 * (1 + j) + 10)

          // draw arrow sprites
          for (var s = 0; s < this.arrow_sprites.length; s++) {
            this.arrow_sprites[s].draw()
          }

        } else {

          // draw menu items
          for (var i=0; i < this.items.length; i++) {

            var this_item = this.items[i]

            if (!this_item.active)
              continue

            jaws.context.font = MENU_FONT
            jaws.context.lineWidth = 10
            jaws.context.fillStyle =  (this_item.color == undefined) ? ((this.index == i) ? ((this_item.locked) ? "Brown" : "Red") : ((this_item.locked) ? "Grey" : "White")) : this_item.color
            jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
            jaws.context.fillText(this_item.text, this.x + 20, this.y + 20 * (i + 1 + j) + 10)

            // draw this menu item's sprites
            for (var s=0; s < this_item.sprites.length; s++) {
              this_item.sprites[s].draw()
            }

          }
        }

      }

    }

    // ok sub menu class
    function OkSubMenu(title,parent,action) {

      this.menu_box = new MenuBox(title,parent,parent.x, parent.y + parent.height, parent.width, [new MenuItem(parent,"OK",function() {
        action()
      })])

      this.sprites = new Array()

      this.update = function() {
        if (this.menu_box.active) {
          if (this.menu_box.mouse_inside)
            this.menu_box.index = 0
          else
            this.menu_box.index = -1
        }
      }

      this.draw = function() {
        this.menu_box.draw()
        for(var s=0; s<this.sprites.length; s++) {
          this.sprites[s].draw()
        }
      }

    }

    function MainMenu() {

      var active_menu
      var menus = new Array()
      var level_select_string = (player_progress.length-1) + "-" + player_progress[player_progress.length-1][0]
      var star_total_sprite
      var description_box
      var level_record
      var replay_record_box

      // unhide progress buttons
      var progress_buttons = $("progressButtons")
      progress_buttons.hidden = false
      $("live_info").innerHTML = ""

      // update player_save data and cookie data
      updateSaveAndCookie()

      this.back = function() {
          var this_menu = menus.pop()
          active_menu = this_menu.setActiveMenu(this_menu.parent,active_menu)
      }

      this.setup = function() {        

        // main menu
        var main_menu_items = new Array()
          main_menu_items.push(new MenuItem(main_menu,"Puzzle Mode",function() {
            menus.push(level_select_menu)
            menus.push(level_select_ok)
            level_select_menu.submenus.push(level_select_ok)
            // level_select_ok.active = true
            level_select_ok.menu_box.active = true
            if (level_select_menu)
            active_menu = level_select_menu.parent.setActiveMenu(level_select_menu,active_menu,level_select_ok)
            level_edit = false
            marathon = false
            level_select_menu.controls(level_select_menu,level_select_ok,menus)
            var level_count = 0
            for (var i = 1; i < player_progress.length; i++) {
              console.log(player_progress[i][0])
              level_count += parseInt(player_progress[i][0])
            }
            console.log("determining index")
            console.log("level_count = " + level_count)
            if (level_count + 1 >= level_select_menu.items.length)
              level_select_menu.index = level_select_menu.items.length - 1
            else
              level_select_menu.index = level_count
          
            for (var i = 0; i < level_select_menu.star_sprites.length; i++) {
              level_select_menu.star_sprites[i].active = false
            }
            level_select_menu.scroll_action()
              

          }))
          main_menu_items[main_menu_items.length-1].description
            = "Brew potions to destroy robots. Clear\n" +
            "all robots from the board to advance to\n" +
            "the next puzzle."
          main_menu_items.push(new MenuItem(main_menu,"Marathon Mode",function() {
            level_edit = false
            marathon = true
            replay = null
            jaws.start(Game)
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Brew potions to destroy robots.\n" +
            "Stacks rise toward the top of the board.\n" +
            "Try to survive and beat your high score!"

          var marathon_menu_item = main_menu_items[main_menu_items.length-1]
          marathon_menu_item.star_lock = MARATHON_STAR_LOCK
          marathon_menu_item.locked = (starTotal() >= marathon_menu_item.star_lock) ? false : true
          main_menu_items.push(new MenuItem(main_menu,"Change Name",function() {
            jaws.start(PlayerNameState)
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Change your name."
          main_menu_items.push(new MenuItem(main_menu,"Level Editor",function() {
            menus.push(level_edit_select)
            menus.push(level_select_ok)
            level_edit_select.submenus.push(level_select_ok)
            // level_select_ok.active = true
            level_select_ok.menu_box.active = true
            active_menu = level_edit_select.parent.setActiveMenu(level_edit_select,active_menu,level_select_ok)
            level_edit_select.controls(level_edit_select,level_select_ok,menus)
            level_edit = true
            marathon = false
            replay = null
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Let's make some levels, Kris."
          main_menu_items.push(new MenuItem(main_menu,"How to Play",function() {
            menus.push(help_menu)
            active_menu = help_menu.parent.setActiveMenu(help_menu,active_menu)
          }))
          main_menu_items[main_menu_items.length-1].active = true
          main_menu_items[main_menu_items.length-1].description
            = "Learn about the controls and score system."
          main_menu_items.push(new MenuItem(main_menu,"Save Progress",function() {
            menus.push(save_menu)
            active_menu = save_menu.parent.setActiveMenu(save_menu,active_menu)
            console.dir(active_menu)
          }))
          main_menu_items[main_menu_items.length-1].description
            = "Save, Load, or Reset your progress.\n"
          main_menu_items.push(new MenuItem(main_menu,"Replay Mode",function() {

            replayMode(menus,replay_select_menu,level_select_ok,active_menu,level_record)

          }))
        var main_menu = new MenuBox("",main_menu,ITEM_WIDTH,ITEM_WIDTH,200,main_menu_items,false,true)

        main_menu_items[0].active = puzzle_mode_active
        main_menu.items[2].active = change_name_active // set change name to be active
        main_menu.items[3].active = level_editor_active // set level editor to be active
        main_menu.items[6].active = replay_mode_active // set replay mode to be active

        menus.push(main_menu)
        active_menu = main_menu
        active_menu.active = true


        // level select menu
        var level_select_menu = new MenuBox("Level",main_menu,main_menu.x + main_menu.width + 1, main_menu.y, 150, new Array(),true,true)
        level_select_menu.back = this.back

        var level_select_ok = new OkSubMenu("",level_select_menu,function() {
          level_select_menu.items[menu.index].action(jaws)
        })

        // add level menu items
        console.log("ADDING LEVEL MENU ITEMS")
        console.dir(player_path)
        var item_count = 0
        for (var i = 1; i <= LEVEL_PATHS[player_path].length; i++) {
          console.log("add level menu item, i = " + i)
          console.log("playerpath level  = " + LEVEL_PATHS[player_path])
          if (level_data.levels[LEVEL_PATHS[player_path][i-1]] == undefined)
            continue
          for (var j = 0; j < level_data.levels[LEVEL_PATHS[player_path][i-1]].length; j++) {
            console.log("add level menu item, j = " + j)
            if (i == 1 && j+1 == 1)
              level_select_menu.index = item_count
            var this_level = new MenuItem(level_select_menu,(i + "-" + (j+1)),function() {
                var level_name = level_select_menu.items[level_select_menu.index].text
                level_name = level_name.split("-")
                player_level = level_name[0]
                player_stage = level_name[1]
                replay = null
                jaws.start(Game)
            })
            var this_level_star_lock = level_data.levels[LEVEL_PATHS[player_path][i-1]][j].split('\n')[8]
            this_level.star_lock = (this_level.text[0] != "1") ? ((this_level_star_lock == undefined) ? ZERO_STAR_LOCK : this_level_star_lock) : this_level_star_lock

            // set "l-1" to be active but locked unless star_lock met
            if (i == 1 && j == 0) {
              this_level.active = true
              this_level.locked = (starTotal() >= this_level.star_lock) ? false : true

            // set other puzzles to be inactive unless previous puzzle completed
            } else {

              console.log("j = " + j)
              console.log("player_progress = ")
              console.dir(player_progress)

              this_level.active = false

              if (j > 0) {
                if (j <= player_progress[i][0])
                  this_level.active = true
              } else {
                if (player_progress[i-1][0] >= 6)
                  this_level.active = true
              }
            }

            // set world 0 to be inactive
            if (i == 0)
              this_level.active = false

            level_select_menu.items.push(this_level)
            item_count++
          }
        }
        console.log("level_select_menu")
        console.dir(level_select_menu)

        // level select stars
        level_select_menu.star_sprites = new Array()
        var star_sprite_1 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+36,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_1.width = 15
        star_sprite_1.height = 15
        level_select_menu.sprites.push(star_sprite_1)
        level_select_menu.star_sprites.push(star_sprite_1)
        star_sprite_1.active = false

        var star_sprite_2 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+21,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_2.width = 15
        star_sprite_2.height = 15
        level_select_menu.sprites.push(star_sprite_2)
        level_select_menu.star_sprites.push(star_sprite_2)
        star_sprite_2.active = false

        var star_sprite_3 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+6,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_3.width = 15
        star_sprite_3.height = 15
        level_select_menu.sprites.push(star_sprite_3)
        level_select_menu.star_sprites.push(star_sprite_3)
        star_sprite_3.active = false

        var star_sprite_4 = new jaws.Sprite({x:level_select_menu.x,y:level_select_menu.y+51,image:"./static/images/STAR.gif",anchor:"left"})        
        star_sprite_4.width = 15
        star_sprite_4.height = 15
        level_select_menu.sprites.push(star_sprite_4)
        level_select_menu.star_sprites.push(star_sprite_4)
        star_sprite_4.active = false

        star_total_sprite = new jaws.Sprite({x:ITEM_WIDTH+140,y:13,image:"./static/images/STAR.gif",anchor:"left"})        
        star_total_sprite.width = 15
        star_total_sprite.height = 15
        console.log("star_total_sprite")
        console.dir(star_total_sprite)

        // lock sprite
        var lock_sprite = new jaws.Sprite({x:level_select_ok.menu_box.x+21,y:level_select_ok.menu_box.y,image:"./static/images/LOCK.gif",anchor:"left"})        
        console.log("lock_sprite")
        console.dir(lock_sprite)
        console.dir(level_select_ok)
        level_select_ok.menu_box.sprites.push(lock_sprite)
        lock_sprite.active = true

        // star lock sprite
        var star_lock_sprite = new jaws.Sprite({x:level_select_ok.menu_box.x+64,y:level_select_ok.menu_box.y+17,image:"./static/images/STAR.gif",anchor:"left"})        
        star_lock_sprite.width = 15
        star_lock_sprite.height = 15
        console.log("star_lock_sprite")
        console.dir(star_lock_sprite)
        console.dir(menus[0].submenus)
        level_select_ok.menu_box.sprites.push(star_lock_sprite)
        star_lock_sprite.active = true

        // marathon star lock menu
        var marathon_star_lock_menu = new OkSubMenu("",main_menu,function(){})
        marathon_star_lock_menu.menu_box.items[0].text = "      x " + main_menu.items[1].star_lock
        main_menu.submenus.push(marathon_star_lock_menu)
        marathon_star_lock_menu.menu_box.setup(main_menu.x + main_menu.width/2 + ITEM_WIDTH*2, main_menu.y + 20,level_select_ok.menu_box.width)
        marathon_star_lock_menu.menu_box.index = -1

        // level edit select menu
        level_edit_select = new MenuBox("Level",main_menu,main_menu.x + main_menu.width + 1, main_menu.y, 150, [],true)
        level_edit_select.back = this.back

        // add level edit menu items
        console.log("ADDING LEVEL EDIT MENU ITEMS")
        console.dir(level_data)
        var item_count = 0
        var sprint_items = []
        for (var i = 0; i < level_data.levels.length; i++) {
          for (var j = 0; j < level_data.levels[i].length; j++) {
            // console.log("i = " + i + ", j = " + j)
            var this_level = new MenuItem(level_edit_select,(i + "-" + (j+1)),function() {
                player_level = this.level
                player_stage = this.stage
                replay = null
                jaws.start(Game)
            })

            var data = level_data.levels[i][j].split('\n')
            this_level.text = (data[9]!=undefined)?data[9]:(i+"-"+(j+1).toString())
            this_level.level = i
            this_level.stage = j+1
            level_edit_select.items.push(this_level)
            if (i == 0 && j == level_data.levels[i].length-1) {
              var new_level = new MenuItem(level_select_menu,"[new]",function() {
                player_level = 0
                player_stage = level_data.levels[0].length + 1
                replay = null
                jaws.start(Game)
              })
              level_edit_select.items.push(new_level)
              console.dir(new_level)
              item_count++
              level_edit_select.index = item_count
            }
            // go through each key in sprints data to see if this level name encountered
            for (var key in sprints) {
              if (key == this_level.text) {
                sprint_items.push(key)
              }
            }

            console.dir(this_level)
            item_count++
          }
        }

        // add the rest of the sprints
        for (var key in sprints) {

          var added_already = false

          // check if it has been added already
          for (var i = 0; i < sprint_items.length; i++) {
            if (sprint_items[i] == key)
              added_already = true
          }

          if (!added_already) {
            var this_level = new MenuItem(level_edit_select,key,function() {
                replay = null
                sprint = true
                jaws.start(Game)
            })
            level_edit_select.items.push(this_level)
          }

        }

        console.log("level_edit_select")
        console.dir(level_edit_select)

        // replay menu
        var replay_select_menu = new MenuBox("Replay",main_menu,main_menu.x + main_menu.width + 1, main_menu.y, 150, new Array(),true,true)
        replay_select_menu.back = this.back

        // help menu
        var help_menu_items = new Array()
        help_menu_items.push(new MenuItem(help_menu, "Keyboard Control", function() {
          menus.push(keyboard_menu)
          active_menu = keyboard_menu.parent.setActiveMenu(keyboard_menu,active_menu)
          }))
        help_menu_items[help_menu_items.length-1].description
          = "Move cursor with the arrow keys (or WASD).\n"
          + "Press SPACE (or J) to grab items.\n"
          + "While grabbing, SPACE (or J) drops an item.\n"
          + "Press C (or K) to grab/drop a whole stack."
        help_menu_items.push(new MenuItem(help_menu, "Mouse Control", function() {
          menus.push(mouse_menu)
          active_menu = mouse_menu.parent.setActiveMenu(mouse_menu,active_menu)
          }))
        help_menu_items[help_menu_items.length-1].description
          = "Click items to grab them.\n"
          + "While holding, click the board to drop an\n"
          + "item or click on held items to drop them.\n"
          + "Right click to grab/drop a whole stack."
        help_menu_items.push(new MenuItem(help_menu, "Scoring", function() {return}))
        help_menu_items[help_menu_items.length-1].description
          = "Melting blocks gives you 1 point.\n"
          + "Brewing potions gives you 1 point.\n"
          + "Clear stacks of robots to multiply your score.\n"
          + "Perform chains to exponentiate your score.\n"
        help_menu_items.push(new MenuItem(help_menu, "Misc.", function() {return}))
        help_menu_items[help_menu_items.length-1].description
          = "CTRL+Z to undo your last move in Puzzle Mode.\n"
          + "(no stars can be earned if you undo)\n"
          + "Press L or click outside of the board\n"
          + "to make the stacks rise in Marathon Mode."
        var help_menu = new MenuBox("",main_menu,main_menu.x + main_menu.width + 1, main_menu.y + 40, 200, help_menu_items)
        help_menu.back = this.back

        if (starTotal() <= 0)
          main_menu.index = 4

        // save menu
        var save_menu_items = new Array()
          save_menu_items.push(new MenuItem(save_menu, "Save", function() {
            var player_save = $("saveData")
            player_save.innerHTML = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress) + "|" + player_uid + "|" + JSON.stringify(player_path)
            // update cookie save
            setCookie("player_save",player_save.innerHTML,360000)

            save_menu_items[0].description += "\n\nSaved."
          }))
          save_menu_items.push(new MenuItem(save_menu, "Export Save", function() {
            var save_string = "SuperWizardPotionSave|" + player_name + "|" + JSON.stringify(player_progress) + "|" + JSON.stringify(star_progress) + "|" + JSON.stringify(marathon_progress)
            save_string = sjcl.encrypt("zonky",save_string)
            window.prompt("Copy this text and keep it somewhere safe!",save_string)
          }))
          save_menu_items.push(new MenuItem(save_menu, "Import Save", function() {

            var input_string = window.prompt("enter save string","")

            input_string = sjcl.decrypt("zonky",input_string)

            // load save file
            var open_data = input_string.split("|")
            if (open_data[0] == "SuperWizardPotionSave") {

              console.log("open_data = ")
              console.dir(open_data)

              player_name = open_data[1]
              player_progress = JSON.parse(open_data[2])
              star_progress = JSON.parse(open_data[3])
              marathon_progress = JSON.parse(open_data[4])
              player_uid = open_data[5]
              $("openData").innerHTML = ""
              jaws.start(MainMenu)
            }
          }))
          save_menu_items.push(new MenuItem(save_menu, "Reset", function() {
            menus.push(reset_menu)
            reset_menu.index = 1
            active_menu = reset_menu.parent.setActiveMenu(reset_menu,active_menu)
          }))
        var save_menu = new MenuBox("",main_menu,main_menu.x + main_menu.width + 1, main_menu.y + 40, 160, save_menu_items, false, true)
        save_menu.back = this.back
        save_menu_items[0].description = "Save your progress manually\n"
          + "(the game autosaves after each level)."
        save_menu_items[1].description = "Back up your progress by exporting\n"
          + "it as a save string."
        save_menu_items[2].description = "Load your progress with\n"
          + "a save string."
        save_menu_items[3].description = "Delete all your progress.\n"

        // reset sub menu
        var reset_menu_items = new Array()
          reset_menu_items.push(new MenuItem(reset_menu, "Yes", function() {
            player_name = ""
            var reset_progress = clearProgress(level_data)
            player_progress = reset_progress[0]
            star_progress = reset_progress[1]
            marathon_progress = ["00:00",0]
            player_level = 1
            player_stage = 1
            main_menu_auto = undefined
            jaws.start(PlayerNameState)
          }))
          reset_menu_items.push(new MenuItem(reset_menu, "No", function() {
            reset_menu.back()
          }))
        var reset_menu = new MenuBox("Really?",save_menu,save_menu.x + save_menu.width + 1, save_menu.y, 150, reset_menu_items)
        reset_menu.index = 1
        reset_menu.back = function() {
          menus.pop()
          active_menu = reset_menu.setActiveMenu(reset_menu.parent,active_menu)
        }
        reset_menu_items[0].description = "Delete all your progress.\n"
          + "\nNo take-backsies. You might want\n"
          + "to Export Save first."
        reset_menu_items[1].description = "Delete all your progress.\n"
          + "\nNo take-backsies. You might want\n"
          + "to Export Save first."

        description_box = new MenuBox("",description_box,main_menu.x,main_menu.y+main_menu.height+1+ITEM_WIDTH/2,500, [new MenuItem(description_box,"",function(){}),new MenuItem(description_box,"",function(){}),new MenuItem(description_box,"",function(){}),new MenuItem(description_box,"",function(){})])
        description_box.index = -1

        // level record data
        var level_record_items = new Array()
        level_record_items.push(new MenuItem(level_record,"Completed!",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Time:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"Score:",function() {return}))
        level_record_items.push(new MenuItem(level_record,"",function() {return}))

        level_record = new MenuBox("",level_record,level_select_menu.x + level_select_menu.width - 30, level_select_menu.y+5, 230, level_record_items)
        level_record.index = -1

        // replay record data
        var replay_record_items = new Array()
        replay_record_items.push(new MenuItem(level_record,"",function() {return}))
        replay_record_items.push(new MenuItem(level_record,"",function() {return}))
        replay_record_items.push(new MenuItem(level_record,"",function() {return}))
        replay_record_items.push(new MenuItem(level_record,"",function() {return}))

        replay_record_box = new MenuBox("",replay_record_box,level_select_menu.x, level_select_ok.y+level_select_ok.height, 230, replay_record_items)
        replay_record_box.index = -1


        // add star sprites for level record data
        for (var s=0; s < level_record_items.length; s++) {
          var this_sprite = new jaws.Sprite({x:level_record.x,y:level_record.y+36 + 20*(s-1),anchor:"left",image:"./static/images/STAR.gif"})
          this_sprite.width = 15
          this_sprite.height = 15
          this_sprite.active = false
          level_record.sprites.push(this_sprite)

        }

        // go to submenu if specified by player quitting a level
        console.log("MAINMENUAUTO")
        console.dir(main_menu_auto)
        if (main_menu_auto != undefined) {
          if (main_menu_auto[0] == 0) {
            main_menu.items[main_menu_auto[0]].action()
            main_menu.index = main_menu_auto[0]
            var item_count = 0
            for (var i = 0; i < level_data.levels.length; i++) {
              for (var j = 0; j < level_data.levels[i].length; j++) {
                var this_level = level_select_menu.items[item_count]
                var level_name = this_level.text.split("-")
                if (main_menu_auto[1]==level_name[0] && main_menu_auto[2]==level_name[1]) {
                  level_select_menu.index = item_count
                  break
                }
                item_count++
              }
            }
          } else {
              main_menu.index = main_menu_auto[0]
              active_menu.controls(active_menu)
            }
        } else
        // controls
        active_menu.controls(active_menu)
        console.log("menus!")
        console.dir(menus)
      }

      this.update = function() {

        // load save file
        var open_data = $("openData").innerHTML.split("|")
        if (open_data[0] == "SuperWizardPotionSave") {

          console.log("MAIN MENU open_data = ")
          console.dir(open_data)

          player_name = open_data[1]
          // player_progress = JSON.parse(open_data[2])
          // star_progress = JSON.parse(open_data[3])
          loadProgress(level_data,JSON.parse(open_data))
          marathon_progress = JSON.parse(open_data[4])
          player_uid = open_data[5]
          $("openData").innerHTML = ""
          jaws.start(MainMenu)
        }

        // update description box
        // var description = menus[0].items[menus[0].index].description.split("\n")
        var description = active_menu.items[active_menu.index].description.split("\n")
        for (var i=0; i < description_box.items.length; i++) {
          description_box.items[i].text = (description[i] == undefined) ? "" : description[i]
        }
          
        for (var i = 0; i < menus.length; i++) {
          menus[i].update()
        }

      }

      this.draw = function() {

        jaws.context.fillStyle = "Black"
        jaws.context.fillRect(0,0,jaws.width,jaws.height)

        // player name
        jaws.context.font = MENU_FONT
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Red"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText(player_name, ITEM_WIDTH + 17, 28)

        // star sprite
        star_total_sprite.x = ITEM_WIDTH + 19 + player_name.length*12.5
        star_total_sprite.draw()

        // player star count
        jaws.context.font = MENU_FONT
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "White"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText("x " + starTotal(), star_total_sprite.x + star_total_sprite.width + 10, 28)

        for (var i = 0; i < menus.length; i++) {
          menus[i].draw()
        }

        // draw description box
        if (menus[0].index == 1 && menus[0].items[1].locked) {
          var marathon_submenu = menus[0].submenus[0]
          marathon_submenu.sprites.push(new jaws.Sprite({x:marathon_submenu.menu_box.x+21,y:marathon_submenu.menu_box.y,image:"./static/images/LOCK.gif",anchor:"left"}))
          var star_lock_sprite = new jaws.Sprite({x:marathon_submenu.menu_box.x+64,y:marathon_submenu.menu_box.y+17,image:"./static/images/STAR.gif",anchor:"left"})
          star_lock_sprite.width = 15
          star_lock_sprite.height = 15
          marathon_submenu.sprites.push(star_lock_sprite)
          menus[0].submenus[0].draw()
        } else if (menus[0].index == 1){
          var marathon_submenu = menus[0].submenus[0]
          marathon_submenu.menu_box.items[0].text = "Best Time:  " + marathon_progress[0]
          if (marathon_submenu.menu_box.items[1] == undefined) {
            marathon_submenu.menu_box.items.push(new MenuItem(marathon_submenu.menu_box,"High Score:",function(){return}))
            marathon_submenu.menu_box.setup(marathon_submenu.menu_box.x,marathon_submenu.menu_box.y,marathon_submenu.menu_box.width+30)
          }
          marathon_submenu.menu_box.items[1].text = "High Score: \u03BB" + marathon_progress[1]
          marathon_submenu.menu_box.index = -1
          marathon_submenu.draw()
        }
        if (active_menu.items[active_menu.index].description != "" && active_menu.items[active_menu.index].active)
          description_box.draw()

        // draw level record
        if (menus[0].index == 0 && menus[1] != undefined && menus[1].title == "Level") {
          var level_select_submenu = menus[1]
          var level_menu_item = level_select_submenu.items[level_select_submenu.index]
          var level_name = level_menu_item.text.split("-")
          var level = parseInt(level_name[0])
          var stage = level_name[1]
          if (player_progress[level][1][stage] != undefined) {
            level_record.items[1].text = "Best Time:  " + player_progress[level][1][stage][0]
            level_record.items[2].text = "High Score: \u03BB" + player_progress[level][1][stage][1]
            
            // show appropriate stars
            level_record.sprites[0].active = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? true : false
            level_record.sprites[1].active = (star_progress[level][stage] != undefined && star_progress[level][stage][1] > 0) ? true : false
            level_record.sprites[2].active = (star_progress[level][stage] != undefined && star_progress[level][stage][2] > 0) ? true : false
            level_record.sprites[3].active = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? true : false
            level_record.items[0].text = (star_progress[level][stage] != undefined && star_progress[level][stage][0] > 0) ? "Completed!" : "Completed (undo)"
            if (star_progress[level][stage] == undefined) {
              level_menu_item.description = "Complete the level without\n"
                + "undoing to earn stars."
            } else
              level_menu_item.description = ""
            level_record.items[3].text = (star_progress[level][stage] != undefined && star_progress[level][stage][3] > 0) ? "Perfect" : ""
            if (!level_menu_item.locked) {
              level_record.draw()
            }
          }
        } else if (menus[0].index == 6 && menus[1] != undefined) {

          // replay record data
          replay_record_box.setup(menus[1].x,menus[1].y+menus[1].height, 230)

          var this_replay = replay_records[menus[1].index]
          replay_record_box.items[0].text = this_replay["puzzle"]
          replay_record_box.items[1].text = "Time:   " + this_replay["time"]
          replay_record_box.items[2].text = "Score:  " + this_replay["score"]
          replay_record_box.items[3].text = "Result: " + this_replay["result"]
          replay_record_box.draw()
        }        

      }

    }

    function PlayerNameState() {

      var disablekeys = false

      messageConsole = function() {
        console.log("player_name = " + player_name)
        if (disablekeys)
          player_name = player_name.substring(0,player_name.length-1)
      }

      var name_text = "       " + player_name
      if (player_name.length < 10) name_text = name_text + "_"

      var enter_name
      var enter_name_items = new Array()
        enter_name_items.push(new MenuItem(enter_name,"Please enter your name: ",function(){return
        }))
        enter_name_items.push(new MenuItem(enter_name,name_text,function(){
          return
        }))

      enter_name = new MenuBox("",enter_name,ITEM_WIDTH,ITEM_WIDTH,300,enter_name_items)
      enter_name.index = 1

      // enter name OK sub menu
      var enter_name_ok = new MenuBox("",enter_name,enter_name.x, enter_name.y + enter_name.height, 300, [new MenuItem(enter_name_ok,"          OK",function() {
        if (player_name.length > 0)
          jaws.switchGameState(MainMenu)
      })])
      enter_name_ok.active = true

      this.setup = function() {

        this.controls(enter_name,enter_name_ok)
      }

      this.draw = function() {

        // load save file
        var open_data = $("openData").innerHTML.split("|")
        if (open_data[0] == "SuperWizardPotionSave") {
          player_name = open_data[1]
          player_progress = JSON.parse(open_data[2])
          star_progress = JSON.parse(open_data[3])
          marathon_progress = JSON.parse(open_data[4])
          player_uid = open_data[5]
          $("openData").innerHTML = ""
          jaws.start(MainMenu)
        }

        jaws.context.clearRect(0,0,jaws.width,jaws.height)

        jaws.context.fillStyle = "Black"
        jaws.context.fillRect(0,0,jaws.width,jaws.height)

        // update name_text
        name_text = "       " + player_name
        if (player_name.length < 10) name_text = name_text + "_"
        enter_name.items[1].text = name_text
        enter_name.draw()

        if (enter_name_ok.active) {
          if (enter_name_ok.mouse_inside)
            enter_name_ok.index = 0
          else
            enter_name_ok.index = -1
        }
        enter_name_ok.draw()

        jaws.context.font = "bold 30pt terminal";
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Black"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"
        jaws.context.fillText("Please enter your name:", 125, 225)

        jaws.context.font = "bold 30pt terminal";
        jaws.context.lineWidth = 10
        jaws.context.fillStyle =  "Black"
        jaws.context.strokeStyle =  "rgba(200,200,200,0.0)"

        var name_text = player_name
        if (player_name.length < 10) name_text += "_"

        jaws.context.fillText(name_text, 210, 275)
      }

      this.controls = function(menu,ok_submenu) {


        var shift = false

        jaws.on_keydown(["left_mouse_button"], function() {

          if (ok_submenu.mouse_inside) {
            ok_submenu.items[ok_submenu.index].action()
          }
        })

        jaws.on_keydown(["shift"], function () {
          shift = true
        })

        jaws.on_keyup(["shift"], function () {
          shift = false
        })

        jaws.on_keydown(["enter"],  function()  {

          disablekeys = true

          // check which path this player will be taking
          playerPath(player_name, function(data) {

            console.log("in a callback with data = " + data)

            if (data < 0) {
              player_path = 3
              puzzle_mode_active = false
              // jaws.start(PlayerNameState)
            } else {
              player_path = data
              puzzle_mode_active = true
            }

            if (player_name.length > 0) {
              jaws.switchGameState(MainMenu)
            } else
              jaws.start(PlayerNameState)

          })

        } )

        jaws.on_keydown(["backspace"], function() {

          if (disablekeys)
            return

          player_name = player_name.substring(0,player_name.length-1)
          messageConsole()
        })

        jaws.on_keydown(["space"], function () {
          if (player_name.length < 10)
            player_name += " "
          messageConsole()
        })

        jaws.on_keydown(["a"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "A" : "a"
          messageConsole()
        })

        jaws.on_keydown(["b"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "B" : "b"
          messageConsole()
        })

        jaws.on_keydown(["c"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "C" : "c"
          messageConsole()
        })

        jaws.on_keydown(["d"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "D" : "d"
          messageConsole()
        })

        jaws.on_keydown(["e"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "E" : "e"
          messageConsole()
        })

        jaws.on_keydown(["f"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "F" : "f"
          messageConsole()
        })

        jaws.on_keydown(["g"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "G" : "g"
          messageConsole()
        })

        jaws.on_keydown(["h"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "H" : "h"
          messageConsole()
        })

        jaws.on_keydown(["i"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "I" : "i"
          messageConsole()
        })

        jaws.on_keydown(["j"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "J" : "j"
          messageConsole()
        })

        jaws.on_keydown(["k"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "K" : "k"
          messageConsole()
        })

        jaws.on_keydown(["l"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "L" : "l"
          messageConsole()
        })

        jaws.on_keydown(["m"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "M" : "m"
          messageConsole()
        })

        jaws.on_keydown(["n"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "N" : "n"
          messageConsole()
        })

        jaws.on_keydown(["o"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "O" : "o"
          messageConsole()
        })

        jaws.on_keydown(["p"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "P" : "p"
          messageConsole()
        })

        jaws.on_keydown(["q"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "Q" : "q"
          messageConsole()
        })

        jaws.on_keydown(["r"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "R" : "r"
          messageConsole()
        })

        jaws.on_keydown(["s"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "S" : "s"
          messageConsole()
        })

        jaws.on_keydown(["t"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "T" : "t"
          messageConsole()
        })

        jaws.on_keydown(["u"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "U" : "u"
          messageConsole()
        })

        jaws.on_keydown(["v"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "V" : "v"
          messageConsole()
        })

        jaws.on_keydown(["w"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "W" : "w"
          messageConsole()
        })

        jaws.on_keydown(["x"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "X" : "x"
          messageConsole()
        })

        jaws.on_keydown(["y"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "Y" : "y"
          messageConsole()
        })

        jaws.on_keydown(["z"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "Z" : "z"
          messageConsole()
        })

        jaws.on_keydown(["0"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? ")" : "0"
          messageConsole()
        })

        jaws.on_keydown(["1"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "!" : "1"
          messageConsole()
        })

        jaws.on_keydown(["2"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "@" : "2"
          messageConsole()
        })

        jaws.on_keydown(["3"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "#" : "3"
          messageConsole()
        })

        jaws.on_keydown(["4"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "$$" : "4"
          messageConsole()
        })

        jaws.on_keydown(["5"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "%" : "5"
          messageConsole()
        })

        jaws.on_keydown(["6"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "^" : "6"
          messageConsole()
        })

        jaws.on_keydown(["7"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "&" : "7"
          messageConsole()
        })

        jaws.on_keydown(["8"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "*" : "8"
          messageConsole()
        })

        jaws.on_keydown(["9"], function () {
          if (player_name.length < 10)
            player_name += (shift) ? "(" : "9"
          messageConsole()
        })
      }
    }

    jaws.onload = function() {
      console.log("Bugs: need to check if there's enough flasks for lose condition")
      jaws.unpack()
      var assets_array = ["./static/images/CURSOR.gif","./static/images/STAR.gif","./static/images/STAR_BORDER.gif","./static/images/STAR_SHADOW.gif","./static/images/LOCK.gif","./static/images/BLUE.gif","./static/images/GREEN.gif","./static/images/RED.gif","./static/images/YELLOW.gif","./static/images/PURPLE.gif","./static/images/WHITE.gif","./static/images/ORANGE.gif","./static/images/POTION_EMPTY.gif","./static/images/POTION_BLUE.gif","./static/images/POTION_GREEN.gif","./static/images/POTION_RED.gif","./static/images/POTION_YELLOW.gif","./static/images/POTION_PURPLE.gif","./static/images/POTION_WHITE.gif","./static/images/POTION_ORANGE.gif","./static/images/POTION_SPRITES.gif","./static/images/ROBOT_RED.gif","./static/images/ROBOT_WHITE.gif","./static/images/ROBOT_YELLOW.gif","./static/images/ROBOT_PURPLE.gif","./static/images/ROBOT_GREEN.gif","./static/images/ROBOT_BLUE.gif","./static/images/ROBOT_ORANGE.gif","./static/images/ROBOT_RED_DEATH.gif","./static/images/ROBOT_YELLOW_DEATH.gif","./static/images/ROBOT_PURPLE_DEATH.gif","./static/images/ROBOT_RED_SPLASH.gif","./static/images/ROBOT_BLUE_SPLASH.gif","./static/images/ROBOT_YELLOW_SPLASH.gif","./static/images/ROBOT_GREEN_SPLASH.gif","./static/images/ROBOT_PURPLE_SPLASH.gif","./static/images/ROBOT_ORANGE_SPLASH.gif","./static/images/POTION_SPLASH.gif","./static/images/BOARD.gif","./static/images/CHAIN.gif","./static/images/MENUBOX_SPRITES.gif","./static/images/ARROWS.gif","./static/images/CAULDRON.gif","./static/images/WIZARD.gif"]

      // "./static/sfx/grab.wav","./static/sfx/drop.wav","./static/sfx/robot_death.wav","./static/sfx/brew.wav","./static/sfx/break.wav","./static/sfx/melt1.wav","./static/sfx/white3.wav"

      jaws.assets.add(assets_array)

      console.log("loading levels")
      loadLevels(function(data) {

        level_data = JSON.parse(data)
        if (cookie_save != null && cookie_save != "") {
          console.log("cookie loaded")
          console.log(cookie_save.toString())
          var open_data = cookie_save.split("|")
          if (open_data[0] == "SuperWizardPotionSave") {

            console.log("open_data = ")
            console.dir(open_data)

            player_name = open_data[1]
            // player_progress = JSON.parse(open_data[2])
            // star_progress = JSON.parse(open_data[3])
            var loaded_progress = loadProgress(level_data,open_data)
            player_progress = loaded_progress[0]
            star_progress = loaded_progress[1]
            marathon_progress = JSON.parse(open_data[4])
            player_uid = open_data[5]
            player_path = parseInt(JSON.parse(open_data[6]))
            if (player_path == undefined || player_path < 0)
              player_path = 3 // fix old cookies

            name_entered = true
          }
        } else {
          console.log("failed to load cookie data")

          // clear progress
          var cleared_progress = clearProgress(level_data)
          player_progress = cleared_progress[0]
          star_progress = cleared_progress[1]

          // generate unique id for this player
          player_uid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
              var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
              return v.toString(16);
          });
          console.log(player_uid)
        }

        // sprints
        sprints = JSON.parse(level_data.sprints)
        console.log("SPRITNS")
        console.dir(sprints)

        latest_edit = level_data.levels[0].length + 1
        player_progress[0][0] = latest_edit - 2
        console.log("player_progress = " + player_progress[0][0])
        console.dir(player_progress)

        if (name_entered)
          jaws.start(MainMenu)  // Our convenience function jaws.start() will load assets, call setup and loop update/draw in 60 FPS
        else
          jaws.start(PlayerNameState)
      })

    }

  </script>

</body>
</html>

